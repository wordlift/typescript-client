/* tslint:disable */
/* eslint-disable */
/**
 * Embeddings API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'analytics_client_factory'?: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'analyzerId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'botify_project'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'botify_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'botify_username'?: string;
    /**
     * The collection hosing the Knowledge Graph.
     * @type {string}
     * @memberof Account
     */
    'collection'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     * @deprecated
     */
    'datasetId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'datasetUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'domainUri'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'google_search_console_site_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'indexed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Account
     */
    'is_wordpress'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'ngDatasetId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'resolvedUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'subscriptionId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'wpAdmin'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'wpJson'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'wp_include_exclude_default'?: string;
}
/**
 * Account Information
 * @export
 * @interface AccountInfo
 */
export interface AccountInfo {
    /**
     * The Account Id
     * @type {number}
     * @memberof AccountInfo
     */
    'accountId': number;
    /**
     * The Dataset Id
     * @type {string}
     * @memberof AccountInfo
     */
    'datasetId'?: string;
    /**
     * The dataset URI
     * @type {string}
     * @memberof AccountInfo
     */
    'datasetUri': string;
    /**
     * A list of features enabled or disabled for the account
     * @type {{ [key: string]: boolean; }}
     * @memberof AccountInfo
     */
    'features'?: { [key: string]: boolean; };
    /**
     * Google Search Console Site URL
     * @type {string}
     * @memberof AccountInfo
     */
    'googleSearchConsoleSiteUrl'?: string;
    /**
     * The default setting for include/exclude URLs.
     * @type {string}
     * @memberof AccountInfo
     */
    'includeExcludeDefault'?: string;
    /**
     * The Key
     * @type {string}
     * @memberof AccountInfo
     */
    'key'?: string;
    /**
     * The language code
     * @type {string}
     * @memberof AccountInfo
     */
    'language'?: string;
    /**
     * A list of connected Account Information
     * @type {Array<NetworkAccountInfo>}
     * @memberof AccountInfo
     */
    'networks': Array<NetworkAccountInfo>;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'ngDatasetId'?: string;
    /**
     * The Subscription Id
     * @type {number}
     * @memberof AccountInfo
     */
    'subscriptionId': number;
    /**
     * The website URL
     * @type {string}
     * @memberof AccountInfo
     */
    'url'?: string;
    /**
     * If WordPress, the WP-ADMIN URL
     * @type {string}
     * @memberof AccountInfo
     */
    'wpAdmin'?: string;
    /**
     * If WordPress, the WP-JSON end-point
     * @type {string}
     * @memberof AccountInfo
     */
    'wpJson'?: string;
}
/**
 * The Account statistics
 * @export
 * @interface AccountStats
 */
export interface AccountStats {
    /**
     * The number of entities.
     * @type {number}
     * @memberof AccountStats
     */
    'entities': number;
    /**
     * The number of entities with URL.
     * @type {number}
     * @memberof AccountStats
     */
    'entities_with_url': number;
    /**
     * The number of product groups in the KG.
     * @type {number}
     * @memberof AccountStats
     */
    'product_groups': number;
    /**
     * The number of products in the KG.
     * @type {number}
     * @memberof AccountStats
     */
    'products': number;
}
/**
 * 
 * @export
 * @interface AccountSubscription
 */
export interface AccountSubscription {
    /**
     * 
     * @type {string}
     * @memberof AccountSubscription
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountSubscription
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccountSubscription
     */
    'last_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountSubscription
     */
    'order_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountSubscription
     */
    'sku'?: string;
}
/**
 * An array of objects.
 * @export
 * @interface ActiveAccount
 */
export interface ActiveAccount {
    /**
     * The collection hosting the Knowledge Graph.
     * @type {string}
     * @memberof ActiveAccount
     */
    'collection'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActiveAccount
     */
    'country'?: string;
    /**
     * 
     * @type {Array<DiagnosticPlugin>}
     * @memberof ActiveAccount
     */
    'diagnostic_plugins'?: Array<DiagnosticPlugin>;
    /**
     * 
     * @type {string}
     * @memberof ActiveAccount
     */
    'domain_uri'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActiveAccount
     */
    'google_search_console_site_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActiveAccount
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ActiveAccount
     */
    'is_wordpress'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ActiveAccount
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActiveAccount
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActiveAccount
     */
    'ng_dataset_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActiveAccount
     */
    'package_type'?: string;
    /**
     * 
     * @type {AccountSubscription}
     * @memberof ActiveAccount
     */
    'subscription'?: AccountSubscription;
    /**
     * 
     * @type {number}
     * @memberof ActiveAccount
     */
    'subscription_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActiveAccount
     */
    'total_entities'?: number;
    /**
     * 
     * @type {number}
     * @memberof ActiveAccount
     */
    'total_entities_with_schema_url'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActiveAccount
     */
    'url'?: string;
    /**
     * 
     * @type {number}
     * @memberof ActiveAccount
     */
    'user_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ActiveAccount
     */
    'wp_admin'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActiveAccount
     */
    'wp_include_exclude_default'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActiveAccount
     */
    'wp_json'?: string;
}
/**
 * An Add-On configuration
 * @export
 * @interface AddOnConfiguration
 */
export interface AddOnConfiguration {
    /**
     * Whether this Add-on can do content expansion
     * @type {boolean}
     * @memberof AddOnConfiguration
     */
    'can_do_content_expansion'?: boolean;
    /**
     * Whether this Add-on can import to WordPress.
     * @type {boolean}
     * @memberof AddOnConfiguration
     */
    'can_import_to_wordpress'?: boolean;
    /**
     * A key
     * @type {string}
     * @memberof AddOnConfiguration
     */
    'key'?: string;
    /**
     * The wp-admin endpoint for a website using the key.
     * @type {string}
     * @memberof AddOnConfiguration
     */
    'wp_admin'?: string;
    /**
     * The wp-json endpoint for a website using the key.
     * @type {string}
     * @memberof AddOnConfiguration
     */
    'wp_json'?: string;
}
/**
 * The analysis request.
 * @export
 * @interface AnalysesRequest
 */
export interface AnalysesRequest {
    /**
     * The text to analyse.
     * @type {string}
     * @memberof AnalysesRequest
     */
    'text'?: string;
    /**
     * The URL to analyse.
     * @type {string}
     * @memberof AnalysesRequest
     */
    'url'?: string;
    /**
     * The query string to analyse.
     * @type {string}
     * @memberof AnalysesRequest
     */
    'query'?: string;
    /**
     * The html to analyse.
     * @type {string}
     * @memberof AnalysesRequest
     */
    'html'?: string;
    /**
     * The language code used for content analysis, e.g. `en`.
     * @type {string}
     * @memberof AnalysesRequest
     */
    'language_code'?: string;
    /**
     * The location name for the query, e.g. United Kingdom.
     * @type {string}
     * @memberof AnalysesRequest
     */
    'query_location_name'?: string;
    /**
     * The search engine domain for the query, if not set will be chosen according to `query_location_name`
     * @type {string}
     * @memberof AnalysesRequest
     */
    'query_search_engine'?: string;
    /**
     * Whether to include results from Linked Data (e.g. DBpedia), by default true.
     * @type {boolean}
     * @memberof AnalysesRequest
     */
    'linked_data'?: boolean;
    /**
     * Whether to include results from the local Knowledge Graph, by default true.
     * @type {boolean}
     * @memberof AnalysesRequest
     */
    'local_data'?: boolean;
    /**
     * Whether to include results from connected Knowledge Graphs, by default true.
     * @type {boolean}
     * @memberof AnalysesRequest
     */
    'network_data'?: boolean;
}
/**
 * 
 * @export
 * @interface AnalysesResponse
 */
export interface AnalysesResponse {
    /**
     * 
     * @type {Array<AnalysesResponseItem>}
     * @memberof AnalysesResponse
     */
    'items'?: Array<AnalysesResponseItem>;
}
/**
 * 
 * @export
 * @interface AnalysesResponseItem
 */
export interface AnalysesResponseItem {
    /**
     * The text matching the entity.
     * @type {string}
     * @memberof AnalysesResponseItem
     */
    'text'?: string;
    /**
     * The confidence score this is the right entity.
     * @type {number}
     * @memberof AnalysesResponseItem
     */
    'confidence'?: number;
    /**
     * The number of occurrences.
     * @type {number}
     * @memberof AnalysesResponseItem
     */
    'occurrences'?: number;
    /**
     * The position of the entity in SERP. `null` if not applicable.
     * @type {number}
     * @memberof AnalysesResponseItem
     */
    'serp_position'?: number;
    /**
     * The entity id (URI).
     * @type {string}
     * @memberof AnalysesResponseItem
     */
    'entity_id'?: string;
    /**
     * The entity label.
     * @type {string}
     * @memberof AnalysesResponseItem
     */
    'entity_label'?: string;
    /**
     * The entity type.
     * @type {string}
     * @memberof AnalysesResponseItem
     */
    'entity_type'?: string;
    /**
     * The entity description.
     * @type {string}
     * @memberof AnalysesResponseItem
     */
    'entity_description'?: string;
}
/**
 * An Analytics Import request.
 * @export
 * @interface AnalyticsImportRequest
 */
export interface AnalyticsImportRequest {
    /**
     * An array of URLs.
     * @type {Set<string>}
     * @memberof AnalyticsImportRequest
     */
    'urls'?: Set<string>;
}
/**
 * The Anchor Text request.
 * @export
 * @interface AnchorText
 */
export interface AnchorText {
    /**
     * 
     * @type {string}
     * @memberof AnchorText
     */
    'actual_prompt_template'?: string;
    /**
     * Whether to enable Anchor Text, by default false.
     * @type {boolean}
     * @memberof AnchorText
     */
    'enabled'?: boolean;
    /**
     * The maximum anchor text length, by default 15 characters.
     * @type {number}
     * @memberof AnchorText
     */
    'max_characters'?: number;
    /**
     * The model to use.
     * @type {string}
     * @memberof AnchorText
     */
    'model'?: string;
    /**
     * The prompt template, we provide a default. Liquid template language is supported.
     * @type {string}
     * @memberof AnchorText
     */
    'prompt_template'?: string;
}
/**
 * Object representing single annotation.
 * @export
 * @interface Annotation
 */
export interface Annotation {
    /**
     * An unique id.
     * @type {string}
     * @memberof Annotation
     */
    'annotationId'?: string;
    /**
     * The starting posistion of annotation in content (zero-indexed & non negative ).
     * @type {number}
     * @memberof Annotation
     */
    'start'?: number;
    /**
     * The ending posistion of annotation in content (zero-indexed & non negative ).
     * @type {number}
     * @memberof Annotation
     */
    'end'?: number;
    /**
     * The annotated text.
     * @type {string}
     * @memberof Annotation
     */
    'text'?: string;
    /**
     * The list of entities which the annotation matches.
     * @type {Array<EntityMatch>}
     * @memberof Annotation
     */
    'entityMatches'?: Array<EntityMatch>;
}
/**
 * 
 * @export
 * @interface AskRequest
 */
export interface AskRequest {
    /**
     * 
     * @type {string}
     * @memberof AskRequest
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof AskRequest
     */
    'model'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AskRequest
     */
    'security'?: boolean;
}
/**
 * 
 * @export
 * @interface AskResponse
 */
export interface AskResponse {
    /**
     * 
     * @type {string}
     * @memberof AskResponse
     */
    'response': string;
}
/**
 * The author request.
 * @export
 * @interface AuthorRequest
 */
export interface AuthorRequest {
    /**
     * The name of the author, e.g. `John Smith`.
     * @type {string}
     * @memberof AuthorRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Authorization
 */
export interface Authorization {
    /**
     * When the access token was issued
     * @type {string}
     * @memberof Authorization
     */
    'access_token_issued_at': string;
    /**
     * Account key
     * @type {string}
     * @memberof Authorization
     */
    'account': string;
    /**
     * When the refresh token was issued
     * @type {string}
     * @memberof Authorization
     */
    'refresh_token_issued_at'?: string;
    /**
     * 
     * @type {AuthorizationStatus}
     * @memberof Authorization
     */
    'status': AuthorizationStatus;
}


/**
 * The connections status
 * @export
 * @enum {string}
 */

export const AuthorizationStatus = {
    Connected: 'connected'
} as const;

export type AuthorizationStatus = typeof AuthorizationStatus[keyof typeof AuthorizationStatus];


/**
 * 
 * @export
 * @interface AutocompleteResult
 */
export interface AutocompleteResult {
    /**
     * 
     * @type {string}
     * @memberof AutocompleteResult
     */
    'id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AutocompleteResult
     */
    'labels'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AutocompleteResult
     */
    'descriptions'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AutocompleteResult
     */
    'types'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AutocompleteResult
     */
    'urls'?: Array<string>;
    /**
     * A list of image URLs.
     * @type {Array<string>}
     * @memberof AutocompleteResult
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AutocompleteResult
     */
    'sameAss'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AutocompleteResult
     */
    'scope'?: AutocompleteResultScopeEnum;
    /**
     * 
     * @type {string}
     * @memberof AutocompleteResult
     */
    'description'?: string;
    /**
     * Schema type slug
     * @type {string}
     * @memberof AutocompleteResult
     */
    'mainType'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutocompleteResult
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutocompleteResult
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutocompleteResult
     */
    'displayTypes'?: string;
}

export const AutocompleteResultScopeEnum = {
    Local: 'local',
    Network: 'network',
    Cloud: 'cloud'
} as const;

export type AutocompleteResultScopeEnum = typeof AutocompleteResultScopeEnum[keyof typeof AutocompleteResultScopeEnum];

/**
 * A request part of a batch.
 * @export
 * @interface BatchRequest
 */
export interface BatchRequest {
    /**
     * The entity URI.
     * @type {string}
     * @memberof BatchRequest
     */
    'uri': string;
    /**
     * 
     * @type {string}
     * @memberof BatchRequest
     */
    'model': string;
    /**
     * Whether the entity should be hidden from Linked Data and GraphQL.
     * @type {boolean}
     * @memberof BatchRequest
     */
    'private'?: boolean;
}
/**
 * The Botify Crawl Import request
 * @export
 * @interface BotifyCrawlImportRequest
 */
export interface BotifyCrawlImportRequest {
    /**
     * 
     * @type {string}
     * @memberof BotifyCrawlImportRequest
     */
    'collection'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BotifyCrawlImportRequest
     */
    'description'?: Array<string>;
    /**
     * 
     * @type {Array<Filter>}
     * @memberof BotifyCrawlImportRequest
     */
    'filters'?: Array<Filter>;
    /**
     * 
     * @type {string}
     * @memberof BotifyCrawlImportRequest
     */
    'headline'?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof BotifyCrawlImportRequest
     */
    'request_embeddings'?: Set<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BotifyCrawlImportRequest
     */
    'text'?: Array<string>;
    /**
     * 
     * @type {Set<string>}
     * @memberof BotifyCrawlImportRequest
     */
    'types'?: Set<string>;
    /**
     * 
     * @type {string}
     * @memberof BotifyCrawlImportRequest
     */
    'url'?: string;
}
/**
 * The request of the `buildAuthorizeUri` endpoint.
 * @export
 * @interface BuildAuthorizeUriRequest
 */
export interface BuildAuthorizeUriRequest {
    /**
     * The Redirect URI to where redirect the Client after successful authentication.
     * @type {string}
     * @memberof BuildAuthorizeUriRequest
     */
    'redirect_uri': string;
}
/**
 * The response of the `buildAuthorizeUri` endpoint.
 * @export
 * @interface BuildAuthorizeUriResponse
 */
export interface BuildAuthorizeUriResponse {
    /**
     * The Authorization URI. The Client should be redirected to this URI.
     * @type {string}
     * @memberof BuildAuthorizeUriResponse
     */
    'authorize_uri': string;
}
/**
 * 
 * @export
 * @interface ClassificationRequest
 */
export interface ClassificationRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassificationRequest
     */
    'classes'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ClassificationRequest
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface ClassificationResponse
 */
export interface ClassificationResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof ClassificationResponse
     */
    'labels'?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ClassificationResponse
     */
    'scores'?: Array<number>;
}
/**
 * A request for a completion.
 * @export
 * @interface CompletionRequest
 */
export interface CompletionRequest {
    /**
     * 
     * @type {number}
     * @memberof CompletionRequest
     */
    'frequency_penalty'?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof CompletionRequest
     */
    'logit_bias'?: { [key: string]: number; };
    /**
     * 
     * @type {number}
     * @memberof CompletionRequest
     */
    'max_tokens'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompletionRequest
     */
    'min_words'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompletionRequest
     */
    'model_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CompletionRequest
     */
    'presence_penalty'?: number;
    /**
     * 
     * @type {string}
     * @memberof CompletionRequest
     */
    'prompt': string;
    /**
     * 
     * @type {string}
     * @memberof CompletionRequest
     */
    'stop'?: string;
    /**
     * 
     * @type {number}
     * @memberof CompletionRequest
     */
    'temperature'?: number;
}
/**
 * The Content Expansion request.
 * @export
 * @interface ContentExpansionRequest
 */
export interface ContentExpansionRequest {
    /**
     * The target URL.
     * @type {string}
     * @memberof ContentExpansionRequest
     */
    'url': string;
    /**
     * A list of entity labels.
     * @type {Set<string>}
     * @memberof ContentExpansionRequest
     */
    'entities': Set<string>;
    /**
     * The OpenAI key.
     * @type {string}
     * @memberof ContentExpansionRequest
     */
    'openai_key': string;
}
/**
 * A Content Expansion response.
 * @export
 * @interface ContentExpansionResponse
 */
export interface ContentExpansionResponse {
    /**
     * The completion.
     * @type {string}
     * @memberof ContentExpansionResponse
     */
    'completion'?: string;
}
/**
 * A Content Generation project.
 * @export
 * @interface ContentGeneration
 */
export interface ContentGeneration {
    /**
     * The Account id bound to this Content Generation.
     * @type {number}
     * @memberof ContentGeneration
     */
    'account_id': number;
    /**
     * The create date-time.
     * @type {string}
     * @memberof ContentGeneration
     */
    'created_at'?: string;
    /**
     * True if the project has been deleted.
     * @type {boolean}
     * @memberof ContentGeneration
     */
    'deleted': boolean;
    /**
     * The delete date-time.
     * @type {string}
     * @memberof ContentGeneration
     */
    'deleted_at'?: string;
    /**
     * The GraphQL query which will be used to import entity data from the Knowledge Graph.
     * @type {string}
     * @memberof ContentGeneration
     */
    'graphql_query': string;
    /**
     * The unique id.
     * @type {number}
     * @memberof ContentGeneration
     */
    'id'?: number;
    /**
     * The maximum number of tokens.
     * @type {number}
     * @memberof ContentGeneration
     */
    'max_tokens'?: number;
    /**
     * Minimum amount of words per completion
     * @type {number}
     * @memberof ContentGeneration
     */
    'min_words'?: number;
    /**
     * The model ID.
     * @type {number}
     * @memberof ContentGeneration
     */
    'model_id'?: number;
    /**
     * The last modified date-time.
     * @type {string}
     * @memberof ContentGeneration
     */
    'modified_at'?: string;
    /**
     * The name.
     * @type {string}
     * @memberof ContentGeneration
     */
    'name': string;
    /**
     * The penalty score.
     * @type {number}
     * @memberof ContentGeneration
     */
    'penalty'?: number;
    /**
     * The prompt template.
     * @type {string}
     * @memberof ContentGeneration
     */
    'prompt_template'?: string;
    /**
     * The stop sequence.
     * @type {string}
     * @memberof ContentGeneration
     */
    'stop'?: string;
    /**
     * The temperature score.
     * @type {number}
     * @memberof ContentGeneration
     */
    'temperature'?: number;
    /**
     * Words to ignore when checking for words not in prompt.
     * @type {Set<string>}
     * @memberof ContentGeneration
     */
    'words_to_ignore'?: Set<string>;
}
/**
 * The Content Generation request.
 * @export
 * @interface ContentGenerationRequest
 */
export interface ContentGenerationRequest {
    /**
     * The account id bound to this content generation.
     * @type {number}
     * @memberof ContentGenerationRequest
     */
    'account_id': number;
    /**
     * The deleted flag.
     * @type {boolean}
     * @memberof ContentGenerationRequest
     */
    'deleted'?: boolean;
    /**
     * The GraphQL query which will be used to import entity data from the Knowledge Graph.
     * @type {string}
     * @memberof ContentGenerationRequest
     */
    'graphql_query': string;
    /**
     * The maximum number of tokens.
     * @type {number}
     * @memberof ContentGenerationRequest
     */
    'max_tokens'?: number;
    /**
     * Minimum amount of words per completion.
     * @type {number}
     * @memberof ContentGenerationRequest
     */
    'min_words'?: number;
    /**
     * The model ID.
     * @type {number}
     * @memberof ContentGenerationRequest
     */
    'model_id'?: number;
    /**
     * The model name.
     * @type {string}
     * @memberof ContentGenerationRequest
     */
    'name': string;
    /**
     * The penalty score.
     * @type {number}
     * @memberof ContentGenerationRequest
     */
    'penalty'?: number;
    /**
     * The prompt template.
     * @type {string}
     * @memberof ContentGenerationRequest
     */
    'prompt_template'?: string;
    /**
     * The stop sequence.
     * @type {string}
     * @memberof ContentGenerationRequest
     */
    'stop'?: string;
    /**
     * The temperature score.
     * @type {number}
     * @memberof ContentGenerationRequest
     */
    'temperature'?: number;
    /**
     * Words to ignore when checking for words not in prompt.
     * @type {Set<string>}
     * @memberof ContentGenerationRequest
     */
    'words_to_ignore'?: Set<string>;
}
/**
 * Statistics about a Content Generation Project.
 * @export
 * @interface ContentGenerationStats
 */
export interface ContentGenerationStats {
    /**
     * The number of accepted records.
     * @type {number}
     * @memberof ContentGenerationStats
     */
    'accepted'?: number;
    /**
     * The number of records with errors.
     * @type {number}
     * @memberof ContentGenerationStats
     */
    'errors'?: number;
    /**
     * The total number of records.
     * @type {number}
     * @memberof ContentGenerationStats
     */
    'total'?: number;
    /**
     * The number of valid records.
     * @type {number}
     * @memberof ContentGenerationStats
     */
    'valid'?: number;
    /**
     * The number of records with warnings.
     * @type {number}
     * @memberof ContentGenerationStats
     */
    'warnings'?: number;
}
/**
 * 
 * @export
 * @interface CreateEmbeddingsInput
 */
export interface CreateEmbeddingsInput {
    /**
     * 
     * @type {string}
     * @memberof CreateEmbeddingsInput
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface CreateSEOScore200Response
 */
export interface CreateSEOScore200Response {
    /**
     * Traffic light system indicating the match. M for match, T for trustworthiness, O for overall score.
     * @type {string}
     * @memberof CreateSEOScore200Response
     */
    'analyze'?: string;
}
/**
 * 
 * @export
 * @interface CreateSEOScoreRequest
 */
export interface CreateSEOScoreRequest {
    /**
     * URL of the content to be analyzed. Mutually exclusive with text.
     * @type {string}
     * @memberof CreateSEOScoreRequest
     */
    'url'?: string;
    /**
     * A paragraph of text content to be analyzed. Mutually exclusive with URL.
     * @type {string}
     * @memberof CreateSEOScoreRequest
     */
    'text'?: string;
    /**
     * Keyword or query related to the content.
     * @type {string}
     * @memberof CreateSEOScoreRequest
     */
    'keyword'?: string;
    /**
     * Narrative description of the intent behind the query.
     * @type {string}
     * @memberof CreateSEOScoreRequest
     */
    'description_narrative'?: string;
}
/**
 * Plugin Data used for diagnostics
 * @export
 * @interface DiagnosticPlugin
 */
export interface DiagnosticPlugin {
    /**
     * The account id.
     * @type {number}
     * @memberof DiagnosticPlugin
     */
    'account_id'?: number;
    /**
     * Whether the plugin is active.
     * @type {boolean}
     * @memberof DiagnosticPlugin
     */
    'active'?: boolean;
    /**
     * The create date-time
     * @type {string}
     * @memberof DiagnosticPlugin
     */
    'created_at'?: string;
    /**
     * The record id.
     * @type {number}
     * @memberof DiagnosticPlugin
     */
    'id'?: number;
    /**
     * The plugin name.
     * @type {string}
     * @memberof DiagnosticPlugin
     */
    'name'?: string;
    /**
     * The plugin version.
     * @type {string}
     * @memberof DiagnosticPlugin
     */
    'version'?: string;
}
/**
 * Diagnostic Plugin Data Request
 * @export
 * @interface DiagnosticPluginRequest
 */
export interface DiagnosticPluginRequest {
    /**
     * Whether the plugin is active.
     * @type {boolean}
     * @memberof DiagnosticPluginRequest
     */
    'active'?: boolean;
    /**
     * The plugin name.
     * @type {string}
     * @memberof DiagnosticPluginRequest
     */
    'name'?: string;
    /**
     * The plugin version.
     * @type {string}
     * @memberof DiagnosticPluginRequest
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface DomainValidationRequest
 */
export interface DomainValidationRequest {
    /**
     * The dataset domain, e.g. data.example.org
     * @type {string}
     * @memberof DomainValidationRequest
     */
    'dataset_domain': string;
    /**
     * The dataset name, e.g. my-dataset-name
     * @type {string}
     * @memberof DomainValidationRequest
     */
    'dataset_name': string;
}
/**
 * 
 * @export
 * @interface DuplicateAuthorizationRequest
 */
export interface DuplicateAuthorizationRequest {
    /**
     * 
     * @type {string}
     * @memberof DuplicateAuthorizationRequest
     */
    'from_account_key': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DuplicateAuthorizationRequest
     */
    'to_account_keys': Array<string>;
}
/**
 * A request to generate the embeddings.
 * @export
 * @interface EmbeddingRequest
 */
export interface EmbeddingRequest {
    /**
     * The model used to generate the embeddings.
     * @type {string}
     * @memberof EmbeddingRequest
     */
    'model'?: string;
    /**
     * The list of properties to use to generate the embeddings.
     * @type {Set<string>}
     * @memberof EmbeddingRequest
     */
    'properties'?: Set<string>;
}
/**
 * Entity
 * @export
 * @interface Entity
 */
export interface Entity {
    /**
     * The entity URI.
     * @type {string}
     * @memberof Entity
     */
    'entityId'?: string;
    /**
     * Confidence score representing the entity match level.
     * @type {number}
     * @memberof Entity
     */
    'confidence'?: number;
    /**
     * The main schema type for the current entity.
     * @type {string}
     * @memberof Entity
     */
    'mainType'?: string;
    /**
     * The list of schema types which the entity can be classified to.
     * @type {Array<string>}
     * @memberof Entity
     */
    'types'?: Array<string>;
    /**
     * The title of the entity.
     * @type {string}
     * @memberof Entity
     */
    'label'?: string;
    /**
     * The description about the entity.
     * @type {string}
     * @memberof Entity
     */
    'description'?: string;
    /**
     * The list of entity image URIs.
     * @type {Array<string>}
     * @memberof Entity
     */
    'images'?: Array<string>;
    /**
     * The list of entity sameas URIs.
     * @type {Array<string>}
     * @memberof Entity
     */
    'sameAs'?: Array<string>;
    /**
     * 
     * @type {Properties}
     * @memberof Entity
     */
    'properties'?: Properties;
    /**
     * 
     * @type {Array<string>}
     * @memberof Entity
     */
    'synonyms'?: Array<string>;
}
/**
 * The list of entities matching the query.
 * @export
 * @interface Entity1
 */
export interface Entity1 {
    /**
     * The referenced entity URI
     * @type {string}
     * @memberof Entity1
     */
    'reference'?: string;
    /**
     * 
     * @type {Properties1}
     * @memberof Entity1
     */
    'properties'?: Properties1;
}
/**
 * 
 * @export
 * @interface EntityGapRequest
 */
export interface EntityGapRequest {
    /**
     * The URL to analyze.
     * @type {string}
     * @memberof EntityGapRequest
     */
    'url': string;
    /**
     * The search query to analyze.
     * @type {string}
     * @memberof EntityGapRequest
     */
    'query': string;
    /**
     * The model
     * @type {string}
     * @memberof EntityGapRequest
     */
    'model'?: string;
    /**
     * Number of entities to highlight.
     * @type {number}
     * @memberof EntityGapRequest
     */
    'number_of_entities'?: number;
    /**
     * The location name for the query, e.g. United Kingdom.
     * @type {string}
     * @memberof EntityGapRequest
     */
    'query_location_name'?: string;
    /**
     * The search engine domain for the query, if not set will be chosen according to `query_location_name`
     * @type {string}
     * @memberof EntityGapRequest
     */
    'query_search_engine'?: string;
}
/**
 * Entity Match
 * @export
 * @interface EntityMatch
 */
export interface EntityMatch {
    /**
     * Confidence score for the current entity.
     * @type {number}
     * @memberof EntityMatch
     */
    'confidence'?: number;
    /**
     * The entity URI.
     * @type {string}
     * @memberof EntityMatch
     */
    'entityId'?: string;
}
/**
 * 
 * @export
 * @interface EntityPatchRequest
 */
export interface EntityPatchRequest {
    /**
     * The patch operation, example `add`.
     * @type {string}
     * @memberof EntityPatchRequest
     */
    'op'?: EntityPatchRequestOpEnum;
    /**
     * The property to apply the operation, JSONPath formatted (leading slash) on, e.g. `/https://schema.org/image (note the leading slash).
     * @type {string}
     * @memberof EntityPatchRequest
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof EntityPatchRequest
     */
    'value'?: string;
}

export const EntityPatchRequestOpEnum = {
    Add: 'add',
    Remove: 'remove',
    Replace: 'replace',
    Move: 'move',
    Copy: 'copy',
    Test: 'test',
    Add2: 'add',
    Remove2: 'remove',
    Replace2: 'replace'
} as const;

export type EntityPatchRequestOpEnum = typeof EntityPatchRequestOpEnum[keyof typeof EntityPatchRequestOpEnum];

/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'source'?: string;
    /**
     * 
     * @type {object}
     * @memberof Event
     */
    'args'?: object;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'recorded_at'?: string;
    /**
     * 
     * @type {number}
     * @memberof Event
     */
    'account_id'?: number;
}
/**
 * The request of the `exchangeAuthCode` endpoint.
 * @export
 * @interface ExchangeAuthCodeRequest
 */
export interface ExchangeAuthCodeRequest {
    /**
     * The Authorization Code. The API will use the Authorization Code to exchange it with an Access Token.
     * @type {string}
     * @memberof ExchangeAuthCodeRequest
     */
    'code': string;
    /**
     * The Google Search Console Resource Id as it shows in the Google Search Console, e.g. sc-domain:example.org.
     * @type {string}
     * @memberof ExchangeAuthCodeRequest
     */
    'google_search_console_resource_id': string;
}
/**
 * The response of the `buildAuthorizeUri` endpoint.
 * @export
 * @interface ExchangeAuthCodeResponse
 */
export interface ExchangeAuthCodeResponse {
    /**
     * The access token
     * @type {string}
     * @memberof ExchangeAuthCodeResponse
     */
    'access_token'?: string;
    /**
     * The number of seconds for the access token to expire
     * @type {number}
     * @memberof ExchangeAuthCodeResponse
     */
    'expires_in'?: number;
    /**
     * The refresh token
     * @type {string}
     * @memberof ExchangeAuthCodeResponse
     */
    'refresh_token'?: string;
    /**
     * The scope
     * @type {string}
     * @memberof ExchangeAuthCodeResponse
     */
    'scope'?: string;
    /**
     * The token type, usually Bearer
     * @type {string}
     * @memberof ExchangeAuthCodeResponse
     */
    'token_type'?: string;
}
/**
 * 
 * @export
 * @interface Field
 */
export interface Field {
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'name'?: string;
}
/**
 * A query request filter.
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * Operational filters such as AND or OR.
     * @type {Array<Filter>}
     * @memberof Filter
     */
    'filters'?: Array<Filter>;
    /**
     * The filter key. Key is required for the filters [EQ, NE, GT, LT, GTE, LTE, IN, NIN]
     * @type {string}
     * @memberof Filter
     */
    'key'?: string;
    /**
     * A query request filter operator.
     * @type {string}
     * @memberof Filter
     */
    'operator': FilterOperatorEnum;
    /**
     * 
     * @type {FilterValue}
     * @memberof Filter
     */
    'value'?: FilterValue;
    /**
     * The filter value as a date, if provided will be preferred over the `value` field.
     * @type {string}
     * @memberof Filter
     */
    'value_date'?: string;
}

export const FilterOperatorEnum = {
    Eq: 'EQ',
    Gt: 'GT',
    Lt: 'LT',
    Ne: 'NE',
    Gte: 'GTE',
    Lte: 'LTE',
    In: 'IN',
    Nin: 'NIN',
    And: 'AND',
    Or: 'OR'
} as const;

export type FilterOperatorEnum = typeof FilterOperatorEnum[keyof typeof FilterOperatorEnum];

/**
 * @type FilterValue
 * The filter value.
 * @export
 */
export type FilterValue = Array<number> | Array<string> | number | string;

/**
 * 
 * @export
 * @interface GenerateSitemap200Response
 */
export interface GenerateSitemap200Response {
    /**
     * The generated sitemap in XML format.
     * @type {string}
     * @memberof GenerateSitemap200Response
     */
    'sitemap'?: string;
}
/**
 * 
 * @export
 * @interface GenerateSitemapRequest
 */
export interface GenerateSitemapRequest {
    /**
     * 
     * @type {string}
     * @memberof GenerateSitemapRequest
     */
    'query'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenerateSitemapRequest
     */
    'operationName'?: string;
}
/**
 * 
 * @export
 * @interface GraphqlRequest
 */
export interface GraphqlRequest {
    /**
     * 
     * @type {string}
     * @memberof GraphqlRequest
     */
    'query'?: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * The html fragment or html page to analyze.
 * @export
 * @interface Html
 */
export interface Html {
    /**
     * The html fragment to analyze.
     * @type {string}
     * @memberof Html
     */
    'fragment'?: string;
    /**
     * The html page to analyze, either fragment or page should be present
     * @type {string}
     * @memberof Html
     */
    'page'?: string;
}
/**
 * Image
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * The title of the image.
     * @type {string}
     * @memberof Image
     */
    'label'?: string;
    /**
     * The image URI.
     * @type {string}
     * @memberof Image
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface IncludeExclude
 */
export interface IncludeExclude {
    /**
     * Account unique identifier
     * @type {number}
     * @memberof IncludeExclude
     */
    'account_id': number;
    /**
     * A flag which determines whether the URL is `INCLUDE` or `EXCLUDE`.
     * @type {string}
     * @memberof IncludeExclude
     */
    'flag': IncludeExcludeFlagEnum;
    /**
     * Unique identifier
     * @type {number}
     * @memberof IncludeExclude
     */
    'id'?: number;
    /**
     * The URL
     * @type {string}
     * @memberof IncludeExclude
     */
    'url': string;
}

export const IncludeExcludeFlagEnum = {
    Include: 'INCLUDE',
    Exclude: 'EXCLUDE'
} as const;

export type IncludeExcludeFlagEnum = typeof IncludeExcludeFlagEnum[keyof typeof IncludeExcludeFlagEnum];

/**
 * 
 * @export
 * @interface IncludeExcludeRequest
 */
export interface IncludeExcludeRequest {
    /**
     * A flag which determines whether the URL is `INCLUDE` or `EXCLUDE`.
     * @type {string}
     * @memberof IncludeExcludeRequest
     */
    'flag': IncludeExcludeRequestFlagEnum;
    /**
     * The URL
     * @type {string}
     * @memberof IncludeExcludeRequest
     */
    'url': string;
}

export const IncludeExcludeRequestFlagEnum = {
    Include: 'INCLUDE',
    Exclude: 'EXCLUDE'
} as const;

export type IncludeExcludeRequestFlagEnum = typeof IncludeExcludeRequestFlagEnum[keyof typeof IncludeExcludeRequestFlagEnum];

/**
 * 
 * @export
 * @interface InspectResponse
 */
export interface InspectResponse {
    [key: string]: object | any;

    /**
     * 
     * @type {boolean}
     * @memberof InspectResponse
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface InternalLink
 */
export interface InternalLink {
    /**
     * InternalLink destinations configuration.
     * @type {Array<InternalLinkDestination>}
     * @memberof InternalLink
     */
    'destinations': Array<InternalLinkDestination>;
    /**
     * 
     * @type {InternalLinkSource}
     * @memberof InternalLink
     */
    'source': InternalLinkSource;
}
/**
 * InternalLink destinations configuration.
 * @export
 * @interface InternalLinkDestination
 */
export interface InternalLinkDestination {
    /**
     * Identifier of the Entity.
     * @type {string}
     * @memberof InternalLinkDestination
     */
    'name': string;
    /**
     * The position of an item in a series or sequence of items.
     * @type {number}
     * @memberof InternalLinkDestination
     */
    'position': number;
    /**
     * URL of the Entity.
     * @type {string}
     * @memberof InternalLinkDestination
     */
    'url': string;
}
/**
 * An Internal Links request.
 * @export
 * @interface InternalLinkRequest
 */
export interface InternalLinkRequest {
    /**
     * 
     * @type {AnchorText}
     * @memberof InternalLinkRequest
     */
    'anchor_text'?: AnchorText;
    /**
     * An array of items.
     * @type {Array<Item>}
     * @memberof InternalLinkRequest
     */
    'items': Array<Item>;
    /**
     * The output template, not required, we provide a default JSON-LD template
     * @type {string}
     * @memberof InternalLinkRequest
     */
    'template'?: string;
}
/**
 * InternalLink source configuration.
 * @export
 * @interface InternalLinkSource
 */
export interface InternalLinkSource {
    /**
     * Entity identifier.
     * @type {string}
     * @memberof InternalLinkSource
     */
    'id'?: string;
    /**
     * Entity name.
     * @type {string}
     * @memberof InternalLinkSource
     */
    'name'?: string;
    /**
     * Entity url.
     * @type {string}
     * @memberof InternalLinkSource
     */
    'url': string;
}
/**
 * An Internal Link request item.
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * The entity id, reused in the output template.
     * @type {string}
     * @memberof Item
     */
    'id'?: string;
    /**
     * 
     * @type {VectorSearchQueryRequest}
     * @memberof Item
     */
    'query': VectorSearchQueryRequest;
    /**
     * The webpage name, reused in the output template.
     * @type {string}
     * @memberof Item
     */
    'source_name'?: string;
}
/**
 * 
 * @export
 * @interface KgEmbeddingRequest
 */
export interface KgEmbeddingRequest {
    /**
     * 
     * @type {string}
     * @memberof KgEmbeddingRequest
     */
    'graphql_query'?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof KgEmbeddingRequest
     */
    'properties'?: Set<string>;
}
/**
 * The rule level.
 * @export
 * @enum {string}
 */

export const LevelEnum = {
    Recommended: 'RECOMMENDED',
    Required: 'REQUIRED'
} as const;

export type LevelEnum = typeof LevelEnum[keyof typeof LevelEnum];


/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface LongtailResponse
 */
export interface LongtailResponse {
    /**
     * The page summary.
     * @type {string}
     * @memberof LongtailResponse
     */
    'summary'?: string;
    /**
     * The list of entities matching the query.
     * @type {Array<Entity1>}
     * @memberof LongtailResponse
     */
    'entities'?: Array<Entity1>;
}
/**
 * A Merchant project.
 * @export
 * @interface Merchant
 */
export interface Merchant {
    /**
     * The Google merchant access token
     * @type {string}
     * @memberof Merchant
     */
    'access_token': string;
    /**
     * The account id
     * @type {number}
     * @memberof Merchant
     */
    'account_id'?: number;
    /**
     * Whether the Merchant data will be synchronized automatically
     * @type {boolean}
     * @memberof Merchant
     */
    'automatic_synchronization'?: boolean;
    /**
     * The create date-time
     * @type {string}
     * @memberof Merchant
     */
    'created_at'?: string;
    /**
     * Custom seller entity - if applicable.
     * @type {string}
     * @memberof Merchant
     */
    'custom_seller'?: string;
    /**
     * The custom domain (for example data.example.org)
     * @type {string}
     * @memberof Merchant
     * @deprecated
     */
    'dataset_domain'?: string;
    /**
     * The dataset path (for example /data)
     * @type {string}
     * @memberof Merchant
     * @deprecated
     */
    'dataset_name'?: string;
    /**
     * Default Products filter action to apply during sync process.
     * @type {string}
     * @memberof Merchant
     */
    'default_products_filter_action': MerchantDefaultProductsFilterActionEnum;
    /**
     * True if the merchant has been deleted
     * @type {boolean}
     * @memberof Merchant
     */
    'deleted': boolean;
    /**
     * The delete date-time
     * @type {string}
     * @memberof Merchant
     */
    'deleted_at'?: string;
    /**
     * The Google Merchant id
     * @type {number}
     * @memberof Merchant
     */
    'google_merchant_id': number;
    /**
     * The unique id
     * @type {number}
     * @memberof Merchant
     */
    'id'?: number;
    /**
     * Whether to ignore the `brand` property during validation
     * @type {boolean}
     * @memberof Merchant
     */
    'ignore_brand'?: boolean;
    /**
     * Whether to ignore the `image` property during validation
     * @type {boolean}
     * @memberof Merchant
     */
    'ignore_image'?: boolean;
    /**
     * The last modified date-time
     * @type {string}
     * @memberof Merchant
     */
    'modified_at'?: string;
    /**
     * The publisher name (shows in schema publisher)
     * @type {string}
     * @memberof Merchant
     */
    'publisher_name': string;
    /**
     * The Google merchant refresh token
     * @type {string}
     * @memberof Merchant
     */
    'refresh_token': string;
    /**
     * The website URL
     * @type {string}
     * @memberof Merchant
     */
    'url'?: string;
    /**
     * Which strategy to use to write the url schema.
     * @type {string}
     * @memberof Merchant
     */
    'url_strategy'?: MerchantUrlStrategyEnum;
    /**
     * How to write the merchant data to the graph, if unsure, do not set anything (by default `wordpressMerchantWriter`).
     * @type {string}
     * @memberof Merchant
     */
    'writer_service'?: string;
}

export const MerchantDefaultProductsFilterActionEnum = {
    Process: 'PROCESS',
    Ignore: 'IGNORE'
} as const;

export type MerchantDefaultProductsFilterActionEnum = typeof MerchantDefaultProductsFilterActionEnum[keyof typeof MerchantDefaultProductsFilterActionEnum];
export const MerchantUrlStrategyEnum = {
    CanonicalLinkAndLink: 'canonicalLinkAndLink',
    CanonicalLinkOtherwiseLink: 'canonicalLinkOtherwiseLink'
} as const;

export type MerchantUrlStrategyEnum = typeof MerchantUrlStrategyEnum[keyof typeof MerchantUrlStrategyEnum];

/**
 * A Merchant Entry with the Google Merchant Id and the Website URL
 * @export
 * @interface MerchantEntry
 */
export interface MerchantEntry {
    /**
     * The Google Merchant id
     * @type {number}
     * @memberof MerchantEntry
     */
    'google_merchant_id': number;
    /**
     * The Google Merchant Website URL
     * @type {string}
     * @memberof MerchantEntry
     */
    'website_url': string;
}
/**
 * The Merchant request
 * @export
 * @interface MerchantRequest
 */
export interface MerchantRequest {
    /**
     * Google Merchant access token
     * @type {string}
     * @memberof MerchantRequest
     */
    'access_token'?: string;
    /**
     * The Knowledge Graph to use for the Merchant. Please note that the Knowledge Graph will be reset. When not provided, this method will use the first available Knowledge Graph.
     * @type {number}
     * @memberof MerchantRequest
     */
    'account_id'?: number;
    /**
     * The custom domain (for example data.example.org)
     * @type {string}
     * @memberof MerchantRequest
     */
    'dataset_domain'?: string;
    /**
     * The dataset path (for example \"data\")
     * @type {string}
     * @memberof MerchantRequest
     */
    'dataset_name'?: string;
    /**
     * True if the merchant has been deleted
     * @type {boolean}
     * @memberof MerchantRequest
     */
    'deleted'?: boolean;
    /**
     * The Google Merchant id
     * @type {number}
     * @memberof MerchantRequest
     */
    'google_merchant_id': number;
    /**
     * Whether to ignore the `brand` property during validation
     * @type {boolean}
     * @memberof MerchantRequest
     */
    'ignore_brand'?: boolean;
    /**
     * Whether to ignore the `image` property during validation
     * @type {boolean}
     * @memberof MerchantRequest
     */
    'ignore_image'?: boolean;
    /**
     * The publisher name (shows in schema publisher)
     * @type {string}
     * @memberof MerchantRequest
     */
    'publisher_name': string;
    /**
     * Google Merchant refresh token
     * @type {string}
     * @memberof MerchantRequest
     */
    'refresh_token': string;
    /**
     * The website URL
     * @type {string}
     * @memberof MerchantRequest
     */
    'url': string;
    /**
     * Which strategy to use to write the url schema.
     * @type {string}
     * @memberof MerchantRequest
     */
    'url_strategy'?: MerchantRequestUrlStrategyEnum;
    /**
     * How to write the merchant data to the graph, if unsure, do not set anything (by default `wordpressMerchantWriter`).
     * @type {string}
     * @memberof MerchantRequest
     */
    'writer_service'?: string;
}

export const MerchantRequestUrlStrategyEnum = {
    CanonicalLinkAndLink: 'canonicalLinkAndLink',
    CanonicalLinkOtherwiseLink: 'canonicalLinkOtherwiseLink'
} as const;

export type MerchantRequestUrlStrategyEnum = typeof MerchantRequestUrlStrategyEnum[keyof typeof MerchantRequestUrlStrategyEnum];

/**
 * A Merchant products data synchronization.
 * @export
 * @interface MerchantSync
 */
export interface MerchantSync {
    /**
     * The create date-time.
     * @type {string}
     * @memberof MerchantSync
     */
    'created_at'?: string;
    /**
     * Error that caused the synchronization to fail.
     * @type {string}
     * @memberof MerchantSync
     */
    'error_reason'?: string;
    /**
     * Whether the sync encountered errors.
     * @type {boolean}
     * @memberof MerchantSync
     */
    'has_errors'?: boolean;
    /**
     * The unique id.
     * @type {number}
     * @memberof MerchantSync
     */
    'id'?: number;
    /**
     * The parent Merchant id.
     * @type {number}
     * @memberof MerchantSync
     */
    'merchant_id': number;
    /**
     * The last modified date-time.
     * @type {string}
     * @memberof MerchantSync
     */
    'modified_at'?: string;
    /**
     * The overall amount of products available on KG after syncing.
     * @type {number}
     * @memberof MerchantSync
     */
    'overall_products_in_kg'?: number;
    /**
     * The number of created products
     * @type {number}
     * @memberof MerchantSync
     */
    'products_created'?: number;
    /**
     * The number of deleted products
     * @type {number}
     * @memberof MerchantSync
     */
    'products_deleted'?: number;
    /**
     * The number of errored products
     * @type {number}
     * @memberof MerchantSync
     */
    'products_errored'?: number;
    /**
     * The number of skipped products
     * @type {number}
     * @memberof MerchantSync
     */
    'products_skipped'?: number;
    /**
     * The total number of processed products, including the skipped and errored.
     * @type {number}
     * @memberof MerchantSync
     */
    'products_total'?: number;
    /**
     * The number of products that haven\'t changed and therefore haven\'t been synced again
     * @type {number}
     * @memberof MerchantSync
     */
    'products_unchanged'?: number;
    /**
     * The number of update products
     * @type {number}
     * @memberof MerchantSync
     */
    'products_updated'?: number;
    /**
     * The started date-time.
     * @type {string}
     * @memberof MerchantSync
     */
    'started_at'?: string;
    /**
     * The stopped date-time.
     * @type {string}
     * @memberof MerchantSync
     */
    'stopped_at'?: string;
    /**
     * The number of products synced by this process available in KG.
     * @type {number}
     * @memberof MerchantSync
     */
    'synced_products_in_kg'?: number;
    /**
     * 
     * @type {number}
     * @memberof MerchantSync
     */
    'synced_products_in_kg_before_cleanup'?: number;
}
/**
 * An array of objects.
 * @export
 * @interface MerchantView
 */
export interface MerchantView {
    /**
     * The Google merchant access token
     * @type {string}
     * @memberof MerchantView
     */
    'access_token': string;
    /**
     * The account id
     * @type {number}
     * @memberof MerchantView
     */
    'account_id'?: number;
    /**
     * Whether the Merchant data will be synchronized automatically
     * @type {boolean}
     * @memberof MerchantView
     */
    'automatic_synchronization'?: boolean;
    /**
     * The create date-time
     * @type {string}
     * @memberof MerchantView
     */
    'created_at'?: string;
    /**
     * Custom seller entity - if applicable.
     * @type {string}
     * @memberof MerchantView
     */
    'custom_seller'?: string;
    /**
     * The custom domain (for example data.example.org)
     * @type {string}
     * @memberof MerchantView
     * @deprecated
     */
    'dataset_domain'?: string;
    /**
     * The dataset path (for example /data)
     * @type {string}
     * @memberof MerchantView
     * @deprecated
     */
    'dataset_name'?: string;
    /**
     * Default Products filter action to apply during sync process.
     * @type {string}
     * @memberof MerchantView
     */
    'default_products_filter_action': MerchantViewDefaultProductsFilterActionEnum;
    /**
     * True if the merchant has been deleted
     * @type {boolean}
     * @memberof MerchantView
     */
    'deleted': boolean;
    /**
     * The delete date-time
     * @type {string}
     * @memberof MerchantView
     */
    'deleted_at'?: string;
    /**
     * The Google Merchant id
     * @type {number}
     * @memberof MerchantView
     */
    'google_merchant_id': number;
    /**
     * The unique id
     * @type {number}
     * @memberof MerchantView
     */
    'id'?: number;
    /**
     * Whether to ignore the `brand` property during validation
     * @type {boolean}
     * @memberof MerchantView
     */
    'ignore_brand'?: boolean;
    /**
     * Whether to ignore the `image` property during validation
     * @type {boolean}
     * @memberof MerchantView
     */
    'ignore_image'?: boolean;
    /**
     * The last modified date-time
     * @type {string}
     * @memberof MerchantView
     */
    'modified_at'?: string;
    /**
     * The publisher name (shows in schema publisher)
     * @type {string}
     * @memberof MerchantView
     */
    'publisher_name': string;
    /**
     * The Google merchant refresh token
     * @type {string}
     * @memberof MerchantView
     */
    'refresh_token': string;
    /**
     * 
     * @type {string}
     * @memberof MerchantView
     */
    'sid'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MerchantView
     */
    'sync_has_errors'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MerchantView
     */
    'sync_id'?: number;
    /**
     * 
     * @type {number}
     * @memberof MerchantView
     */
    'sync_products_created'?: number;
    /**
     * 
     * @type {number}
     * @memberof MerchantView
     */
    'sync_products_deleted'?: number;
    /**
     * 
     * @type {number}
     * @memberof MerchantView
     */
    'sync_products_errored'?: number;
    /**
     * 
     * @type {number}
     * @memberof MerchantView
     */
    'sync_products_skipped'?: number;
    /**
     * 
     * @type {number}
     * @memberof MerchantView
     */
    'sync_products_total'?: number;
    /**
     * 
     * @type {number}
     * @memberof MerchantView
     */
    'sync_products_unchanged'?: number;
    /**
     * 
     * @type {number}
     * @memberof MerchantView
     */
    'sync_products_updated'?: number;
    /**
     * The started date-time.
     * @type {string}
     * @memberof MerchantView
     */
    'sync_started_at'?: string;
    /**
     * The stopped date-time.
     * @type {string}
     * @memberof MerchantView
     */
    'sync_stopped_at'?: string;
    /**
     * The website URL
     * @type {string}
     * @memberof MerchantView
     */
    'url'?: string;
    /**
     * Which strategy to use to write the url schema.
     * @type {string}
     * @memberof MerchantView
     */
    'url_strategy'?: MerchantViewUrlStrategyEnum;
    /**
     * How to write the merchant data to the graph, if unsure, do not set anything (by default `wordpressMerchantWriter`).
     * @type {string}
     * @memberof MerchantView
     */
    'writer_service'?: string;
}

export const MerchantViewDefaultProductsFilterActionEnum = {
    Process: 'PROCESS',
    Ignore: 'IGNORE'
} as const;

export type MerchantViewDefaultProductsFilterActionEnum = typeof MerchantViewDefaultProductsFilterActionEnum[keyof typeof MerchantViewDefaultProductsFilterActionEnum];
export const MerchantViewUrlStrategyEnum = {
    CanonicalLinkAndLink: 'canonicalLinkAndLink',
    CanonicalLinkOtherwiseLink: 'canonicalLinkOtherwiseLink'
} as const;

export type MerchantViewUrlStrategyEnum = typeof MerchantViewUrlStrategyEnum[keyof typeof MerchantViewUrlStrategyEnum];

/**
 * A language model.
 * @export
 * @interface Model
 */
export interface Model {
    /**
     * The unique id.
     * @type {number}
     * @memberof Model
     */
    'id'?: number;
    /**
     * The language model name.
     * @type {string}
     * @memberof Model
     */
    'name': string;
    /**
     * The system prompt for the model - chat models only.
     * @type {string}
     * @memberof Model
     */
    'system_prompt'?: string;
    /**
     * The upper token margin for completions.
     * @type {number}
     * @memberof Model
     */
    'token_margin'?: number;
}
/**
 * Network Account Information
 * @export
 * @interface NetworkAccountInfo
 */
export interface NetworkAccountInfo {
    /**
     * The Account Id
     * @type {number}
     * @memberof NetworkAccountInfo
     */
    'accountId'?: number;
    /**
     * The Dataset Id
     * @type {string}
     * @memberof NetworkAccountInfo
     */
    'datasetId'?: string;
    /**
     * The Dataset URI
     * @type {string}
     * @memberof NetworkAccountInfo
     */
    'datasetUri': string;
    /**
     * The website URL
     * @type {string}
     * @memberof NetworkAccountInfo
     */
    'url'?: string;
}
/**
 * A node request.
 * @export
 * @interface NodeRequest
 */
export interface NodeRequest {
    /**
     * A list of embeddings.
     * @type {Array<number>}
     * @memberof NodeRequest
     */
    'embeddings'?: Array<number>;
    /**
     * The entity id in the form on an IRI, e.g. https://data.example.org/dataset/entity.
     * @type {string}
     * @memberof NodeRequest
     */
    'entity_id': string;
    /**
     * A map of metadata properties.
     * @type {{ [key: string]: NodeRequestMetadataValue; }}
     * @memberof NodeRequest
     */
    'metadata'?: { [key: string]: NodeRequestMetadataValue; };
    /**
     * The node id generally expressed in the form of a UUID.
     * @type {string}
     * @memberof NodeRequest
     */
    'node_id': string;
    /**
     * The original text.
     * @type {string}
     * @memberof NodeRequest
     */
    'text'?: string;
}
/**
 * @type NodeRequestMetadataValue
 * A map of metadata properties.
 * @export
 */
export type NodeRequestMetadataValue = boolean | number | string;

/**
 * A OAuth2 Authorized Client
 * @export
 * @interface OAuth2AuthorizedClient
 */
export interface OAuth2AuthorizedClient {
    /**
     * 
     * @type {string}
     * @memberof OAuth2AuthorizedClient
     */
    'access_token_expires_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2AuthorizedClient
     */
    'access_token_issued_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2AuthorizedClient
     */
    'access_token_scopes'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2AuthorizedClient
     */
    'access_token_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2AuthorizedClient
     */
    'access_token_value'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2AuthorizedClient
     */
    'client_registration_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof OAuth2AuthorizedClient
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof OAuth2AuthorizedClient
     */
    'principal_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2AuthorizedClient
     */
    'refresh_token_issued_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof OAuth2AuthorizedClient
     */
    'refresh_token_value'?: string;
}
/**
 * The OAuth2 Authorized Client request
 * @export
 * @interface OAuth2AuthorizedClientRequest
 */
export interface OAuth2AuthorizedClientRequest {
    /**
     * When the Access Token expires
     * @type {string}
     * @memberof OAuth2AuthorizedClientRequest
     */
    'access_token_expires_at'?: string;
    /**
     * When the Access Token was issued
     * @type {string}
     * @memberof OAuth2AuthorizedClientRequest
     */
    'access_token_issued_at'?: string;
    /**
     * The Access Token scopes
     * @type {string}
     * @memberof OAuth2AuthorizedClientRequest
     */
    'access_token_scopes'?: string;
    /**
     * The Access Token Type
     * @type {string}
     * @memberof OAuth2AuthorizedClientRequest
     */
    'access_token_type'?: string;
    /**
     * The Access Token Value
     * @type {string}
     * @memberof OAuth2AuthorizedClientRequest
     */
    'access_token_value'?: string;
    /**
     * The Client Registration Id
     * @type {string}
     * @memberof OAuth2AuthorizedClientRequest
     */
    'client_registration_id'?: string;
    /**
     * The Principal Name
     * @type {string}
     * @memberof OAuth2AuthorizedClientRequest
     */
    'principal_name'?: string;
    /**
     * When the Access Token was issued
     * @type {string}
     * @memberof OAuth2AuthorizedClientRequest
     */
    'refresh_token_issued_at'?: string;
    /**
     * The Refresh Token Value
     * @type {string}
     * @memberof OAuth2AuthorizedClientRequest
     */
    'refresh_token_value'?: string;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PageActiveAccount
 */
export interface PageActiveAccount {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PageActiveAccount
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<ActiveAccount>}
     * @memberof PageActiveAccount
     */
    'items': Array<ActiveAccount>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PageActiveAccount
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageActiveAccount
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageActiveAccount
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PageActiveAccount
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PageAddOnConfiguration
 */
export interface PageAddOnConfiguration {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PageAddOnConfiguration
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<AddOnConfiguration>}
     * @memberof PageAddOnConfiguration
     */
    'items': Array<AddOnConfiguration>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PageAddOnConfiguration
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageAddOnConfiguration
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageAddOnConfiguration
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PageAddOnConfiguration
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PageContentGeneration
 */
export interface PageContentGeneration {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PageContentGeneration
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<ContentGeneration>}
     * @memberof PageContentGeneration
     */
    'items': Array<ContentGeneration>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PageContentGeneration
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageContentGeneration
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageContentGeneration
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PageContentGeneration
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PageField
 */
export interface PageField {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PageField
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<Field>}
     * @memberof PageField
     */
    'items': Array<Field>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PageField
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageField
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageField
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PageField
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PageMerchantEntry
 */
export interface PageMerchantEntry {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PageMerchantEntry
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<MerchantEntry>}
     * @memberof PageMerchantEntry
     */
    'items': Array<MerchantEntry>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PageMerchantEntry
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageMerchantEntry
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageMerchantEntry
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PageMerchantEntry
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PageMerchantSync
 */
export interface PageMerchantSync {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PageMerchantSync
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<MerchantSync>}
     * @memberof PageMerchantSync
     */
    'items': Array<MerchantSync>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PageMerchantSync
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageMerchantSync
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageMerchantSync
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PageMerchantSync
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PageMerchantView
 */
export interface PageMerchantView {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PageMerchantView
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<MerchantView>}
     * @memberof PageMerchantView
     */
    'items': Array<MerchantView>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PageMerchantView
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageMerchantView
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageMerchantView
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PageMerchantView
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PageModel
 */
export interface PageModel {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PageModel
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<Model>}
     * @memberof PageModel
     */
    'items': Array<Model>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PageModel
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageModel
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageModel
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PageModel
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PageOAuth2AuthorizedClient
 */
export interface PageOAuth2AuthorizedClient {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PageOAuth2AuthorizedClient
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<OAuth2AuthorizedClient>}
     * @memberof PageOAuth2AuthorizedClient
     */
    'items': Array<OAuth2AuthorizedClient>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PageOAuth2AuthorizedClient
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageOAuth2AuthorizedClient
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageOAuth2AuthorizedClient
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PageOAuth2AuthorizedClient
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PagePlatformLimit
 */
export interface PagePlatformLimit {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PagePlatformLimit
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<PlatformLimit>}
     * @memberof PagePlatformLimit
     */
    'items': Array<PlatformLimit>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PagePlatformLimit
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PagePlatformLimit
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PagePlatformLimit
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PagePlatformLimit
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PagePreset
 */
export interface PagePreset {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PagePreset
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<Preset>}
     * @memberof PagePreset
     */
    'items': Array<Preset>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PagePreset
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PagePreset
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PagePreset
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PagePreset
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PageRecord
 */
export interface PageRecord {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PageRecord
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<Record>}
     * @memberof PageRecord
     */
    'items': Array<Record>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PageRecord
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageRecord
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageRecord
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PageRecord
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PageRule
 */
export interface PageRule {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PageRule
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<Rule>}
     * @memberof PageRule
     */
    'items': Array<Rule>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PageRule
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageRule
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageRule
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PageRule
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PageVectorSearchQueryResponseItem
 */
export interface PageVectorSearchQueryResponseItem {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PageVectorSearchQueryResponseItem
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<VectorSearchQueryResponseItem>}
     * @memberof PageVectorSearchQueryResponseItem
     */
    'items': Array<VectorSearchQueryResponseItem>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PageVectorSearchQueryResponseItem
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageVectorSearchQueryResponseItem
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageVectorSearchQueryResponseItem
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PageVectorSearchQueryResponseItem
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PageVectorSearchQuestionResponseItem
 */
export interface PageVectorSearchQuestionResponseItem {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PageVectorSearchQuestionResponseItem
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<VectorSearchQuestionResponseItem>}
     * @memberof PageVectorSearchQuestionResponseItem
     */
    'items': Array<VectorSearchQuestionResponseItem>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PageVectorSearchQuestionResponseItem
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageVectorSearchQuestionResponseItem
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageVectorSearchQuestionResponseItem
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PageVectorSearchQuestionResponseItem
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PageWebsite
 */
export interface PageWebsite {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PageWebsite
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<Website>}
     * @memberof PageWebsite
     */
    'items': Array<Website>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PageWebsite
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageWebsite
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageWebsite
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PageWebsite
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PageWebsiteSearch
 */
export interface PageWebsiteSearch {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PageWebsiteSearch
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<WebsiteSearch>}
     * @memberof PageWebsiteSearch
     */
    'items': Array<WebsiteSearch>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PageWebsiteSearch
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageWebsiteSearch
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageWebsiteSearch
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PageWebsiteSearch
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PageWithLimits
 */
export interface PageWithLimits {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PageWithLimits
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<WithLimits>}
     * @memberof PageWithLimits
     */
    'items': Array<WithLimits>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PageWithLimits
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageWithLimits
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageWithLimits
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PageWithLimits
     */
    'self': string | null;
}
/**
 * A page object with links to move to other pages and the list of objects.
 * @export
 * @interface PageWord
 */
export interface PageWord {
    /**
     * The link to the first page.
     * @type {string}
     * @memberof PageWord
     */
    'first': string | null;
    /**
     * An array of objects.
     * @type {Array<Word>}
     * @memberof PageWord
     */
    'items': Array<Word>;
    /**
     * The link to the last page.
     * @type {string}
     * @memberof PageWord
     */
    'last': string | null;
    /**
     * The link to the next page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageWord
     */
    'next': string | null;
    /**
     * The link to the previous page or `null` if there\'s no page.
     * @type {string}
     * @memberof PageWord
     */
    'prev': string | null;
    /**
     * The link to the current page.
     * @type {string}
     * @memberof PageWord
     */
    'self': string | null;
}
/**
 * 
 * @export
 * @interface PlatformLimit
 */
export interface PlatformLimit {
    /**
     * 
     * @type {string}
     * @memberof PlatformLimit
     */
    'applies_to': string;
    /**
     * 
     * @type {string}
     * @memberof PlatformLimit
     */
    'based_on': PlatformLimitBasedOnEnum;
    /**
     * 
     * @type {string}
     * @memberof PlatformLimit
     */
    'based_on_value': string;
    /**
     * The create date-time.
     * @type {string}
     * @memberof PlatformLimit
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformLimit
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PlatformLimit
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlatformLimit
     */
    'limits': number;
    /**
     * The last modified date-time.
     * @type {string}
     * @memberof PlatformLimit
     */
    'modified_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlatformLimit
     */
    'scope': PlatformLimitScopeEnum;
}

export const PlatformLimitBasedOnEnum = {
    Sku: 'SKU'
} as const;

export type PlatformLimitBasedOnEnum = typeof PlatformLimitBasedOnEnum[keyof typeof PlatformLimitBasedOnEnum];
export const PlatformLimitScopeEnum = {
    Account: 'ACCOUNT',
    Subscription: 'SUBSCRIPTION'
} as const;

export type PlatformLimitScopeEnum = typeof PlatformLimitScopeEnum[keyof typeof PlatformLimitScopeEnum];

/**
 * Platform Limit request
 * @export
 * @interface PlatformLimitRequest
 */
export interface PlatformLimitRequest {
    /**
     * 
     * @type {string}
     * @memberof PlatformLimitRequest
     */
    'applies_to': string;
    /**
     * 
     * @type {string}
     * @memberof PlatformLimitRequest
     */
    'based_on': PlatformLimitRequestBasedOnEnum;
    /**
     * 
     * @type {string}
     * @memberof PlatformLimitRequest
     */
    'based_on_value': string;
    /**
     * 
     * @type {string}
     * @memberof PlatformLimitRequest
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof PlatformLimitRequest
     */
    'limits': number;
    /**
     * 
     * @type {string}
     * @memberof PlatformLimitRequest
     */
    'scope': PlatformLimitRequestScopeEnum;
}

export const PlatformLimitRequestBasedOnEnum = {
    Sku: 'SKU'
} as const;

export type PlatformLimitRequestBasedOnEnum = typeof PlatformLimitRequestBasedOnEnum[keyof typeof PlatformLimitRequestBasedOnEnum];
export const PlatformLimitRequestScopeEnum = {
    Account: 'ACCOUNT',
    Subscription: 'SUBSCRIPTION'
} as const;

export type PlatformLimitRequestScopeEnum = typeof PlatformLimitRequestScopeEnum[keyof typeof PlatformLimitRequestScopeEnum];

/**
 * An array of objects.
 * @export
 * @interface Preset
 */
export interface Preset {
    /**
     * The predefined graphql query.
     * @type {string}
     * @memberof Preset
     */
    'body': string;
    /**
     * 
     * @type {number}
     * @memberof Preset
     */
    'id'?: number;
    /**
     * The label of the preset.
     * @type {string}
     * @memberof Preset
     */
    'label': string;
}
/**
 * 
 * @export
 * @interface ProblemDetail
 */
export interface ProblemDetail {
    /**
     * 
     * @type {string}
     * @memberof ProblemDetail
     */
    'detail'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetail
     */
    'instance'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ProblemDetail
     */
    'properties'?: { [key: string]: object; };
    /**
     * 
     * @type {number}
     * @memberof ProblemDetail
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetail
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProblemDetail
     */
    'type'?: string;
}
/**
 * The project type, if applicable.
 * @export
 * @enum {string}
 */

export const ProjectType = {
    SmartContent: 'SMART_CONTENT',
    ContentGeneration: 'CONTENT_GENERATION'
} as const;

export type ProjectType = typeof ProjectType[keyof typeof ProjectType];


/**
 * The entity properties.
 * @export
 * @interface Properties
 */
export interface Properties {
    /**
     * The latitude.
     * @type {number}
     * @memberof Properties
     */
    'latitude'?: number;
    /**
     * The longitude.
     * @type {number}
     * @memberof Properties
     */
    'longitude'?: number;
}
/**
 * 
 * @export
 * @interface Properties1
 */
export interface Properties1 {
    /**
     * The name of the entity.
     * @type {string}
     * @memberof Properties1
     */
    'name'?: string;
    /**
     * A list of sameAs entity URIs.
     * @type {Array<string>}
     * @memberof Properties1
     */
    'sameAs'?: Array<string>;
}
/**
 * Generated Q&A content.
 * @export
 * @interface QuestionAndAnswer
 */
export interface QuestionAndAnswer {
    /**
     * The generated answer.
     * @type {string}
     * @memberof QuestionAndAnswer
     */
    'answer'?: string;
    /**
     * The create date-time.
     * @type {string}
     * @memberof QuestionAndAnswer
     */
    'created_at'?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof QuestionAndAnswer
     */
    'entity_gaps'?: Set<string>;
    /**
     * The set of errors found for the answer.
     * @type {Array<ValidationResult>}
     * @memberof QuestionAndAnswer
     */
    'errors'?: Array<ValidationResult>;
    /**
     * The unique id.
     * @type {number}
     * @memberof QuestionAndAnswer
     */
    'id'?: number;
    /**
     * The webpage IRI tied to this Q&A.
     * @type {string}
     * @memberof QuestionAndAnswer
     */
    'iri': string;
    /**
     * The deleted flag.
     * @type {boolean}
     * @memberof QuestionAndAnswer
     */
    'is_deleted'?: boolean;
    /**
     * The published flag.
     * @type {boolean}
     * @memberof QuestionAndAnswer
     */
    'is_published'?: boolean;
    /**
     * The last modified date-time.
     * @type {string}
     * @memberof QuestionAndAnswer
     */
    'modified_at'?: string;
    /**
     * The generated question.
     * @type {string}
     * @memberof QuestionAndAnswer
     */
    'question'?: string;
    /**
     * 
     * @type {number}
     * @memberof QuestionAndAnswer
     */
    'smart_content_id'?: number;
    /**
     * The webpage URL tied to this Q&A.
     * @type {string}
     * @memberof QuestionAndAnswer
     */
    'url': string;
    /**
     * The set of warnings found for the answer.
     * @type {Array<ValidationResult>}
     * @memberof QuestionAndAnswer
     */
    'warnings'?: Array<ValidationResult>;
}
/**
 * 
 * @export
 * @interface QuestionAndAnswerRequest
 */
export interface QuestionAndAnswerRequest {
    /**
     * 
     * @type {number}
     * @memberof QuestionAndAnswerRequest
     */
    'smartContentId'?: number;
    /**
     * 
     * @type {WebpageProperties}
     * @memberof QuestionAndAnswerRequest
     */
    'webpageProperties'?: WebpageProperties;
}
/**
 * 
 * @export
 * @interface RankEntities
 */
export interface RankEntities {
    /**
     * 
     * @type {number}
     * @memberof RankEntities
     */
    'rank'?: number;
    /**
     * 
     * @type {Array<Entity1>}
     * @memberof RankEntities
     */
    'entities'?: Array<Entity1>;
}
/**
 * 
 * @export
 * @interface Record
 */
export interface Record {
    /**
     * 
     * @type {string}
     * @memberof Record
     */
    'completion'?: string;
    /**
     * The parent content generation id.
     * @type {number}
     * @memberof Record
     */
    'content_generation_id': number;
    /**
     * The data from knowledge graph after applying the graphql query.
     * @type {object}
     * @memberof Record
     */
    'data'?: object;
    /**
     * The set of errors found for record.
     * @type {Array<ValidationResult>}
     * @memberof Record
     */
    'errors'?: Array<ValidationResult>;
    /**
     * This indicates whether the user upvoted the completion.
     * @type {boolean}
     * @memberof Record
     */
    'has_upvote': boolean;
    /**
     * 
     * @type {number}
     * @memberof Record
     */
    'id'?: number;
    /**
     * This indicates whether the completion is accepted by the user.
     * @type {boolean}
     * @memberof Record
     */
    'is_accepted': boolean;
    /**
     * The last modified date-time.
     * @type {string}
     * @memberof Record
     */
    'modified_at'?: string;
    /**
     * Words in completion that are not in the prompt.
     * @type {Set<string>}
     * @memberof Record
     */
    'not_in_prompt_words'?: Set<string>;
    /**
     * The prompt.
     * @type {string}
     * @memberof Record
     */
    'prompt': string;
    /**
     * Words in completion which are repeated.
     * @type {{ [key: string]: WordRepetitionData; }}
     * @memberof Record
     */
    'repeated_words'?: { [key: string]: WordRepetitionData; };
    /**
     * The status of the record, whether it\'s accepted, with errors, with warnings or valid.
     * @type {string}
     * @memberof Record
     */
    'status'?: RecordStatusEnum;
    /**
     * The last validation date-time.
     * @type {string}
     * @memberof Record
     */
    'validated_at'?: string;
    /**
     * The set of errors found for record.
     * @type {Array<ValidationResult>}
     * @memberof Record
     */
    'warnings'?: Array<ValidationResult>;
}

export const RecordStatusEnum = {
    Accepted: 'accepted',
    Warnings: 'warnings',
    Errors: 'errors',
    Valid: 'valid'
} as const;

export type RecordStatusEnum = typeof RecordStatusEnum[keyof typeof RecordStatusEnum];

/**
 * A request to render a template using the provided data structure.
 * @export
 * @interface RenderRequest
 */
export interface RenderRequest {
    /**
     * The data from knowledge graph after applying the graphql query.
     * @type {object}
     * @memberof RenderRequest
     */
    'data': object;
    /**
     * The liquid template.
     * @type {string}
     * @memberof RenderRequest
     */
    'template': string;
}
/**
 * The request
 * @export
 * @interface Request
 */
export interface Request {
    /**
     * 
     * @type {Html}
     * @memberof Request
     */
    'html'?: Html;
    /**
     * The url of the page to analyze.
     * @type {string}
     * @memberof Request
     */
    'url'?: string;
    /**
     * The client which the analysis should use to extract the content, by default chrome is used.
     * @type {string}
     * @memberof Request
     */
    'urlClient'?: RequestUrlClientEnum;
    /**
     * The content language, 2 letters code, e.g. \'en\'.
     * @type {string}
     * @memberof Request
     */
    'language': string;
    /**
     * A textual fragment.
     * @type {string}
     * @memberof Request
     */
    'text'?: string;
    /**
     * An array of item IDs to exclude from the analysis results.
     * @type {Array<string>}
     * @memberof Request
     */
    'exclude'?: Array<string>;
    /**
     * The scope of the analysis, one of \'local\', \'network\', \'cloud-only\', \'network-only\' or \'all\'.
     * @type {string}
     * @memberof Request
     */
    'scope': string;
    /**
     * Filter out results that don\'t have at least the specified number of occurrences. By default 1.
     * @type {number}
     * @memberof Request
     */
    'matches'?: number;
    /**
     * When returning an interpolated HTML results, matches should have the \'wl-link\' class. By default \'no\'.
     * @type {string}
     * @memberof Request
     */
    'links'?: string;
}

export const RequestUrlClientEnum = {
    Chrome: 'CHROME',
    PlainHttp: 'PLAIN_HTTP',
    ChromePlainHttp: 'CHROME, PLAIN_HTTP'
} as const;

export type RequestUrlClientEnum = typeof RequestUrlClientEnum[keyof typeof RequestUrlClientEnum];

/**
 * The Event request
 * @export
 * @interface Request1
 */
export interface Request1 {
    /**
     * 
     * @type {string}
     * @memberof Request1
     */
    'source'?: string;
    /**
     * 
     * @type {object}
     * @memberof Request1
     */
    'args'?: object;
    /**
     * 
     * @type {string}
     * @memberof Request1
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface Request2
 */
export interface Request2 {
    /**
     * 
     * @type {string}
     * @memberof Request2
     */
    'redeem_code'?: string;
}
/**
 * 
 * @export
 * @interface Request3
 */
export interface Request3 {
    /**
     * 
     * @type {string}
     * @memberof Request3
     */
    'completion'?: string;
    /**
     * This indicates whether the user upvoted the completion.
     * @type {boolean}
     * @memberof Request3
     */
    'has_upvote': boolean;
    /**
     * This indicates whether the completion is accepted by the user.
     * @type {boolean}
     * @memberof Request3
     */
    'is_accepted': boolean;
    /**
     * Validation time of the record - null to revalidate.
     * @type {string}
     * @memberof Request3
     */
    'validated_at'?: string;
}
/**
 * Response
 * @export
 * @interface Response
 */
export interface Response {
    /**
     * A map of entity URI to the respective entity.
     * @type {{ [key: string]: Entity; }}
     * @memberof Response
     */
    'entities'?: { [key: string]: Entity; };
    /**
     * A map of annotation id to the respective annotation.
     * @type {{ [key: string]: Annotation; }}
     * @memberof Response
     */
    'annotations'?: { [key: string]: Annotation; };
    /**
     * A list of images.
     * @type {Array<Image>}
     * @memberof Response
     */
    'images'?: Array<Image>;
    /**
     * A list of languages.
     * @type {Array<string>}
     * @memberof Response
     */
    'languages'?: Array<string>;
    /**
     * A list of topics.
     * @type {Array<Topic>}
     * @memberof Response
     */
    'topics'?: Array<Topic>;
    /**
     * The text supplied for analysis.
     * @type {string}
     * @memberof Response
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface Response1
 */
export interface Response1 {
    /**
     * 
     * @type {Array<Event>}
     * @memberof Response1
     */
    'items'?: Array<Event>;
    /**
     * 
     * @type {string}
     * @memberof Response1
     */
    'self'?: string;
    /**
     * 
     * @type {string}
     * @memberof Response1
     */
    'next'?: string;
    /**
     * 
     * @type {string}
     * @memberof Response1
     */
    'prev'?: string;
    /**
     * 
     * @type {string}
     * @memberof Response1
     */
    'last'?: string;
    /**
     * 
     * @type {string}
     * @memberof Response1
     */
    'first'?: string;
}
/**
 * 
 * @export
 * @interface Response2
 */
export interface Response2 {
    /**
     * 
     * @type {string}
     * @memberof Response2
     */
    'key'?: string;
}
/**
 * 
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * The create date-time.
     * @type {string}
     * @memberof Rule
     */
    'created_at'?: string;
    /**
     * Description for the rule
     * @type {string}
     * @memberof Rule
     */
    'description'?: string;
    /**
     * The list of fixes to apply when the rule validation fails.
     * @type {Array<ValidationFix>}
     * @memberof Rule
     */
    'fixes'?: Array<ValidationFix>;
    /**
     * 
     * @type {number}
     * @memberof Rule
     */
    'id'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Rule
     */
    'is_enabled'?: boolean;
    /**
     * 
     * @type {LevelEnum}
     * @memberof Rule
     */
    'level': LevelEnum;
    /**
     * The last modified date-time.
     * @type {string}
     * @memberof Rule
     */
    'modified_at'?: string;
    /**
     * The rule name.
     * @type {string}
     * @memberof Rule
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof Rule
     */
    'project_id'?: number;
    /**
     * 
     * @type {ProjectType}
     * @memberof Rule
     */
    'project_type'?: ProjectType;
    /**
     * 
     * @type {Scope}
     * @memberof Rule
     */
    'scope': Scope;
    /**
     * The rule type, one of `field`, `word` or `code`. By default `field`.
     * @type {string}
     * @memberof Rule
     */
    'type': string;
    /**
     * 
     * @type {WhatOperandLhs}
     * @memberof Rule
     */
    'what_operand_lhs': WhatOperandLhs;
    /**
     * The right hand side operand for what condition.
     * @type {string}
     * @memberof Rule
     */
    'what_operand_rhs': string;
    /**
     * 
     * @type {WhatOperator}
     * @memberof Rule
     */
    'what_operator': WhatOperator;
    /**
     * The left hand side  operand for when condition.
     * @type {string}
     * @memberof Rule
     */
    'when_operand_lhs': string;
    /**
     * The right hand side operand for when condition.
     * @type {string}
     * @memberof Rule
     */
    'when_operand_rhs': string;
    /**
     * 
     * @type {WhenOperator}
     * @memberof Rule
     */
    'when_operator': WhenOperator;
}


/**
 * 
 * @export
 * @interface RuleRequest
 */
export interface RuleRequest {
    /**
     * Description for the rule
     * @type {string}
     * @memberof RuleRequest
     */
    'description'?: string;
    /**
     * The list of fixes to apply when the rule validation fails.
     * @type {Array<ValidationFix>}
     * @memberof RuleRequest
     */
    'fixes'?: Array<ValidationFix>;
    /**
     * 
     * @type {boolean}
     * @memberof RuleRequest
     */
    'is_enabled'?: boolean;
    /**
     * 
     * @type {LevelEnum}
     * @memberof RuleRequest
     */
    'level': LevelEnum;
    /**
     * The rule name.
     * @type {string}
     * @memberof RuleRequest
     */
    'name': string;
    /**
     * The project id, if applicable.
     * @type {number}
     * @memberof RuleRequest
     */
    'project_id'?: number;
    /**
     * 
     * @type {ProjectType}
     * @memberof RuleRequest
     */
    'project_type'?: ProjectType;
    /**
     * 
     * @type {Scope}
     * @memberof RuleRequest
     */
    'scope': Scope;
    /**
     * The rule type, one of `field`, `word` or `code`. By default `field`.
     * @type {string}
     * @memberof RuleRequest
     */
    'type': string;
    /**
     * 
     * @type {WhatOperandLhs}
     * @memberof RuleRequest
     */
    'what_operand_lhs': WhatOperandLhs;
    /**
     * The right hand side operand for what condition.
     * @type {string}
     * @memberof RuleRequest
     */
    'what_operand_rhs': string;
    /**
     * 
     * @type {WhatOperator}
     * @memberof RuleRequest
     */
    'what_operator': WhatOperator;
    /**
     * The left hand side  operand for when condition.
     * @type {string}
     * @memberof RuleRequest
     */
    'when_operand_lhs': string;
    /**
     * The right hand side operand for when condition.
     * @type {string}
     * @memberof RuleRequest
     */
    'when_operand_rhs': string;
    /**
     * 
     * @type {WhenOperator}
     * @memberof RuleRequest
     */
    'when_operator': WhenOperator;
}


/**
 * The rule scope.
 * @export
 * @enum {string}
 */

export const Scope = {
    User: 'USER',
    Project: 'PROJECT'
} as const;

export type Scope = typeof Scope[keyof typeof Scope];


/**
 * The Sitemap Import request
 * @export
 * @interface SitemapImportRequest
 */
export interface SitemapImportRequest {
    /**
     * 
     * @type {EmbeddingRequest}
     * @memberof SitemapImportRequest
     */
    'embedding'?: EmbeddingRequest;
    /**
     * The entity id generator, by default uses the web page path.
     * @type {string}
     * @memberof SitemapImportRequest
     */
    'id_generator'?: SitemapImportRequestIdGeneratorEnum;
    /**
     * The type of the generated entities, by default `http://schema.org/WebPage`.
     * @type {Set<string>}
     * @memberof SitemapImportRequest
     */
    'output_types'?: Set<string>;
    /**
     * Whether to overwrite existing entities.
     * @type {boolean}
     * @memberof SitemapImportRequest
     */
    'overwrite'?: boolean;
    /**
     * The sitemap URL
     * @type {string}
     * @memberof SitemapImportRequest
     */
    'sitemap_url'?: string;
    /**
     * A regex filter to apply to discovered URLs, it only applies to URLs in sitemaps.
     * @type {string}
     * @memberof SitemapImportRequest
     */
    'sitemap_url_regex'?: string;
    /**
     * The URLs
     * @type {Set<string>}
     * @memberof SitemapImportRequest
     */
    'urls'?: Set<string>;
}

export const SitemapImportRequestIdGeneratorEnum = {
    Default: 'default',
    HeadlineWithUrlHash: 'headline-with-url-hash'
} as const;

export type SitemapImportRequestIdGeneratorEnum = typeof SitemapImportRequestIdGeneratorEnum[keyof typeof SitemapImportRequestIdGeneratorEnum];

/**
 * A Smart Content project.
 * @export
 * @interface SmartContent
 */
export interface SmartContent {
    /**
     * The account id.
     * @type {number}
     * @memberof SmartContent
     */
    'account_id': number;
    /**
     * The create date-time.
     * @type {string}
     * @memberof SmartContent
     */
    'created_at'?: string;
    /**
     * The unique id.
     * @type {number}
     * @memberof SmartContent
     */
    'id'?: number;
    /**
     * The model id.
     * @type {number}
     * @memberof SmartContent
     */
    'model_id'?: number;
}
/**
 * 
 * @export
 * @interface SmartContentRequest
 */
export interface SmartContentRequest {
    /**
     * The account id.
     * @type {number}
     * @memberof SmartContentRequest
     */
    'account_id': number;
    /**
     * The model id.
     * @type {number}
     * @memberof SmartContentRequest
     */
    'model_id'?: number;
    /**
     * 
     * @type {Array<RuleRequest>}
     * @memberof SmartContentRequest
     */
    'rules'?: Array<RuleRequest>;
    /**
     * 
     * @type {Array<WebpageProperties>}
     * @memberof SmartContentRequest
     */
    'webpage_properties'?: Array<WebpageProperties>;
}
/**
 * 
 * @export
 * @interface SubmitFactCheck200Response
 */
export interface SubmitFactCheck200Response {
    /**
     * 
     * @type {string}
     * @memberof SubmitFactCheck200Response
     */
    'response'?: string;
}
/**
 * 
 * @export
 * @interface SubmitFactCheckRequest
 */
export interface SubmitFactCheckRequest {
    /**
     * 
     * @type {string}
     * @memberof SubmitFactCheckRequest
     */
    'query'?: string;
}
/**
 * Topic
 * @export
 * @interface Topic
 */
export interface Topic {
    /**
     * The topic title.
     * @type {string}
     * @memberof Topic
     */
    'label'?: string;
    /**
     * The topic description.
     * @type {string}
     * @memberof Topic
     */
    'description'?: string;
    /**
     * The topic URI.
     * @type {string}
     * @memberof Topic
     */
    'uri'?: string;
    /**
     * The topic confidence score.
     * @type {number}
     * @memberof Topic
     */
    'confidence'?: number;
    /**
     * A list of image URIs.
     * @type {Array<string>}
     * @memberof Topic
     */
    'images'?: Array<string>;
    /**
     * A list of sameas URIs.
     * @type {Array<string>}
     * @memberof Topic
     */
    'sameAs'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateAccountRequest
 */
export interface UpdateAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountRequest
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountRequest
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountRequest
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface UpdateQuestionAndAnswerRequest
 */
export interface UpdateQuestionAndAnswerRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateQuestionAndAnswerRequest
     */
    'answer'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateQuestionAndAnswerRequest
     */
    'question'?: string;
}
/**
 * A request to update the properties of a record.
 * @export
 * @interface UpdateRecordRequest
 */
export interface UpdateRecordRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateRecordRequest
     */
    'completion'?: string;
    /**
     * Whether the user upvoted the completion.
     * @type {boolean}
     * @memberof UpdateRecordRequest
     */
    'has_upvote': boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateRecordRequest
     */
    'id': number;
    /**
     * Whether the completion is accepted by the user.
     * @type {boolean}
     * @memberof UpdateRecordRequest
     */
    'is_accepted': boolean;
}
/**
 * A request to update the properties of multiple records.
 * @export
 * @interface UpdateRecordsRequest
 */
export interface UpdateRecordsRequest {
    /**
     * The validation time of the record.
     * @type {string}
     * @memberof UpdateRecordsRequest
     */
    'validated_at'?: string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * The list of fixes to apply when the rule validation fails.
 * @export
 * @interface ValidationFix
 */
export interface ValidationFix {
    /**
     * 
     * @type {ValidationTypeEnum}
     * @memberof ValidationFix
     */
    'type'?: ValidationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ValidationFix
     */
    'what'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationFix
     */
    'with'?: string;
}


/**
 * The set of warnings found for the answer.
 * @export
 * @interface ValidationResult
 */
export interface ValidationResult {
    /**
     * 
     * @type {LevelEnum}
     * @memberof ValidationResult
     */
    'levelEnum'?: LevelEnum;
    /**
     * 
     * @type {string}
     * @memberof ValidationResult
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationResult
     */
    'result'?: ValidationResultResultEnum;
}

export const ValidationResultResultEnum = {
    Pass: 'PASS',
    Fail: 'FAIL',
    Skip: 'SKIP',
    Fixed: 'FIXED'
} as const;

export type ValidationResultResultEnum = typeof ValidationResultResultEnum[keyof typeof ValidationResultResultEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const ValidationTypeEnum = {
    FindAndReplace: 'FIND_AND_REPLACE',
    OpenAi: 'OPEN_AI',
    Append: 'APPEND'
} as const;

export type ValidationTypeEnum = typeof ValidationTypeEnum[keyof typeof ValidationTypeEnum];


/**
 * A query request.
 * @export
 * @interface VectorSearchQueryRequest
 */
export interface VectorSearchQueryRequest {
    /**
     * List of extra fields to be retrieved.
     * @type {Set<string>}
     * @memberof VectorSearchQueryRequest
     */
    'fields'?: Set<string>;
    /**
     * A list of prefilters.
     * @type {Array<Filter>}
     * @memberof VectorSearchQueryRequest
     */
    'filters'?: Array<Filter>;
    /**
     * The list of embeddings, not required if `query_string` is provided.
     * @type {Array<number>}
     * @memberof VectorSearchQueryRequest
     */
    'query_embedding'?: Array<number>;
    /**
     * The query string, not required if the `query_embeddings` are provided. Please note that the `query_string` is ignored if the `query_embeddings` are provided.
     * @type {string}
     * @memberof VectorSearchQueryRequest
     */
    'query_string'?: string;
    /**
     * Perform a Vector Search based on similarities with an entity with the specified URI.
     * @type {string}
     * @memberof VectorSearchQueryRequest
     */
    'query_uri'?: string;
    /**
     * Perform a Vector Search based on similarities with an entity with the specified URL (schema:url).
     * @type {string}
     * @memberof VectorSearchQueryRequest
     */
    'query_url'?: string;
    /**
     * The similarity top K.
     * @type {number}
     * @memberof VectorSearchQueryRequest
     */
    'similarity_top_k'?: number;
}
/**
 * An array of objects.
 * @export
 * @interface VectorSearchQueryResponseItem
 */
export interface VectorSearchQueryResponseItem {
    /**
     * Map of extra retrieved fields. The values of the requested fields are always returned in an array.If no value is found an empty array is returned.
     * @type {{ [key: string]: Array<VectorSearchQueryResponseItemFieldsValueInner>; }}
     * @memberof VectorSearchQueryResponseItem
     */
    'fields'?: { [key: string]: Array<VectorSearchQueryResponseItemFieldsValueInner>; };
    /**
     * 
     * @type {string}
     * @memberof VectorSearchQueryResponseItem
     */
    'id'?: string;
    /**
     * The IRI of the entity that this node belongs to.
     * @type {string}
     * @memberof VectorSearchQueryResponseItem
     * @deprecated
     */
    'iri': string;
    /**
     * A nodes extra metadata.
     * @type {{ [key: string]: VectorSearchQueryResponseItemMetadataValue; }}
     * @memberof VectorSearchQueryResponseItem
     */
    'metadata'?: { [key: string]: VectorSearchQueryResponseItemMetadataValue; };
    /**
     * A nodes id.
     * @type {string}
     * @memberof VectorSearchQueryResponseItem
     */
    'node_id'?: string;
    /**
     * The similarity score between the node and the query embeddings.
     * @type {number}
     * @memberof VectorSearchQueryResponseItem
     */
    'score': number;
    /**
     * The text of a node from which the embeddings were generated.
     * @type {string}
     * @memberof VectorSearchQueryResponseItem
     */
    'text'?: string;
}
/**
 * @type VectorSearchQueryResponseItemFieldsValueInner
 * Map of extra retrieved fields. The values of the requested fields are always returned in an array.If no value is found an empty array is returned.
 * @export
 */
export type VectorSearchQueryResponseItemFieldsValueInner = boolean | number | string;

/**
 * @type VectorSearchQueryResponseItemMetadataValue
 * A nodes extra metadata.
 * @export
 */
export type VectorSearchQueryResponseItemMetadataValue = boolean | number | string;

/**
 * One or more questions.
 * @export
 * @interface VectorSearchQuestionRequest
 */
export interface VectorSearchQuestionRequest {
    /**
     * The desired language of the answer.
     * @type {string}
     * @memberof VectorSearchQuestionRequest
     */
    'language'?: string;
    /**
     * The list of questions.
     * @type {Array<string>}
     * @memberof VectorSearchQuestionRequest
     */
    'questions': Array<string>;
}
/**
 * An array of objects.
 * @export
 * @interface VectorSearchQuestionResponseItem
 */
export interface VectorSearchQuestionResponseItem {
    /**
     * 
     * @type {string}
     * @memberof VectorSearchQuestionResponseItem
     */
    'answer'?: string;
    /**
     * 
     * @type {string}
     * @memberof VectorSearchQuestionResponseItem
     */
    'question'?: string;
}
/**
 * 
 * @export
 * @interface WebAsync
 */
export interface WebAsync {
    /**
     * 
     * @type {string}
     * @memberof WebAsync
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebAsync
     */
    'created'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebAsync
     */
    'completed'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebAsync
     */
    'delivered'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebAsync
     */
    'method'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebAsync
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebAsync
     */
    'callback'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebAsync
     */
    'remoteAddress'?: string;
}
/**
 * 
 * @export
 * @interface WebPage
 */
export interface WebPage {
    /**
     * 
     * @type {string}
     * @memberof WebPage
     */
    'abstract'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebPage
     */
    'date_published'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebPage
     */
    'headline'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebPage
     */
    'image'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebPage
     */
    'markdown'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebPage
     */
    'text'?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof WebPage
     */
    'types'?: Set<string>;
    /**
     * 
     * @type {string}
     * @memberof WebPage
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface WebpageProperties
 */
export interface WebpageProperties {
    /**
     * 
     * @type {Set<string>}
     * @memberof WebpageProperties
     */
    'entities': Set<string>;
    /**
     * 
     * @type {string}
     * @memberof WebpageProperties
     */
    'iri': string;
    /**
     * 
     * @type {string}
     * @memberof WebpageProperties
     */
    'query'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebpageProperties
     */
    'url': string;
}
/**
 * A Website
 * @export
 * @interface Website
 */
export interface Website {
    /**
     * The Website URL, it may also start with thew `sc-domain:` prefix.
     * @type {string}
     * @memberof Website
     */
    'url': string;
}
/**
 * Search Data
 * @export
 * @interface WebsiteSearch
 */
export interface WebsiteSearch {
    /**
     * Number of clicks.
     * @type {number}
     * @memberof WebsiteSearch
     */
    'clicks': number;
    /**
     * CTR.
     * @type {number}
     * @memberof WebsiteSearch
     */
    'ctr': number;
    /**
     * The id: it\'s now a unique id, but a row index.
     * @type {number}
     * @memberof WebsiteSearch
     */
    'id': number;
    /**
     * Number of impressions.
     * @type {number}
     * @memberof WebsiteSearch
     */
    'impressions': number;
    /**
     * The keys for the current data, matching the provided `dimensions` in the query.
     * @type {Array<string>}
     * @memberof WebsiteSearch
     */
    'keys': Array<string>;
    /**
     * Position.
     * @type {number}
     * @memberof WebsiteSearch
     */
    'position': number;
    /**
     * A score to spot traffic opportunities, from 0.0 to 1.0 (the higher the better). The score is based on the traffic data.
     * @type {number}
     * @memberof WebsiteSearch
     */
    'score': number;
}
/**
 * The left hand side operand for what condition.
 * @export
 * @enum {string}
 */

export const WhatOperandLhs = {
    Everywhere: 'EVERYWHERE',
    FirstSentence: 'FIRST_SENTENCE',
    LastSentence: 'LAST_SENTENCE'
} as const;

export type WhatOperandLhs = typeof WhatOperandLhs[keyof typeof WhatOperandLhs];


/**
 * The operator for what condition.
 * @export
 * @enum {string}
 */

export const WhatOperator = {
    Contains: 'CONTAINS',
    DoesntContain: 'DOESNT_CONTAIN',
    EndsWith: 'ENDS_WITH',
    Regex: 'REGEX',
    RegexDoesntMatch: 'REGEX_DOESNT_MATCH'
} as const;

export type WhatOperator = typeof WhatOperator[keyof typeof WhatOperator];


/**
 * The operator for when condition.
 * @export
 * @enum {string}
 */

export const WhenOperator = {
    Always: 'ALWAYS',
    Equals: 'EQUALS',
    NotEquals: 'NOT_EQUALS'
} as const;

export type WhenOperator = typeof WhenOperator[keyof typeof WhenOperator];


/**
 * An array of objects.
 * @export
 * @interface WithLimits
 */
export interface WithLimits {
    /**
     * 
     * @type {number}
     * @memberof WithLimits
     */
    'account_limits'?: number;
    /**
     * 
     * @type {string}
     * @memberof WithLimits
     */
    'applies_to': string;
    /**
     * 
     * @type {boolean}
     * @memberof WithLimits
     */
    'block'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WithLimits
     */
    'consumption'?: number;
    /**
     * 
     * @type {number}
     * @memberof WithLimits
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof WithLimits
     */
    'limits'?: number;
    /**
     * 
     * @type {number}
     * @memberof WithLimits
     */
    'reference_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof WithLimits
     */
    'reference_type'?: WithLimitsReferenceTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof WithLimits
     */
    'remaining'?: number;
    /**
     * 
     * @type {number}
     * @memberof WithLimits
     */
    'resets_in_seconds'?: number;
    /**
     * 
     * @type {number}
     * @memberof WithLimits
     */
    'subscription_limits'?: number;
}

export const WithLimitsReferenceTypeEnum = {
    Subscription: 'SUBSCRIPTION',
    Account: 'ACCOUNT'
} as const;

export type WithLimitsReferenceTypeEnum = typeof WithLimitsReferenceTypeEnum[keyof typeof WithLimitsReferenceTypeEnum];

/**
 * A Word bias.
 * @export
 * @interface Word
 */
export interface Word {
    /**
     * The bias.
     * @type {number}
     * @memberof Word
     */
    'bias': number;
    /**
     * The cluster of the word.
     * @type {string}
     * @memberof Word
     */
    'cluster': string;
    /**
     * The content generation id.
     * @type {number}
     * @memberof Word
     */
    'content_generation_id': number;
    /**
     * The create date-time.
     * @type {string}
     * @memberof Word
     */
    'created_at'?: string;
    /**
     * The unique id.
     * @type {number}
     * @memberof Word
     */
    'id'?: number;
    /**
     * The last modified date-time.
     * @type {string}
     * @memberof Word
     */
    'modified_at'?: string;
    /**
     * The token id for the word.
     * @type {string}
     * @memberof Word
     */
    'token_id': string;
    /**
     * The actual word.
     * @type {string}
     * @memberof Word
     */
    'word': string;
}
/**
 * Words in completion which are repeated.
 * @export
 * @interface WordRepetitionData
 */
export interface WordRepetitionData {
    /**
     * 
     * @type {number}
     * @memberof WordRepetitionData
     */
    'count'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof WordRepetitionData
     */
    'repeated_in_same_sentence'?: boolean;
}
/**
 * 
 * @export
 * @interface WordRequest
 */
export interface WordRequest {
    /**
     * The bias.
     * @type {number}
     * @memberof WordRequest
     */
    'bias': number;
    /**
     * The actual word.
     * @type {string}
     * @memberof WordRequest
     */
    'word': string;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the account data for the current account identified by its key.
         * @summary Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the account data for the current account identified by its key.
         * @summary Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.getMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * Get the account data for the current account identified by its key.
         * @summary Get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMe(options?: RawAxiosRequestConfig): AxiosPromise<AccountInfo> {
            return localVarFp.getMe(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * Get the account data for the current account identified by its key.
     * @summary Get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getMe(options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).getMe(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountStatsApi - axios parameter creator
 * @export
 */
export const AccountStatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the Account statistics, such the number of products, product groups and urls in the KG.
         * @summary Get my Account statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/me/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountStatsApi - functional programming interface
 * @export
 */
export const AccountStatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountStatsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the Account statistics, such the number of products, product groups and urls in the KG.
         * @summary Get my Account statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountStatsApi.getMyStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountStatsApi - factory interface
 * @export
 */
export const AccountStatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountStatsApiFp(configuration)
    return {
        /**
         * Get the Account statistics, such the number of products, product groups and urls in the KG.
         * @summary Get my Account statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyStats(options?: RawAxiosRequestConfig): AxiosPromise<AccountStats> {
            return localVarFp.getMyStats(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountStatsApi - object-oriented interface
 * @export
 * @class AccountStatsApi
 * @extends {BaseAPI}
 */
export class AccountStatsApi extends BaseAPI {
    /**
     * Get the Account statistics, such the number of products, product groups and urls in the KG.
     * @summary Get my Account statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountStatsApi
     */
    public getMyStats(options?: RawAxiosRequestConfig) {
        return AccountStatsApiFp(this.configuration).getMyStats(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the account
         * @summary Get an account.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAccount', 'id', id)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the accounts
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] 
         * @param {boolean} [canContentGeneration] Filter accounts that can or cannot do Content Generation
         * @param {boolean} [includeEntityCount] Add entity count data
         * @param {boolean} [includeAllAccounts] Include all the accounts the user has access to
         * @param {boolean} [includeSubscription] Include the subscription data
         * @param {string} [url] The URL
         * @param {string} [ngDatasetId] The dataset id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts: async (cursor?: string, limit?: number, canContentGeneration?: boolean, includeEntityCount?: boolean, includeAllAccounts?: boolean, includeSubscription?: boolean, url?: string, ngDatasetId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (canContentGeneration !== undefined) {
                localVarQueryParameter['can_content_generation'] = canContentGeneration;
            }

            if (includeEntityCount !== undefined) {
                localVarQueryParameter['include_entity_count'] = includeEntityCount;
            }

            if (includeAllAccounts !== undefined) {
                localVarQueryParameter['include_all_accounts'] = includeAllAccounts;
            }

            if (includeSubscription !== undefined) {
                localVarQueryParameter['include_subscription'] = includeSubscription;
            }

            if (url !== undefined) {
                localVarQueryParameter['url'] = url;
            }

            if (ngDatasetId !== undefined) {
                localVarQueryParameter['ng_dataset_id'] = ngDatasetId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the account
         * @summary Update an account.
         * @param {number} id 
         * @param {UpdateAccountRequest} updateAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: async (id: number, updateAccountRequest: UpdateAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAccount', 'id', id)
            // verify required parameter 'updateAccountRequest' is not null or undefined
            assertParamExists('updateAccount', 'updateAccountRequest', updateAccountRequest)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the account
         * @summary Get an account.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.getAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the accounts
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] 
         * @param {boolean} [canContentGeneration] Filter accounts that can or cannot do Content Generation
         * @param {boolean} [includeEntityCount] Add entity count data
         * @param {boolean} [includeAllAccounts] Include all the accounts the user has access to
         * @param {boolean} [includeSubscription] Include the subscription data
         * @param {string} [url] The URL
         * @param {string} [ngDatasetId] The dataset id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccounts(cursor?: string, limit?: number, canContentGeneration?: boolean, includeEntityCount?: boolean, includeAllAccounts?: boolean, includeSubscription?: boolean, url?: string, ngDatasetId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageActiveAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccounts(cursor, limit, canContentGeneration, includeEntityCount, includeAllAccounts, includeSubscription, url, ngDatasetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.listAccounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the account
         * @summary Update an account.
         * @param {number} id 
         * @param {UpdateAccountRequest} updateAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccount(id: number, updateAccountRequest: UpdateAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(id, updateAccountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountsApi.updateAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Get the account
         * @summary Get an account.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.getAccount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the accounts
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] 
         * @param {boolean} [canContentGeneration] Filter accounts that can or cannot do Content Generation
         * @param {boolean} [includeEntityCount] Add entity count data
         * @param {boolean} [includeAllAccounts] Include all the accounts the user has access to
         * @param {boolean} [includeSubscription] Include the subscription data
         * @param {string} [url] The URL
         * @param {string} [ngDatasetId] The dataset id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccounts(cursor?: string, limit?: number, canContentGeneration?: boolean, includeEntityCount?: boolean, includeAllAccounts?: boolean, includeSubscription?: boolean, url?: string, ngDatasetId?: string, options?: RawAxiosRequestConfig): AxiosPromise<PageActiveAccount> {
            return localVarFp.listAccounts(cursor, limit, canContentGeneration, includeEntityCount, includeAllAccounts, includeSubscription, url, ngDatasetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the account
         * @summary Update an account.
         * @param {number} id 
         * @param {UpdateAccountRequest} updateAccountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(id: number, updateAccountRequest: UpdateAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.updateAccount(id, updateAccountRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Get the account
     * @summary Get an account.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(id: number, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the accounts
     * @summary List
     * @param {string} [cursor] The cursor
     * @param {number} [limit] 
     * @param {boolean} [canContentGeneration] Filter accounts that can or cannot do Content Generation
     * @param {boolean} [includeEntityCount] Add entity count data
     * @param {boolean} [includeAllAccounts] Include all the accounts the user has access to
     * @param {boolean} [includeSubscription] Include the subscription data
     * @param {string} [url] The URL
     * @param {string} [ngDatasetId] The dataset id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public listAccounts(cursor?: string, limit?: number, canContentGeneration?: boolean, includeEntityCount?: boolean, includeAllAccounts?: boolean, includeSubscription?: boolean, url?: string, ngDatasetId?: string, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).listAccounts(cursor, limit, canContentGeneration, includeEntityCount, includeAllAccounts, includeSubscription, url, ngDatasetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the account
     * @summary Update an account.
     * @param {number} id 
     * @param {UpdateAccountRequest} updateAccountRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public updateAccount(id: number, updateAccountRequest: UpdateAccountRequest, options?: RawAxiosRequestConfig) {
        return AccountsApiFp(this.configuration).updateAccount(id, updateAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AddOnsApi - axios parameter creator
 * @export
 */
export const AddOnsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List the Add-ons configurations
         * @summary List
         * @param {string} [token] The access token
         * @param {string} [key] The key
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConfigurations: async (token?: string, key?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/addon/configurations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddOnsApi - functional programming interface
 * @export
 */
export const AddOnsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddOnsApiAxiosParamCreator(configuration)
    return {
        /**
         * List the Add-ons configurations
         * @summary List
         * @param {string} [token] The access token
         * @param {string} [key] The key
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConfigurations(token?: string, key?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageAddOnConfiguration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConfigurations(token, key, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AddOnsApi.listConfigurations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AddOnsApi - factory interface
 * @export
 */
export const AddOnsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddOnsApiFp(configuration)
    return {
        /**
         * List the Add-ons configurations
         * @summary List
         * @param {string} [token] The access token
         * @param {string} [key] The key
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConfigurations(token?: string, key?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageAddOnConfiguration> {
            return localVarFp.listConfigurations(token, key, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddOnsApi - object-oriented interface
 * @export
 * @class AddOnsApi
 * @extends {BaseAPI}
 */
export class AddOnsApi extends BaseAPI {
    /**
     * List the Add-ons configurations
     * @summary List
     * @param {string} [token] The access token
     * @param {string} [key] The key
     * @param {number} [limit] The maximum number of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddOnsApi
     */
    public listConfigurations(token?: string, key?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return AddOnsApiFp(this.configuration).listConfigurations(token, key, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AgentApi - axios parameter creator
 * @export
 */
export const AgentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Interact with the WordLift Agent to process a message and receive an AI-driven response.
         * @summary Ask Request
         * @param {AskRequest} askRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        askRequestApiAskPost: async (askRequest: AskRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'askRequest' is not null or undefined
            assertParamExists('askRequestApiAskPost', 'askRequest', askRequest)
            const localVarPath = `/ask`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(askRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentApi - functional programming interface
 * @export
 */
export const AgentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AgentApiAxiosParamCreator(configuration)
    return {
        /**
         * Interact with the WordLift Agent to process a message and receive an AI-driven response.
         * @summary Ask Request
         * @param {AskRequest} askRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async askRequestApiAskPost(askRequest: AskRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AskResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.askRequestApiAskPost(askRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentApi.askRequestApiAskPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AgentApi - factory interface
 * @export
 */
export const AgentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AgentApiFp(configuration)
    return {
        /**
         * Interact with the WordLift Agent to process a message and receive an AI-driven response.
         * @summary Ask Request
         * @param {AskRequest} askRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        askRequestApiAskPost(askRequest: AskRequest, options?: RawAxiosRequestConfig): AxiosPromise<AskResponse> {
            return localVarFp.askRequestApiAskPost(askRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgentApi - object-oriented interface
 * @export
 * @class AgentApi
 * @extends {BaseAPI}
 */
export class AgentApi extends BaseAPI {
    /**
     * Interact with the WordLift Agent to process a message and receive an AI-driven response.
     * @summary Ask Request
     * @param {AskRequest} askRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentApi
     */
    public askRequestApiAskPost(askRequest: AskRequest, options?: RawAxiosRequestConfig) {
        return AgentApiFp(this.configuration).askRequestApiAskPost(askRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnalysesApi - axios parameter creator
 * @export
 */
export const AnalysesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Analyze the content provided with the request.
         * @summary Analyse content
         * @param {Request} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyse: async (request: Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('analyse', 'request', request)
            const localVarPath = `/single`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an analysis request
         * @summary Create
         * @param {AnalysesRequest} analysesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (analysesRequest: AnalysesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'analysesRequest' is not null or undefined
            assertParamExists('create', 'analysesRequest', analysesRequest)
            const localVarPath = `/analysis/analyses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analysesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Analyze content and return the results merged as HTML code.
         * @summary Analyse and Merge
         * @param {Request} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        merge: async (request: Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('merge', 'request', request)
            const localVarPath = `/merge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Analyse the content of a webpage by using the `url` property of the request.
         * @summary Analyse Web Page
         * @param {Request} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Analysis: async (request: Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            assertParamExists('v2Analysis', 'request', request)
            const localVarPath = `/v2/analyze`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalysesApi - functional programming interface
 * @export
 */
export const AnalysesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalysesApiAxiosParamCreator(configuration)
    return {
        /**
         * Analyze the content provided with the request.
         * @summary Analyse content
         * @param {Request} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyse(request: Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyse(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysesApi.analyse']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an analysis request
         * @summary Create
         * @param {AnalysesRequest} analysesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(analysesRequest: AnalysesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(analysesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysesApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Analyze content and return the results merged as HTML code.
         * @summary Analyse and Merge
         * @param {Request} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async merge(request: Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.merge(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysesApi.merge']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Analyse the content of a webpage by using the `url` property of the request.
         * @summary Analyse Web Page
         * @param {Request} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async v2Analysis(request: Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.v2Analysis(request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalysesApi.v2Analysis']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalysesApi - factory interface
 * @export
 */
export const AnalysesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalysesApiFp(configuration)
    return {
        /**
         * Analyze the content provided with the request.
         * @summary Analyse content
         * @param {Request} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyse(request: Request, options?: RawAxiosRequestConfig): AxiosPromise<Response> {
            return localVarFp.analyse(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an analysis request
         * @summary Create
         * @param {AnalysesRequest} analysesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(analysesRequest: AnalysesRequest, options?: RawAxiosRequestConfig): AxiosPromise<AnalysesResponse> {
            return localVarFp.create(analysesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Analyze content and return the results merged as HTML code.
         * @summary Analyse and Merge
         * @param {Request} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        merge(request: Request, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.merge(request, options).then((request) => request(axios, basePath));
        },
        /**
         * Analyse the content of a webpage by using the `url` property of the request.
         * @summary Analyse Web Page
         * @param {Request} request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2Analysis(request: Request, options?: RawAxiosRequestConfig): AxiosPromise<Response> {
            return localVarFp.v2Analysis(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalysesApi - object-oriented interface
 * @export
 * @class AnalysesApi
 * @extends {BaseAPI}
 */
export class AnalysesApi extends BaseAPI {
    /**
     * Analyze the content provided with the request.
     * @summary Analyse content
     * @param {Request} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public analyse(request: Request, options?: RawAxiosRequestConfig) {
        return AnalysesApiFp(this.configuration).analyse(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an analysis request
     * @summary Create
     * @param {AnalysesRequest} analysesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public create(analysesRequest: AnalysesRequest, options?: RawAxiosRequestConfig) {
        return AnalysesApiFp(this.configuration).create(analysesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Analyze content and return the results merged as HTML code.
     * @summary Analyse and Merge
     * @param {Request} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public merge(request: Request, options?: RawAxiosRequestConfig) {
        return AnalysesApiFp(this.configuration).merge(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Analyse the content of a webpage by using the `url` property of the request.
     * @summary Analyse Web Page
     * @param {Request} request 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalysesApi
     */
    public v2Analysis(request: Request, options?: RawAxiosRequestConfig) {
        return AnalysesApiFp(this.configuration).v2Analysis(request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnalyticsImportsApi - axios parameter creator
 * @export
 */
export const AnalyticsImportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Analytics Import using Google Search Console or Botify depending on the Account configuration.
         * @summary Create
         * @param {AnalyticsImportRequest} analyticsImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnalyticsImport: async (analyticsImportRequest: AnalyticsImportRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'analyticsImportRequest' is not null or undefined
            assertParamExists('createAnalyticsImport', 'analyticsImportRequest', analyticsImportRequest)
            const localVarPath = `/analytics-imports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(analyticsImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsImportsApi - functional programming interface
 * @export
 */
export const AnalyticsImportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsImportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a Analytics Import using Google Search Console or Botify depending on the Account configuration.
         * @summary Create
         * @param {AnalyticsImportRequest} analyticsImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAnalyticsImport(analyticsImportRequest: AnalyticsImportRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<{ [key: string]: string; }>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAnalyticsImport(analyticsImportRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsImportsApi.createAnalyticsImport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsImportsApi - factory interface
 * @export
 */
export const AnalyticsImportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsImportsApiFp(configuration)
    return {
        /**
         * Create a Analytics Import using Google Search Console or Botify depending on the Account configuration.
         * @summary Create
         * @param {AnalyticsImportRequest} analyticsImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnalyticsImport(analyticsImportRequest: AnalyticsImportRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<{ [key: string]: string; }>> {
            return localVarFp.createAnalyticsImport(analyticsImportRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsImportsApi - object-oriented interface
 * @export
 * @class AnalyticsImportsApi
 * @extends {BaseAPI}
 */
export class AnalyticsImportsApi extends BaseAPI {
    /**
     * Create a Analytics Import using Google Search Console or Botify depending on the Account configuration.
     * @summary Create
     * @param {AnalyticsImportRequest} analyticsImportRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsImportsApi
     */
    public createAnalyticsImport(analyticsImportRequest: AnalyticsImportRequest, options?: RawAxiosRequestConfig) {
        return AnalyticsImportsApiFp(this.configuration).createAnalyticsImport(analyticsImportRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthorsApi - axios parameter creator
 * @export
 */
export const AuthorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates the structured data for an author.
         * @summary Create
         * @param {AuthorRequest} authorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthor: async (authorRequest: AuthorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorRequest' is not null or undefined
            assertParamExists('createAuthor', 'authorRequest', authorRequest)
            const localVarPath = `/data/authors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorsApi - functional programming interface
 * @export
 */
export const AuthorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates the structured data for an author.
         * @summary Create
         * @param {AuthorRequest} authorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthor(authorRequest: AuthorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthor(authorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthorsApi.createAuthor']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthorsApi - factory interface
 * @export
 */
export const AuthorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthorsApiFp(configuration)
    return {
        /**
         * Creates the structured data for an author.
         * @summary Create
         * @param {AuthorRequest} authorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthor(authorRequest: AuthorRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createAuthor(authorRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthorsApi - object-oriented interface
 * @export
 * @class AuthorsApi
 * @extends {BaseAPI}
 */
export class AuthorsApi extends BaseAPI {
    /**
     * Creates the structured data for an author.
     * @summary Create
     * @param {AuthorRequest} authorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorsApi
     */
    public createAuthor(authorRequest: AuthorRequest, options?: RawAxiosRequestConfig) {
        return AuthorsApiFp(this.configuration).createAuthor(authorRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AutocompleteApi - axios parameter creator
 * @export
 */
export const AutocompleteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The autocomplete endpoint suggests entities from Linked Data that match the provided query.
         * @summary Get
         * @param {string} query Autocomplete query
         * @param {string} language 2-letter language code, e.g. \&#39;en\&#39;.
         * @param {GetScopeEnum} [scope] Scope
         * @param {string} [limit] Maximum number of results. By default 10.
         * @param {Set<string>} [exclude] List of entity URIs to exclude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (query: string, language: string, scope?: GetScopeEnum, limit?: string, exclude?: Set<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('get', 'query', query)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('get', 'language', language)
            const localVarPath = `/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (exclude) {
                localVarQueryParameter['exclude'] = Array.from(exclude);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutocompleteApi - functional programming interface
 * @export
 */
export const AutocompleteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutocompleteApiAxiosParamCreator(configuration)
    return {
        /**
         * The autocomplete endpoint suggests entities from Linked Data that match the provided query.
         * @summary Get
         * @param {string} query Autocomplete query
         * @param {string} language 2-letter language code, e.g. \&#39;en\&#39;.
         * @param {GetScopeEnum} [scope] Scope
         * @param {string} [limit] Maximum number of results. By default 10.
         * @param {Set<string>} [exclude] List of entity URIs to exclude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(query: string, language: string, scope?: GetScopeEnum, limit?: string, exclude?: Set<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutocompleteResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(query, language, scope, limit, exclude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AutocompleteApi.get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AutocompleteApi - factory interface
 * @export
 */
export const AutocompleteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutocompleteApiFp(configuration)
    return {
        /**
         * The autocomplete endpoint suggests entities from Linked Data that match the provided query.
         * @summary Get
         * @param {string} query Autocomplete query
         * @param {string} language 2-letter language code, e.g. \&#39;en\&#39;.
         * @param {GetScopeEnum} [scope] Scope
         * @param {string} [limit] Maximum number of results. By default 10.
         * @param {Set<string>} [exclude] List of entity URIs to exclude.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(query: string, language: string, scope?: GetScopeEnum, limit?: string, exclude?: Set<string>, options?: RawAxiosRequestConfig): AxiosPromise<AutocompleteResult> {
            return localVarFp.get(query, language, scope, limit, exclude, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AutocompleteApi - object-oriented interface
 * @export
 * @class AutocompleteApi
 * @extends {BaseAPI}
 */
export class AutocompleteApi extends BaseAPI {
    /**
     * The autocomplete endpoint suggests entities from Linked Data that match the provided query.
     * @summary Get
     * @param {string} query Autocomplete query
     * @param {string} language 2-letter language code, e.g. \&#39;en\&#39;.
     * @param {GetScopeEnum} [scope] Scope
     * @param {string} [limit] Maximum number of results. By default 10.
     * @param {Set<string>} [exclude] List of entity URIs to exclude.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutocompleteApi
     */
    public get(query: string, language: string, scope?: GetScopeEnum, limit?: string, exclude?: Set<string>, options?: RawAxiosRequestConfig) {
        return AutocompleteApiFp(this.configuration).get(query, language, scope, limit, exclude, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetScopeEnum = {
    Cloud: 'cloud'
} as const;
export type GetScopeEnum = typeof GetScopeEnum[keyof typeof GetScopeEnum];


/**
 * BotifyCrawlImportsApi - axios parameter creator
 * @export
 */
export const BotifyCrawlImportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Botify Crawl Import
         * @summary Create
         * @param {BotifyCrawlImportRequest} botifyCrawlImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBotifyCrawlImport: async (botifyCrawlImportRequest: BotifyCrawlImportRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'botifyCrawlImportRequest' is not null or undefined
            assertParamExists('createBotifyCrawlImport', 'botifyCrawlImportRequest', botifyCrawlImportRequest)
            const localVarPath = `/botify-crawl-imports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(botifyCrawlImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BotifyCrawlImportsApi - functional programming interface
 * @export
 */
export const BotifyCrawlImportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BotifyCrawlImportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a Botify Crawl Import
         * @summary Create
         * @param {BotifyCrawlImportRequest} botifyCrawlImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBotifyCrawlImport(botifyCrawlImportRequest: BotifyCrawlImportRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebPage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBotifyCrawlImport(botifyCrawlImportRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BotifyCrawlImportsApi.createBotifyCrawlImport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BotifyCrawlImportsApi - factory interface
 * @export
 */
export const BotifyCrawlImportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BotifyCrawlImportsApiFp(configuration)
    return {
        /**
         * Create a Botify Crawl Import
         * @summary Create
         * @param {BotifyCrawlImportRequest} botifyCrawlImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBotifyCrawlImport(botifyCrawlImportRequest: BotifyCrawlImportRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<WebPage>> {
            return localVarFp.createBotifyCrawlImport(botifyCrawlImportRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BotifyCrawlImportsApi - object-oriented interface
 * @export
 * @class BotifyCrawlImportsApi
 * @extends {BaseAPI}
 */
export class BotifyCrawlImportsApi extends BaseAPI {
    /**
     * Create a Botify Crawl Import
     * @summary Create
     * @param {BotifyCrawlImportRequest} botifyCrawlImportRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BotifyCrawlImportsApi
     */
    public createBotifyCrawlImport(botifyCrawlImportRequest: BotifyCrawlImportRequest, options?: RawAxiosRequestConfig) {
        return BotifyCrawlImportsApiFp(this.configuration).createBotifyCrawlImport(botifyCrawlImportRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ClassificationsApi - axios parameter creator
 * @export
 */
export const ClassificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Classify the text to provided categories
         * @summary Create
         * @param {ClassificationRequest} body body
         * @param {string} [lang] Language code
         * @param {boolean} [multiClass] When set to true the scores will be independent, each will fall between 0 and 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classifyUsingPost: async (body: ClassificationRequest, lang?: string, multiClass?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('classifyUsingPost', 'body', body)
            const localVarPath = `/classification/classify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }

            if (multiClass !== undefined) {
                localVarQueryParameter['multi_class'] = multiClass;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClassificationsApi - functional programming interface
 * @export
 */
export const ClassificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClassificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Classify the text to provided categories
         * @summary Create
         * @param {ClassificationRequest} body body
         * @param {string} [lang] Language code
         * @param {boolean} [multiClass] When set to true the scores will be independent, each will fall between 0 and 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async classifyUsingPost(body: ClassificationRequest, lang?: string, multiClass?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClassificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.classifyUsingPost(body, lang, multiClass, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ClassificationsApi.classifyUsingPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ClassificationsApi - factory interface
 * @export
 */
export const ClassificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClassificationsApiFp(configuration)
    return {
        /**
         * Classify the text to provided categories
         * @summary Create
         * @param {ClassificationRequest} body body
         * @param {string} [lang] Language code
         * @param {boolean} [multiClass] When set to true the scores will be independent, each will fall between 0 and 1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        classifyUsingPost(body: ClassificationRequest, lang?: string, multiClass?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ClassificationResponse> {
            return localVarFp.classifyUsingPost(body, lang, multiClass, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClassificationsApi - object-oriented interface
 * @export
 * @class ClassificationsApi
 * @extends {BaseAPI}
 */
export class ClassificationsApi extends BaseAPI {
    /**
     * Classify the text to provided categories
     * @summary Create
     * @param {ClassificationRequest} body body
     * @param {string} [lang] Language code
     * @param {boolean} [multiClass] When set to true the scores will be independent, each will fall between 0 and 1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClassificationsApi
     */
    public classifyUsingPost(body: ClassificationRequest, lang?: string, multiClass?: boolean, options?: RawAxiosRequestConfig) {
        return ClassificationsApiFp(this.configuration).classifyUsingPost(body, lang, multiClass, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentExpansionsApi - axios parameter creator
 * @export
 */
export const ContentExpansionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Content Expansion
         * @summary Create
         * @param {ContentExpansionRequest} contentExpansionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContentExpansion: async (contentExpansionRequest: ContentExpansionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentExpansionRequest' is not null or undefined
            assertParamExists('createContentExpansion', 'contentExpansionRequest', contentExpansionRequest)
            const localVarPath = `/content-expansions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contentExpansionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentExpansionsApi - functional programming interface
 * @export
 */
export const ContentExpansionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentExpansionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a Content Expansion
         * @summary Create
         * @param {ContentExpansionRequest} contentExpansionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContentExpansion(contentExpansionRequest: ContentExpansionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentExpansionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContentExpansion(contentExpansionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentExpansionsApi.createContentExpansion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentExpansionsApi - factory interface
 * @export
 */
export const ContentExpansionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentExpansionsApiFp(configuration)
    return {
        /**
         * Create a Content Expansion
         * @summary Create
         * @param {ContentExpansionRequest} contentExpansionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContentExpansion(contentExpansionRequest: ContentExpansionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContentExpansionResponse> {
            return localVarFp.createContentExpansion(contentExpansionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentExpansionsApi - object-oriented interface
 * @export
 * @class ContentExpansionsApi
 * @extends {BaseAPI}
 */
export class ContentExpansionsApi extends BaseAPI {
    /**
     * Create a Content Expansion
     * @summary Create
     * @param {ContentExpansionRequest} contentExpansionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentExpansionsApi
     */
    public createContentExpansion(contentExpansionRequest: ContentExpansionRequest, options?: RawAxiosRequestConfig) {
        return ContentExpansionsApiFp(this.configuration).createContentExpansion(contentExpansionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentGenerationCompletionApi - axios parameter creator
 * @export
 */
export const ContentGenerationCompletionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body) - no resources created
         * @summary Create a completion
         * @param {CompletionRequest} completionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompletion: async (completionRequest: CompletionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'completionRequest' is not null or undefined
            assertParamExists('createCompletion', 'completionRequest', completionRequest)
            const localVarPath = `/completions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentGenerationCompletionApi - functional programming interface
 * @export
 */
export const ContentGenerationCompletionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentGenerationCompletionApiAxiosParamCreator(configuration)
    return {
        /**
         * [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body) - no resources created
         * @summary Create a completion
         * @param {CompletionRequest} completionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCompletion(completionRequest: CompletionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCompletion(completionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationCompletionApi.createCompletion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentGenerationCompletionApi - factory interface
 * @export
 */
export const ContentGenerationCompletionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentGenerationCompletionApiFp(configuration)
    return {
        /**
         * [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body) - no resources created
         * @summary Create a completion
         * @param {CompletionRequest} completionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCompletion(completionRequest: CompletionRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createCompletion(completionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentGenerationCompletionApi - object-oriented interface
 * @export
 * @class ContentGenerationCompletionApi
 * @extends {BaseAPI}
 */
export class ContentGenerationCompletionApi extends BaseAPI {
    /**
     * [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body) - no resources created
     * @summary Create a completion
     * @param {CompletionRequest} completionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationCompletionApi
     */
    public createCompletion(completionRequest: CompletionRequest, options?: RawAxiosRequestConfig) {
        return ContentGenerationCompletionApiFp(this.configuration).createCompletion(completionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentGenerationFieldsApi - axios parameter creator
 * @export
 */
export const ContentGenerationFieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List
         * @param {number} contentGenerationId The Content Generation id.
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFields: async (contentGenerationId: number, cursor?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentGenerationId' is not null or undefined
            assertParamExists('listFields', 'contentGenerationId', contentGenerationId)
            const localVarPath = `/content-generations/{contentGenerationId}/fields`
                .replace(`{${"contentGenerationId"}}`, encodeURIComponent(String(contentGenerationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List for GraphQl Query
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFieldsForGraphQlQuery: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('listFieldsForGraphQlQuery', 'body', body)
            const localVarPath = `/fields`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/graphql';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentGenerationFieldsApi - functional programming interface
 * @export
 */
export const ContentGenerationFieldsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentGenerationFieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List
         * @param {number} contentGenerationId The Content Generation id.
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFields(contentGenerationId: number, cursor?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFields(contentGenerationId, cursor, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationFieldsApi.listFields']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List for GraphQl Query
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFieldsForGraphQlQuery(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Field>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFieldsForGraphQlQuery(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationFieldsApi.listFieldsForGraphQlQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentGenerationFieldsApi - factory interface
 * @export
 */
export const ContentGenerationFieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentGenerationFieldsApiFp(configuration)
    return {
        /**
         * 
         * @summary List
         * @param {number} contentGenerationId The Content Generation id.
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFields(contentGenerationId: number, cursor?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageField> {
            return localVarFp.listFields(contentGenerationId, cursor, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List for GraphQl Query
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFieldsForGraphQlQuery(body: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Field>> {
            return localVarFp.listFieldsForGraphQlQuery(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentGenerationFieldsApi - object-oriented interface
 * @export
 * @class ContentGenerationFieldsApi
 * @extends {BaseAPI}
 */
export class ContentGenerationFieldsApi extends BaseAPI {
    /**
     * 
     * @summary List
     * @param {number} contentGenerationId The Content Generation id.
     * @param {string} [cursor] The cursor
     * @param {number} [limit] The maximum number of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationFieldsApi
     */
    public listFields(contentGenerationId: number, cursor?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return ContentGenerationFieldsApiFp(this.configuration).listFields(contentGenerationId, cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List for GraphQl Query
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationFieldsApi
     */
    public listFieldsForGraphQlQuery(body: string, options?: RawAxiosRequestConfig) {
        return ContentGenerationFieldsApiFp(this.configuration).listFieldsForGraphQlQuery(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentGenerationModelsApi - axios parameter creator
 * @export
 */
export const ContentGenerationModelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels: async (cursor?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentGenerationModelsApi - functional programming interface
 * @export
 */
export const ContentGenerationModelsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentGenerationModelsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listModels(cursor?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listModels(cursor, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationModelsApi.listModels']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentGenerationModelsApi - factory interface
 * @export
 */
export const ContentGenerationModelsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentGenerationModelsApiFp(configuration)
    return {
        /**
         * 
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listModels(cursor?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageModel> {
            return localVarFp.listModels(cursor, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentGenerationModelsApi - object-oriented interface
 * @export
 * @class ContentGenerationModelsApi
 * @extends {BaseAPI}
 */
export class ContentGenerationModelsApi extends BaseAPI {
    /**
     * 
     * @summary List
     * @param {string} [cursor] The cursor
     * @param {number} [limit] The maximum number of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationModelsApi
     */
    public listModels(cursor?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return ContentGenerationModelsApiFp(this.configuration).listModels(cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentGenerationPresetsApi - axios parameter creator
 * @export
 */
export const ContentGenerationPresetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPresets: async (cursor?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/graphql-query-presets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentGenerationPresetsApi - functional programming interface
 * @export
 */
export const ContentGenerationPresetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentGenerationPresetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPresets(cursor?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagePreset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPresets(cursor, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationPresetsApi.listPresets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentGenerationPresetsApi - factory interface
 * @export
 */
export const ContentGenerationPresetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentGenerationPresetsApiFp(configuration)
    return {
        /**
         * 
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPresets(cursor?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PagePreset> {
            return localVarFp.listPresets(cursor, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentGenerationPresetsApi - object-oriented interface
 * @export
 * @class ContentGenerationPresetsApi
 * @extends {BaseAPI}
 */
export class ContentGenerationPresetsApi extends BaseAPI {
    /**
     * 
     * @summary List
     * @param {string} [cursor] The cursor
     * @param {number} [limit] The maximum number of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationPresetsApi
     */
    public listPresets(cursor?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return ContentGenerationPresetsApiFp(this.configuration).listPresets(cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentGenerationRecordsApi - axios parameter creator
 * @export
 */
export const ContentGenerationRecordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get
         * @param {number} contentGenerationId The Content Generation id.
         * @param {number} recordId The Record id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecord: async (contentGenerationId: number, recordId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentGenerationId' is not null or undefined
            assertParamExists('getRecord', 'contentGenerationId', contentGenerationId)
            // verify required parameter 'recordId' is not null or undefined
            assertParamExists('getRecord', 'recordId', recordId)
            const localVarPath = `/content-generations/{contentGenerationId}/records/{recordId}`
                .replace(`{${"contentGenerationId"}}`, encodeURIComponent(String(contentGenerationId)))
                .replace(`{${"recordId"}}`, encodeURIComponent(String(recordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List
         * @param {number} contentGenerationId The Content Generation id.
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {string} [q] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecords: async (contentGenerationId: number, cursor?: string, limit?: number, q?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentGenerationId' is not null or undefined
            assertParamExists('listRecords', 'contentGenerationId', contentGenerationId)
            const localVarPath = `/content-generations/{contentGenerationId}/records`
                .replace(`{${"contentGenerationId"}}`, encodeURIComponent(String(contentGenerationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List as Events
         * @param {number} contentGenerationId The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecordsAsEvents: async (contentGenerationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentGenerationId' is not null or undefined
            assertParamExists('listRecordsAsEvents', 'contentGenerationId', contentGenerationId)
            const localVarPath = `/content-generations/{contentGenerationId}/records-sse`
                .replace(`{${"contentGenerationId"}}`, encodeURIComponent(String(contentGenerationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update
         * @param {number} contentGenerationId The Content Generation id.
         * @param {number} recordId The Record id.
         * @param {Request3} request3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentGenerationRecord: async (contentGenerationId: number, recordId: number, request3: Request3, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentGenerationId' is not null or undefined
            assertParamExists('updateContentGenerationRecord', 'contentGenerationId', contentGenerationId)
            // verify required parameter 'recordId' is not null or undefined
            assertParamExists('updateContentGenerationRecord', 'recordId', recordId)
            // verify required parameter 'request3' is not null or undefined
            assertParamExists('updateContentGenerationRecord', 'request3', request3)
            const localVarPath = `/content-generations/{contentGenerationId}/records/{recordId}`
                .replace(`{${"contentGenerationId"}}`, encodeURIComponent(String(contentGenerationId)))
                .replace(`{${"recordId"}}`, encodeURIComponent(String(recordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request3, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update
         * @param {number} contentGenerationId The Content Generation id.
         * @param {boolean} isAccepted Completion accepted
         * @param {UpdateRecordsRequest} updateRecordsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecords: async (contentGenerationId: number, isAccepted: boolean, updateRecordsRequest: UpdateRecordsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentGenerationId' is not null or undefined
            assertParamExists('updateRecords', 'contentGenerationId', contentGenerationId)
            // verify required parameter 'isAccepted' is not null or undefined
            assertParamExists('updateRecords', 'isAccepted', isAccepted)
            // verify required parameter 'updateRecordsRequest' is not null or undefined
            assertParamExists('updateRecords', 'updateRecordsRequest', updateRecordsRequest)
            const localVarPath = `/content-generations/{contentGenerationId}/records`
                .replace(`{${"contentGenerationId"}}`, encodeURIComponent(String(contentGenerationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (isAccepted !== undefined) {
                localVarQueryParameter['is_accepted'] = isAccepted;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRecordsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update
         * @param {number} contentGenerationId The Content Generation id.
         * @param {Array<UpdateRecordRequest>} updateRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordsCollection: async (contentGenerationId: number, updateRecordRequest: Array<UpdateRecordRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentGenerationId' is not null or undefined
            assertParamExists('updateRecordsCollection', 'contentGenerationId', contentGenerationId)
            // verify required parameter 'updateRecordRequest' is not null or undefined
            assertParamExists('updateRecordsCollection', 'updateRecordRequest', updateRecordRequest)
            const localVarPath = `/content-generations/{contentGenerationId}/records-collection`
                .replace(`{${"contentGenerationId"}}`, encodeURIComponent(String(contentGenerationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentGenerationRecordsApi - functional programming interface
 * @export
 */
export const ContentGenerationRecordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentGenerationRecordsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get
         * @param {number} contentGenerationId The Content Generation id.
         * @param {number} recordId The Record id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecord(contentGenerationId: number, recordId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Record>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecord(contentGenerationId, recordId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationRecordsApi.getRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List
         * @param {number} contentGenerationId The Content Generation id.
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {string} [q] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecords(contentGenerationId: number, cursor?: string, limit?: number, q?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecords(contentGenerationId, cursor, limit, q, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationRecordsApi.listRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List as Events
         * @param {number} contentGenerationId The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecordsAsEvents(contentGenerationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecordsAsEvents(contentGenerationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationRecordsApi.listRecordsAsEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update
         * @param {number} contentGenerationId The Content Generation id.
         * @param {number} recordId The Record id.
         * @param {Request3} request3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContentGenerationRecord(contentGenerationId: number, recordId: number, request3: Request3, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Record>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContentGenerationRecord(contentGenerationId, recordId, request3, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationRecordsApi.updateContentGenerationRecord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update
         * @param {number} contentGenerationId The Content Generation id.
         * @param {boolean} isAccepted Completion accepted
         * @param {UpdateRecordsRequest} updateRecordsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecords(contentGenerationId: number, isAccepted: boolean, updateRecordsRequest: UpdateRecordsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecords(contentGenerationId, isAccepted, updateRecordsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationRecordsApi.updateRecords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update
         * @param {number} contentGenerationId The Content Generation id.
         * @param {Array<UpdateRecordRequest>} updateRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecordsCollection(contentGenerationId: number, updateRecordRequest: Array<UpdateRecordRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Record>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecordsCollection(contentGenerationId, updateRecordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationRecordsApi.updateRecordsCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentGenerationRecordsApi - factory interface
 * @export
 */
export const ContentGenerationRecordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentGenerationRecordsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get
         * @param {number} contentGenerationId The Content Generation id.
         * @param {number} recordId The Record id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecord(contentGenerationId: number, recordId: number, options?: RawAxiosRequestConfig): AxiosPromise<Record> {
            return localVarFp.getRecord(contentGenerationId, recordId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List
         * @param {number} contentGenerationId The Content Generation id.
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {string} [q] Search query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecords(contentGenerationId: number, cursor?: string, limit?: number, q?: string, options?: RawAxiosRequestConfig): AxiosPromise<PageRecord> {
            return localVarFp.listRecords(contentGenerationId, cursor, limit, q, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List as Events
         * @param {number} contentGenerationId The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecordsAsEvents(contentGenerationId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listRecordsAsEvents(contentGenerationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update
         * @param {number} contentGenerationId The Content Generation id.
         * @param {number} recordId The Record id.
         * @param {Request3} request3 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentGenerationRecord(contentGenerationId: number, recordId: number, request3: Request3, options?: RawAxiosRequestConfig): AxiosPromise<Record> {
            return localVarFp.updateContentGenerationRecord(contentGenerationId, recordId, request3, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update
         * @param {number} contentGenerationId The Content Generation id.
         * @param {boolean} isAccepted Completion accepted
         * @param {UpdateRecordsRequest} updateRecordsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecords(contentGenerationId: number, isAccepted: boolean, updateRecordsRequest: UpdateRecordsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateRecords(contentGenerationId, isAccepted, updateRecordsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update
         * @param {number} contentGenerationId The Content Generation id.
         * @param {Array<UpdateRecordRequest>} updateRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecordsCollection(contentGenerationId: number, updateRecordRequest: Array<UpdateRecordRequest>, options?: RawAxiosRequestConfig): AxiosPromise<Array<Record>> {
            return localVarFp.updateRecordsCollection(contentGenerationId, updateRecordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentGenerationRecordsApi - object-oriented interface
 * @export
 * @class ContentGenerationRecordsApi
 * @extends {BaseAPI}
 */
export class ContentGenerationRecordsApi extends BaseAPI {
    /**
     * 
     * @summary Get
     * @param {number} contentGenerationId The Content Generation id.
     * @param {number} recordId The Record id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationRecordsApi
     */
    public getRecord(contentGenerationId: number, recordId: number, options?: RawAxiosRequestConfig) {
        return ContentGenerationRecordsApiFp(this.configuration).getRecord(contentGenerationId, recordId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List
     * @param {number} contentGenerationId The Content Generation id.
     * @param {string} [cursor] The cursor
     * @param {number} [limit] The maximum number of results
     * @param {string} [q] Search query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationRecordsApi
     */
    public listRecords(contentGenerationId: number, cursor?: string, limit?: number, q?: string, options?: RawAxiosRequestConfig) {
        return ContentGenerationRecordsApiFp(this.configuration).listRecords(contentGenerationId, cursor, limit, q, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List as Events
     * @param {number} contentGenerationId The Content Generation id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationRecordsApi
     */
    public listRecordsAsEvents(contentGenerationId: number, options?: RawAxiosRequestConfig) {
        return ContentGenerationRecordsApiFp(this.configuration).listRecordsAsEvents(contentGenerationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update
     * @param {number} contentGenerationId The Content Generation id.
     * @param {number} recordId The Record id.
     * @param {Request3} request3 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationRecordsApi
     */
    public updateContentGenerationRecord(contentGenerationId: number, recordId: number, request3: Request3, options?: RawAxiosRequestConfig) {
        return ContentGenerationRecordsApiFp(this.configuration).updateContentGenerationRecord(contentGenerationId, recordId, request3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update
     * @param {number} contentGenerationId The Content Generation id.
     * @param {boolean} isAccepted Completion accepted
     * @param {UpdateRecordsRequest} updateRecordsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationRecordsApi
     */
    public updateRecords(contentGenerationId: number, isAccepted: boolean, updateRecordsRequest: UpdateRecordsRequest, options?: RawAxiosRequestConfig) {
        return ContentGenerationRecordsApiFp(this.configuration).updateRecords(contentGenerationId, isAccepted, updateRecordsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update
     * @param {number} contentGenerationId The Content Generation id.
     * @param {Array<UpdateRecordRequest>} updateRecordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationRecordsApi
     */
    public updateRecordsCollection(contentGenerationId: number, updateRecordRequest: Array<UpdateRecordRequest>, options?: RawAxiosRequestConfig) {
        return ContentGenerationRecordsApiFp(this.configuration).updateRecordsCollection(contentGenerationId, updateRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentGenerationRecordsExportApi - axios parameter creator
 * @export
 */
export const ContentGenerationRecordsExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} contentGenerationId The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export: async (contentGenerationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentGenerationId' is not null or undefined
            assertParamExists('_export', 'contentGenerationId', contentGenerationId)
            const localVarPath = `/content-generations/{contentGenerationId}/records.tsv`
                .replace(`{${"contentGenerationId"}}`, encodeURIComponent(String(contentGenerationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentGenerationRecordsExportApi - functional programming interface
 * @export
 */
export const ContentGenerationRecordsExportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentGenerationRecordsExportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} contentGenerationId The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _export(contentGenerationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._export(contentGenerationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationRecordsExportApi._export']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentGenerationRecordsExportApi - factory interface
 * @export
 */
export const ContentGenerationRecordsExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentGenerationRecordsExportApiFp(configuration)
    return {
        /**
         * 
         * @param {number} contentGenerationId The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export(contentGenerationId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp._export(contentGenerationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentGenerationRecordsExportApi - object-oriented interface
 * @export
 * @class ContentGenerationRecordsExportApi
 * @extends {BaseAPI}
 */
export class ContentGenerationRecordsExportApi extends BaseAPI {
    /**
     * 
     * @param {number} contentGenerationId The Content Generation id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationRecordsExportApi
     */
    public _export(contentGenerationId: number, options?: RawAxiosRequestConfig) {
        return ContentGenerationRecordsExportApiFp(this.configuration)._export(contentGenerationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentGenerationRendersApi - axios parameter creator
 * @export
 */
export const ContentGenerationRendersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body) - no resources created
         * @summary Render
         * @param {RenderRequest} renderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderTemplate: async (renderRequest: RenderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'renderRequest' is not null or undefined
            assertParamExists('renderTemplate', 'renderRequest', renderRequest)
            const localVarPath = `/content-generations/renders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body) - no resources created
         * @summary Render
         * @param {Array<RenderRequest>} renderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderTemplateCollection: async (renderRequest: Array<RenderRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'renderRequest' is not null or undefined
            assertParamExists('renderTemplateCollection', 'renderRequest', renderRequest)
            const localVarPath = `/content-generations/renders-collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentGenerationRendersApi - functional programming interface
 * @export
 */
export const ContentGenerationRendersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentGenerationRendersApiAxiosParamCreator(configuration)
    return {
        /**
         * [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body) - no resources created
         * @summary Render
         * @param {RenderRequest} renderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renderTemplate(renderRequest: RenderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renderTemplate(renderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationRendersApi.renderTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body) - no resources created
         * @summary Render
         * @param {Array<RenderRequest>} renderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renderTemplateCollection(renderRequest: Array<RenderRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renderTemplateCollection(renderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationRendersApi.renderTemplateCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentGenerationRendersApi - factory interface
 * @export
 */
export const ContentGenerationRendersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentGenerationRendersApiFp(configuration)
    return {
        /**
         * [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body) - no resources created
         * @summary Render
         * @param {RenderRequest} renderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderTemplate(renderRequest: RenderRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.renderTemplate(renderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body) - no resources created
         * @summary Render
         * @param {Array<RenderRequest>} renderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renderTemplateCollection(renderRequest: Array<RenderRequest>, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.renderTemplateCollection(renderRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentGenerationRendersApi - object-oriented interface
 * @export
 * @class ContentGenerationRendersApi
 * @extends {BaseAPI}
 */
export class ContentGenerationRendersApi extends BaseAPI {
    /**
     * [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body) - no resources created
     * @summary Render
     * @param {RenderRequest} renderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationRendersApi
     */
    public renderTemplate(renderRequest: RenderRequest, options?: RawAxiosRequestConfig) {
        return ContentGenerationRendersApiFp(this.configuration).renderTemplate(renderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * [GET with body payload](https://opensource.zalando.com/restful-api-guidelines/#get-with-body) - no resources created
     * @summary Render
     * @param {Array<RenderRequest>} renderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationRendersApi
     */
    public renderTemplateCollection(renderRequest: Array<RenderRequest>, options?: RawAxiosRequestConfig) {
        return ContentGenerationRendersApiFp(this.configuration).renderTemplateCollection(renderRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentGenerationStatsApi - axios parameter creator
 * @export
 */
export const ContentGenerationStatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get
         * @param {number} contentGenerationId The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get4: async (contentGenerationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentGenerationId' is not null or undefined
            assertParamExists('get4', 'contentGenerationId', contentGenerationId)
            const localVarPath = `/content-generations/{contentGenerationId}/stats`
                .replace(`{${"contentGenerationId"}}`, encodeURIComponent(String(contentGenerationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentGenerationStatsApi - functional programming interface
 * @export
 */
export const ContentGenerationStatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentGenerationStatsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get
         * @param {number} contentGenerationId The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get4(contentGenerationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentGenerationStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get4(contentGenerationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationStatsApi.get4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentGenerationStatsApi - factory interface
 * @export
 */
export const ContentGenerationStatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentGenerationStatsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get
         * @param {number} contentGenerationId The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get4(contentGenerationId: number, options?: RawAxiosRequestConfig): AxiosPromise<ContentGenerationStats> {
            return localVarFp.get4(contentGenerationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentGenerationStatsApi - object-oriented interface
 * @export
 * @class ContentGenerationStatsApi
 * @extends {BaseAPI}
 */
export class ContentGenerationStatsApi extends BaseAPI {
    /**
     * 
     * @summary Get
     * @param {number} contentGenerationId The Content Generation id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationStatsApi
     */
    public get4(contentGenerationId: number, options?: RawAxiosRequestConfig) {
        return ContentGenerationStatsApiFp(this.configuration).get4(contentGenerationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentGenerationSyncsApi - axios parameter creator
 * @export
 */
export const ContentGenerationSyncsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create
         * @param {number} contentGenerationId The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSync1: async (contentGenerationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentGenerationId' is not null or undefined
            assertParamExists('createSync1', 'contentGenerationId', contentGenerationId)
            const localVarPath = `/content-generations/{contentGenerationId}/syncs`
                .replace(`{${"contentGenerationId"}}`, encodeURIComponent(String(contentGenerationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentGenerationSyncsApi - functional programming interface
 * @export
 */
export const ContentGenerationSyncsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentGenerationSyncsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {number} contentGenerationId The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSync1(contentGenerationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSync1(contentGenerationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationSyncsApi.createSync1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentGenerationSyncsApi - factory interface
 * @export
 */
export const ContentGenerationSyncsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentGenerationSyncsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {number} contentGenerationId The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSync1(contentGenerationId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createSync1(contentGenerationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentGenerationSyncsApi - object-oriented interface
 * @export
 * @class ContentGenerationSyncsApi
 * @extends {BaseAPI}
 */
export class ContentGenerationSyncsApi extends BaseAPI {
    /**
     * 
     * @summary Create
     * @param {number} contentGenerationId The Content Generation id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationSyncsApi
     */
    public createSync1(contentGenerationId: number, options?: RawAxiosRequestConfig) {
        return ContentGenerationSyncsApiFp(this.configuration).createSync1(contentGenerationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentGenerationWordBiasesApi - axios parameter creator
 * @export
 */
export const ContentGenerationWordBiasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create
         * @param {number} contentGenerationId The Content Generation id.
         * @param {WordRequest} wordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWord: async (contentGenerationId: number, wordRequest: WordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentGenerationId' is not null or undefined
            assertParamExists('createWord', 'contentGenerationId', contentGenerationId)
            // verify required parameter 'wordRequest' is not null or undefined
            assertParamExists('createWord', 'wordRequest', wordRequest)
            const localVarPath = `/content-generations/{contentGenerationId}/words`
                .replace(`{${"contentGenerationId"}}`, encodeURIComponent(String(contentGenerationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a list of word biases for this prompt. Existing words will be deleted.
         * @summary Update for prompt
         * @param {number} contentGenerationId The Content Generation id.
         * @param {Array<WordRequest>} [wordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWords: async (contentGenerationId: number, wordRequest?: Array<WordRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentGenerationId' is not null or undefined
            assertParamExists('createWords', 'contentGenerationId', contentGenerationId)
            const localVarPath = `/content-generations/{contentGenerationId}/words`
                .replace(`{${"contentGenerationId"}}`, encodeURIComponent(String(contentGenerationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update from CSV
         * @param {number} contentGenerationId The Content Generation id.
         * @param {string} body 
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWordsFromCSV: async (contentGenerationId: number, body: string, contentType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentGenerationId' is not null or undefined
            assertParamExists('createWordsFromCSV', 'contentGenerationId', contentGenerationId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createWordsFromCSV', 'body', body)
            const localVarPath = `/content-generations/{contentGenerationId}/words/imports`
                .replace(`{${"contentGenerationId"}}`, encodeURIComponent(String(contentGenerationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'text/csv';

            if (contentType != null) {
                localVarHeaderParameter['content-type'] = String(contentType);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete
         * @param {number} contentGenerationId The Content Generation id.
         * @param {number} id The Word to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWord: async (contentGenerationId: number, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentGenerationId' is not null or undefined
            assertParamExists('deleteWord', 'contentGenerationId', contentGenerationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWord', 'id', id)
            const localVarPath = `/content-generations/{contentGenerationId}/words/{id}`
                .replace(`{${"contentGenerationId"}}`, encodeURIComponent(String(contentGenerationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List
         * @param {number} contentGenerationId The Content Generation id.
         * @param {string} [theCursor] 
         * @param {number} [theMaximumNumberOfResults] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWords: async (contentGenerationId: number, theCursor?: string, theMaximumNumberOfResults?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentGenerationId' is not null or undefined
            assertParamExists('listWords', 'contentGenerationId', contentGenerationId)
            const localVarPath = `/content-generations/{contentGenerationId}/words`
                .replace(`{${"contentGenerationId"}}`, encodeURIComponent(String(contentGenerationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (theCursor !== undefined) {
                localVarQueryParameter['The cursor.'] = theCursor;
            }

            if (theMaximumNumberOfResults !== undefined) {
                localVarQueryParameter['The maximum number of results.'] = theMaximumNumberOfResults;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update
         * @param {number} contentGenerationId The Content Generation id.
         * @param {number} id The Word bias to update.
         * @param {WordRequest} wordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWord: async (contentGenerationId: number, id: number, wordRequest: WordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentGenerationId' is not null or undefined
            assertParamExists('updateWord', 'contentGenerationId', contentGenerationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateWord', 'id', id)
            // verify required parameter 'wordRequest' is not null or undefined
            assertParamExists('updateWord', 'wordRequest', wordRequest)
            const localVarPath = `/content-generations/{contentGenerationId}/words/{id}`
                .replace(`{${"contentGenerationId"}}`, encodeURIComponent(String(contentGenerationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentGenerationWordBiasesApi - functional programming interface
 * @export
 */
export const ContentGenerationWordBiasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentGenerationWordBiasesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {number} contentGenerationId The Content Generation id.
         * @param {WordRequest} wordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWord(contentGenerationId: number, wordRequest: WordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Word>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWord(contentGenerationId, wordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationWordBiasesApi.createWord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a list of word biases for this prompt. Existing words will be deleted.
         * @summary Update for prompt
         * @param {number} contentGenerationId The Content Generation id.
         * @param {Array<WordRequest>} [wordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWords(contentGenerationId: number, wordRequest?: Array<WordRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Word>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWords(contentGenerationId, wordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationWordBiasesApi.createWords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update from CSV
         * @param {number} contentGenerationId The Content Generation id.
         * @param {string} body 
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWordsFromCSV(contentGenerationId: number, body: string, contentType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWordsFromCSV(contentGenerationId, body, contentType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationWordBiasesApi.createWordsFromCSV']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete
         * @param {number} contentGenerationId The Content Generation id.
         * @param {number} id The Word to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWord(contentGenerationId: number, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWord(contentGenerationId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationWordBiasesApi.deleteWord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List
         * @param {number} contentGenerationId The Content Generation id.
         * @param {string} [theCursor] 
         * @param {number} [theMaximumNumberOfResults] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWords(contentGenerationId: number, theCursor?: string, theMaximumNumberOfResults?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageWord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWords(contentGenerationId, theCursor, theMaximumNumberOfResults, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationWordBiasesApi.listWords']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update
         * @param {number} contentGenerationId The Content Generation id.
         * @param {number} id The Word bias to update.
         * @param {WordRequest} wordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWord(contentGenerationId: number, id: number, wordRequest: WordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Word>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWord(contentGenerationId, id, wordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationWordBiasesApi.updateWord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentGenerationWordBiasesApi - factory interface
 * @export
 */
export const ContentGenerationWordBiasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentGenerationWordBiasesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {number} contentGenerationId The Content Generation id.
         * @param {WordRequest} wordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWord(contentGenerationId: number, wordRequest: WordRequest, options?: RawAxiosRequestConfig): AxiosPromise<Word> {
            return localVarFp.createWord(contentGenerationId, wordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a list of word biases for this prompt. Existing words will be deleted.
         * @summary Update for prompt
         * @param {number} contentGenerationId The Content Generation id.
         * @param {Array<WordRequest>} [wordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWords(contentGenerationId: number, wordRequest?: Array<WordRequest>, options?: RawAxiosRequestConfig): AxiosPromise<Array<Word>> {
            return localVarFp.createWords(contentGenerationId, wordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update from CSV
         * @param {number} contentGenerationId The Content Generation id.
         * @param {string} body 
         * @param {string} [contentType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWordsFromCSV(contentGenerationId: number, body: string, contentType?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createWordsFromCSV(contentGenerationId, body, contentType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete
         * @param {number} contentGenerationId The Content Generation id.
         * @param {number} id The Word to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWord(contentGenerationId: number, id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWord(contentGenerationId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List
         * @param {number} contentGenerationId The Content Generation id.
         * @param {string} [theCursor] 
         * @param {number} [theMaximumNumberOfResults] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWords(contentGenerationId: number, theCursor?: string, theMaximumNumberOfResults?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageWord> {
            return localVarFp.listWords(contentGenerationId, theCursor, theMaximumNumberOfResults, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update
         * @param {number} contentGenerationId The Content Generation id.
         * @param {number} id The Word bias to update.
         * @param {WordRequest} wordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWord(contentGenerationId: number, id: number, wordRequest: WordRequest, options?: RawAxiosRequestConfig): AxiosPromise<Word> {
            return localVarFp.updateWord(contentGenerationId, id, wordRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentGenerationWordBiasesApi - object-oriented interface
 * @export
 * @class ContentGenerationWordBiasesApi
 * @extends {BaseAPI}
 */
export class ContentGenerationWordBiasesApi extends BaseAPI {
    /**
     * 
     * @summary Create
     * @param {number} contentGenerationId The Content Generation id.
     * @param {WordRequest} wordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationWordBiasesApi
     */
    public createWord(contentGenerationId: number, wordRequest: WordRequest, options?: RawAxiosRequestConfig) {
        return ContentGenerationWordBiasesApiFp(this.configuration).createWord(contentGenerationId, wordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a list of word biases for this prompt. Existing words will be deleted.
     * @summary Update for prompt
     * @param {number} contentGenerationId The Content Generation id.
     * @param {Array<WordRequest>} [wordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationWordBiasesApi
     */
    public createWords(contentGenerationId: number, wordRequest?: Array<WordRequest>, options?: RawAxiosRequestConfig) {
        return ContentGenerationWordBiasesApiFp(this.configuration).createWords(contentGenerationId, wordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update from CSV
     * @param {number} contentGenerationId The Content Generation id.
     * @param {string} body 
     * @param {string} [contentType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationWordBiasesApi
     */
    public createWordsFromCSV(contentGenerationId: number, body: string, contentType?: string, options?: RawAxiosRequestConfig) {
        return ContentGenerationWordBiasesApiFp(this.configuration).createWordsFromCSV(contentGenerationId, body, contentType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete
     * @param {number} contentGenerationId The Content Generation id.
     * @param {number} id The Word to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationWordBiasesApi
     */
    public deleteWord(contentGenerationId: number, id: number, options?: RawAxiosRequestConfig) {
        return ContentGenerationWordBiasesApiFp(this.configuration).deleteWord(contentGenerationId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List
     * @param {number} contentGenerationId The Content Generation id.
     * @param {string} [theCursor] 
     * @param {number} [theMaximumNumberOfResults] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationWordBiasesApi
     */
    public listWords(contentGenerationId: number, theCursor?: string, theMaximumNumberOfResults?: number, options?: RawAxiosRequestConfig) {
        return ContentGenerationWordBiasesApiFp(this.configuration).listWords(contentGenerationId, theCursor, theMaximumNumberOfResults, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update
     * @param {number} contentGenerationId The Content Generation id.
     * @param {number} id The Word bias to update.
     * @param {WordRequest} wordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationWordBiasesApi
     */
    public updateWord(contentGenerationId: number, id: number, wordRequest: WordRequest, options?: RawAxiosRequestConfig) {
        return ContentGenerationWordBiasesApiFp(this.configuration).updateWord(contentGenerationId, id, wordRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ContentGenerationsApi - axios parameter creator
 * @export
 */
export const ContentGenerationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create
         * @param {ContentGenerationRequest} contentGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContentGeneration: async (contentGenerationRequest: ContentGenerationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentGenerationRequest' is not null or undefined
            assertParamExists('createContentGeneration', 'contentGenerationRequest', contentGenerationRequest)
            const localVarPath = `/content-generations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contentGenerationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete
         * @param {number} id The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContentGeneration: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteContentGeneration', 'id', id)
            const localVarPath = `/content-generations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Duplicate
         * @param {number} fromContentGenerationId The Content Generation id to duplicate from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateContentGeneration: async (fromContentGenerationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromContentGenerationId' is not null or undefined
            assertParamExists('duplicateContentGeneration', 'fromContentGenerationId', fromContentGenerationId)
            const localVarPath = `/content-generations/{from_content_generation_id}/duplicates`
                .replace(`{${"from_content_generation_id"}}`, encodeURIComponent(String(fromContentGenerationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get
         * @param {number} id The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentGeneration: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContentGeneration', 'id', id)
            const localVarPath = `/content-generations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {boolean} [deleted] Filter for the deleted flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContentGenerations: async (cursor?: string, limit?: number, deleted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/content-generations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update
         * @param {number} id The Content Generation id.
         * @param {ContentGenerationRequest} contentGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentGeneration: async (id: number, contentGenerationRequest: ContentGenerationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateContentGeneration', 'id', id)
            // verify required parameter 'contentGenerationRequest' is not null or undefined
            assertParamExists('updateContentGeneration', 'contentGenerationRequest', contentGenerationRequest)
            const localVarPath = `/content-generations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contentGenerationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentGenerationsApi - functional programming interface
 * @export
 */
export const ContentGenerationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentGenerationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {ContentGenerationRequest} contentGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContentGeneration(contentGenerationRequest: ContentGenerationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentGeneration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContentGeneration(contentGenerationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationsApi.createContentGeneration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete
         * @param {number} id The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContentGeneration(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContentGeneration(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationsApi.deleteContentGeneration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Duplicate
         * @param {number} fromContentGenerationId The Content Generation id to duplicate from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async duplicateContentGeneration(fromContentGenerationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentGeneration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.duplicateContentGeneration(fromContentGenerationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationsApi.duplicateContentGeneration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get
         * @param {number} id The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentGeneration(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentGeneration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContentGeneration(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationsApi.getContentGeneration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {boolean} [deleted] Filter for the deleted flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContentGenerations(cursor?: string, limit?: number, deleted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageContentGeneration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listContentGenerations(cursor, limit, deleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationsApi.listContentGenerations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update
         * @param {number} id The Content Generation id.
         * @param {ContentGenerationRequest} contentGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContentGeneration(id: number, contentGenerationRequest: ContentGenerationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentGeneration>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContentGeneration(id, contentGenerationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentGenerationsApi.updateContentGeneration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentGenerationsApi - factory interface
 * @export
 */
export const ContentGenerationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentGenerationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {ContentGenerationRequest} contentGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContentGeneration(contentGenerationRequest: ContentGenerationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContentGeneration> {
            return localVarFp.createContentGeneration(contentGenerationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete
         * @param {number} id The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContentGeneration(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteContentGeneration(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Duplicate
         * @param {number} fromContentGenerationId The Content Generation id to duplicate from.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateContentGeneration(fromContentGenerationId: number, options?: RawAxiosRequestConfig): AxiosPromise<ContentGeneration> {
            return localVarFp.duplicateContentGeneration(fromContentGenerationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get
         * @param {number} id The Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentGeneration(id: number, options?: RawAxiosRequestConfig): AxiosPromise<ContentGeneration> {
            return localVarFp.getContentGeneration(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {boolean} [deleted] Filter for the deleted flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContentGenerations(cursor?: string, limit?: number, deleted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<PageContentGeneration> {
            return localVarFp.listContentGenerations(cursor, limit, deleted, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update
         * @param {number} id The Content Generation id.
         * @param {ContentGenerationRequest} contentGenerationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContentGeneration(id: number, contentGenerationRequest: ContentGenerationRequest, options?: RawAxiosRequestConfig): AxiosPromise<ContentGeneration> {
            return localVarFp.updateContentGeneration(id, contentGenerationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentGenerationsApi - object-oriented interface
 * @export
 * @class ContentGenerationsApi
 * @extends {BaseAPI}
 */
export class ContentGenerationsApi extends BaseAPI {
    /**
     * 
     * @summary Create
     * @param {ContentGenerationRequest} contentGenerationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationsApi
     */
    public createContentGeneration(contentGenerationRequest: ContentGenerationRequest, options?: RawAxiosRequestConfig) {
        return ContentGenerationsApiFp(this.configuration).createContentGeneration(contentGenerationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete
     * @param {number} id The Content Generation id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationsApi
     */
    public deleteContentGeneration(id: number, options?: RawAxiosRequestConfig) {
        return ContentGenerationsApiFp(this.configuration).deleteContentGeneration(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Duplicate
     * @param {number} fromContentGenerationId The Content Generation id to duplicate from.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationsApi
     */
    public duplicateContentGeneration(fromContentGenerationId: number, options?: RawAxiosRequestConfig) {
        return ContentGenerationsApiFp(this.configuration).duplicateContentGeneration(fromContentGenerationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get
     * @param {number} id The Content Generation id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationsApi
     */
    public getContentGeneration(id: number, options?: RawAxiosRequestConfig) {
        return ContentGenerationsApiFp(this.configuration).getContentGeneration(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List
     * @param {string} [cursor] The cursor
     * @param {number} [limit] The maximum number of results
     * @param {boolean} [deleted] Filter for the deleted flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationsApi
     */
    public listContentGenerations(cursor?: string, limit?: number, deleted?: boolean, options?: RawAxiosRequestConfig) {
        return ContentGenerationsApiFp(this.configuration).listContentGenerations(cursor, limit, deleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update
     * @param {number} id The Content Generation id.
     * @param {ContentGenerationRequest} contentGenerationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentGenerationsApi
     */
    public updateContentGeneration(id: number, contentGenerationRequest: ContentGenerationRequest, options?: RawAxiosRequestConfig) {
        return ContentGenerationsApiFp(this.configuration).updateContentGeneration(id, contentGenerationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomDomainsApi - axios parameter creator
 * @export
 */
export const CustomDomainsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check if the provided custom domain can be set for the account
         * @summary Validate
         * @param {DomainValidationRequest} domainValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validate: async (domainValidationRequest: DomainValidationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainValidationRequest' is not null or undefined
            assertParamExists('validate', 'domainValidationRequest', domainValidationRequest)
            const localVarPath = `/validations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainValidationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomDomainsApi - functional programming interface
 * @export
 */
export const CustomDomainsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomDomainsApiAxiosParamCreator(configuration)
    return {
        /**
         * Check if the provided custom domain can be set for the account
         * @summary Validate
         * @param {DomainValidationRequest} domainValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validate(domainValidationRequest: DomainValidationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validate(domainValidationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomDomainsApi.validate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomDomainsApi - factory interface
 * @export
 */
export const CustomDomainsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomDomainsApiFp(configuration)
    return {
        /**
         * Check if the provided custom domain can be set for the account
         * @summary Validate
         * @param {DomainValidationRequest} domainValidationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validate(domainValidationRequest: DomainValidationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.validate(domainValidationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomDomainsApi - object-oriented interface
 * @export
 * @class CustomDomainsApi
 * @extends {BaseAPI}
 */
export class CustomDomainsApi extends BaseAPI {
    /**
     * Check if the provided custom domain can be set for the account
     * @summary Validate
     * @param {DomainValidationRequest} domainValidationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomDomainsApi
     */
    public validate(domainValidationRequest: DomainValidationRequest, options?: RawAxiosRequestConfig) {
        return CustomDomainsApiFp(this.configuration).validate(domainValidationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DataURIApi - axios parameter creator
 * @export
 */
export const DataURIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The service will return a Web Data URI only for existing datasets. The Web Data URI is not guaranteed to exist (i.e. it may return 404). 
         * @summary Get the Web Data URI for a Web Page URL.
         * @param {string} u The Web Page URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataUri: async (u: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'u' is not null or undefined
            assertParamExists('getDataUri', 'u', u)
            const localVarPath = `/data-uri`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (u !== undefined) {
                localVarQueryParameter['u'] = u;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataURIApi - functional programming interface
 * @export
 */
export const DataURIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataURIApiAxiosParamCreator(configuration)
    return {
        /**
         * The service will return a Web Data URI only for existing datasets. The Web Data URI is not guaranteed to exist (i.e. it may return 404). 
         * @summary Get the Web Data URI for a Web Page URL.
         * @param {string} u The Web Page URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataUri(u: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataUri(u, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataURIApi.getDataUri']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DataURIApi - factory interface
 * @export
 */
export const DataURIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataURIApiFp(configuration)
    return {
        /**
         * The service will return a Web Data URI only for existing datasets. The Web Data URI is not guaranteed to exist (i.e. it may return 404). 
         * @summary Get the Web Data URI for a Web Page URL.
         * @param {string} u The Web Page URL.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataUri(u: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getDataUri(u, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataURIApi - object-oriented interface
 * @export
 * @class DataURIApi
 * @extends {BaseAPI}
 */
export class DataURIApi extends BaseAPI {
    /**
     * The service will return a Web Data URI only for existing datasets. The Web Data URI is not guaranteed to exist (i.e. it may return 404). 
     * @summary Get the Web Data URI for a Web Page URL.
     * @param {string} u The Web Page URL.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataURIApi
     */
    public getDataUri(u: string, options?: RawAxiosRequestConfig) {
        return DataURIApiFp(this.configuration).getDataUri(u, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DatasetApi - axios parameter creator
 * @export
 */
export const DatasetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create or update many entities in the Knowledge Graph.
         * @summary Create or update many
         * @param {Array<BatchRequest>} batchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateEntities1: async (batchRequest: Array<BatchRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchRequest' is not null or undefined
            assertParamExists('createOrUpdateEntities1', 'batchRequest', batchRequest)
            const localVarPath = `/dataset/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update an entity in the Knowledge Graph.
         * @summary Create or update one
         * @param {string} uri The entity\&#39;s URI
         * @param {string} body 
         * @param {boolean} [_private] Whether the entity should be hidden from Linked Data and GraphQL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateEntity: async (uri: string, body: string, _private?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uri' is not null or undefined
            assertParamExists('createOrUpdateEntity', 'uri', uri)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrUpdateEntity', 'body', body)
            const localVarPath = `/dataset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (uri !== undefined) {
                localVarQueryParameter['uri'] = uri;
            }

            if (_private !== undefined) {
                localVarQueryParameter['private'] = _private;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/ld+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all the entities in the Knowledge Graph.
         * @summary Delete all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllEntities: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dataset/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an entity from the Knowledge Graph.
         * @summary Delete one
         * @param {string} uri The URI of the entity to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntity: async (uri: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uri' is not null or undefined
            assertParamExists('deleteEntity', 'uri', uri)
            const localVarPath = `/dataset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (uri !== undefined) {
                localVarQueryParameter['uri'] = uri;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatasetApi - functional programming interface
 * @export
 */
export const DatasetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatasetApiAxiosParamCreator(configuration)
    return {
        /**
         * Create or update many entities in the Knowledge Graph.
         * @summary Create or update many
         * @param {Array<BatchRequest>} batchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateEntities1(batchRequest: Array<BatchRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateEntities1(batchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.createOrUpdateEntities1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update an entity in the Knowledge Graph.
         * @summary Create or update one
         * @param {string} uri The entity\&#39;s URI
         * @param {string} body 
         * @param {boolean} [_private] Whether the entity should be hidden from Linked Data and GraphQL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateEntity(uri: string, body: string, _private?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateEntity(uri, body, _private, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.createOrUpdateEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete all the entities in the Knowledge Graph.
         * @summary Delete all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllEntities(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllEntities(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.deleteAllEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an entity from the Knowledge Graph.
         * @summary Delete one
         * @param {string} uri The URI of the entity to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntity(uri: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntity(uri, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DatasetApi.deleteEntity']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DatasetApi - factory interface
 * @export
 */
export const DatasetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatasetApiFp(configuration)
    return {
        /**
         * Create or update many entities in the Knowledge Graph.
         * @summary Create or update many
         * @param {Array<BatchRequest>} batchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateEntities1(batchRequest: Array<BatchRequest>, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createOrUpdateEntities1(batchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update an entity in the Knowledge Graph.
         * @summary Create or update one
         * @param {string} uri The entity\&#39;s URI
         * @param {string} body 
         * @param {boolean} [_private] Whether the entity should be hidden from Linked Data and GraphQL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateEntity(uri: string, body: string, _private?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createOrUpdateEntity(uri, body, _private, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all the entities in the Knowledge Graph.
         * @summary Delete all
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllEntities(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAllEntities(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an entity from the Knowledge Graph.
         * @summary Delete one
         * @param {string} uri The URI of the entity to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntity(uri: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEntity(uri, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatasetApi - object-oriented interface
 * @export
 * @class DatasetApi
 * @extends {BaseAPI}
 */
export class DatasetApi extends BaseAPI {
    /**
     * Create or update many entities in the Knowledge Graph.
     * @summary Create or update many
     * @param {Array<BatchRequest>} batchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createOrUpdateEntities1(batchRequest: Array<BatchRequest>, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createOrUpdateEntities1(batchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update an entity in the Knowledge Graph.
     * @summary Create or update one
     * @param {string} uri The entity\&#39;s URI
     * @param {string} body 
     * @param {boolean} [_private] Whether the entity should be hidden from Linked Data and GraphQL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public createOrUpdateEntity(uri: string, body: string, _private?: boolean, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).createOrUpdateEntity(uri, body, _private, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete all the entities in the Knowledge Graph.
     * @summary Delete all
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public deleteAllEntities(options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).deleteAllEntities(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an entity from the Knowledge Graph.
     * @summary Delete one
     * @param {string} uri The URI of the entity to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatasetApi
     */
    public deleteEntity(uri: string, options?: RawAxiosRequestConfig) {
        return DatasetApiFp(this.configuration).deleteEntity(uri, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EmbeddingApi - axios parameter creator
 * @export
 */
export const EmbeddingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create the embedding for the IRIs for the provided query.
         * @summary Create
         * @param {KgEmbeddingRequest} kgEmbeddingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbedding: async (kgEmbeddingRequest: KgEmbeddingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'kgEmbeddingRequest' is not null or undefined
            assertParamExists('createEmbedding', 'kgEmbeddingRequest', kgEmbeddingRequest)
            const localVarPath = `/kg/embeddings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(kgEmbeddingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmbeddingApi - functional programming interface
 * @export
 */
export const EmbeddingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmbeddingApiAxiosParamCreator(configuration)
    return {
        /**
         * Create the embedding for the IRIs for the provided query.
         * @summary Create
         * @param {KgEmbeddingRequest} kgEmbeddingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmbedding(kgEmbeddingRequest: KgEmbeddingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<{ [key: string]: string; }>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmbedding(kgEmbeddingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmbeddingApi.createEmbedding']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EmbeddingApi - factory interface
 * @export
 */
export const EmbeddingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmbeddingApiFp(configuration)
    return {
        /**
         * Create the embedding for the IRIs for the provided query.
         * @summary Create
         * @param {KgEmbeddingRequest} kgEmbeddingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbedding(kgEmbeddingRequest: KgEmbeddingRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<{ [key: string]: string; }>> {
            return localVarFp.createEmbedding(kgEmbeddingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmbeddingApi - object-oriented interface
 * @export
 * @class EmbeddingApi
 * @extends {BaseAPI}
 */
export class EmbeddingApi extends BaseAPI {
    /**
     * Create the embedding for the IRIs for the provided query.
     * @summary Create
     * @param {KgEmbeddingRequest} kgEmbeddingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddingApi
     */
    public createEmbedding(kgEmbeddingRequest: KgEmbeddingRequest, options?: RawAxiosRequestConfig) {
        return EmbeddingApiFp(this.configuration).createEmbedding(kgEmbeddingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EmbeddingsApi - axios parameter creator
 * @export
 */
export const EmbeddingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create Embeddings
         * @summary Create Embeddings
         * @param {CreateEmbeddingsInput} createEmbeddingsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddings: async (createEmbeddingsInput: CreateEmbeddingsInput, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createEmbeddingsInput' is not null or undefined
            assertParamExists('createEmbeddings', 'createEmbeddingsInput', createEmbeddingsInput)
            const localVarPath = `/api/embeddings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createEmbeddingsInput, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmbeddingsApi - functional programming interface
 * @export
 */
export const EmbeddingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmbeddingsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create Embeddings
         * @summary Create Embeddings
         * @param {CreateEmbeddingsInput} createEmbeddingsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmbeddings(createEmbeddingsInput: CreateEmbeddingsInput, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmbeddings(createEmbeddingsInput, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmbeddingsApi.createEmbeddings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EmbeddingsApi - factory interface
 * @export
 */
export const EmbeddingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmbeddingsApiFp(configuration)
    return {
        /**
         * Create Embeddings
         * @summary Create Embeddings
         * @param {CreateEmbeddingsInput} createEmbeddingsInput 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmbeddings(createEmbeddingsInput: CreateEmbeddingsInput, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createEmbeddings(createEmbeddingsInput, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmbeddingsApi - object-oriented interface
 * @export
 * @class EmbeddingsApi
 * @extends {BaseAPI}
 */
export class EmbeddingsApi extends BaseAPI {
    /**
     * Create Embeddings
     * @summary Create Embeddings
     * @param {CreateEmbeddingsInput} createEmbeddingsInput 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmbeddingsApi
     */
    public createEmbeddings(createEmbeddingsInput: CreateEmbeddingsInput, options?: RawAxiosRequestConfig) {
        return EmbeddingsApiFp(this.configuration).createEmbeddings(createEmbeddingsInput, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EntitiesApi - axios parameter creator
 * @export
 */
export const EntitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create new entities by automatically generating their id.
         * @summary Create
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntities: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createEntities', 'body', body)
            const localVarPath = `/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/ld+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create or update entities by using the provided ids.
         * @summary Update (or create)
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateEntities: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('createOrUpdateEntities', 'body', body)
            const localVarPath = `/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/ld+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete entities with the provided ids.
         * @summary Delete
         * @param {Set<string>} id One or more ids, in the form of URLs.
         * @param {string} [includeChildren] Whether to delete all the entities whose ids start with the provided ids, by default false.
         * @param {string} [includeReferenced] Whether to delete all the referenced entities (e.g. in &#x60;schema:mentions&#x60;), by default false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntities: async (id: Set<string>, includeChildren?: string, includeReferenced?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEntities', 'id', id)
            const localVarPath = `/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id) {
                localVarQueryParameter['id'] = Array.from(id);
            }

            if (includeChildren !== undefined) {
                localVarQueryParameter['include_children'] = includeChildren;
            }

            if (includeReferenced !== undefined) {
                localVarQueryParameter['include_referenced'] = includeReferenced;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get entities with the provided ids.
         * @summary Get
         * @param {Set<string>} id One or more ids, in the form of URLs.
         * @param {string} [includeChildren] Whether to return all the entities whose ids start with the provided ids, by default false.
         * @param {string} [includeReferenced] Whether to return all the referenced entities (e.g. in &#x60;schema:mentions&#x60;), by default false.
         * @param {string} [includePrivate] Whether to return private properties, requires an authenticated request, by default false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntities: async (id: Set<string>, includeChildren?: string, includeReferenced?: string, includePrivate?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEntities', 'id', id)
            const localVarPath = `/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id) {
                localVarQueryParameter['id'] = Array.from(id);
            }

            if (includeChildren !== undefined) {
                localVarQueryParameter['include_children'] = includeChildren;
            }

            if (includeReferenced !== undefined) {
                localVarQueryParameter['include_referenced'] = includeReferenced;
            }

            if (includePrivate !== undefined) {
                localVarQueryParameter['include_private'] = includePrivate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Patch entity
         * @summary Patch Entity
         * @param {string} id Entity id.
         * @param {Array<EntityPatchRequest>} entityPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntities: async (id: string, entityPatchRequest: Array<EntityPatchRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('patchEntities', 'id', id)
            // verify required parameter 'entityPatchRequest' is not null or undefined
            assertParamExists('patchEntities', 'entityPatchRequest', entityPatchRequest)
            const localVarPath = `/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntitiesApi - functional programming interface
 * @export
 */
export const EntitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create new entities by automatically generating their id.
         * @summary Create
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntities(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntities(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntitiesApi.createEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create or update entities by using the provided ids.
         * @summary Update (or create)
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateEntities(body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateEntities(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntitiesApi.createOrUpdateEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete entities with the provided ids.
         * @summary Delete
         * @param {Set<string>} id One or more ids, in the form of URLs.
         * @param {string} [includeChildren] Whether to delete all the entities whose ids start with the provided ids, by default false.
         * @param {string} [includeReferenced] Whether to delete all the referenced entities (e.g. in &#x60;schema:mentions&#x60;), by default false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntities(id: Set<string>, includeChildren?: string, includeReferenced?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntities(id, includeChildren, includeReferenced, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntitiesApi.deleteEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get entities with the provided ids.
         * @summary Get
         * @param {Set<string>} id One or more ids, in the form of URLs.
         * @param {string} [includeChildren] Whether to return all the entities whose ids start with the provided ids, by default false.
         * @param {string} [includeReferenced] Whether to return all the referenced entities (e.g. in &#x60;schema:mentions&#x60;), by default false.
         * @param {string} [includePrivate] Whether to return private properties, requires an authenticated request, by default false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEntities(id: Set<string>, includeChildren?: string, includeReferenced?: string, includePrivate?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEntities(id, includeChildren, includeReferenced, includePrivate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntitiesApi.getEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Patch entity
         * @summary Patch Entity
         * @param {string} id Entity id.
         * @param {Array<EntityPatchRequest>} entityPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchEntities(id: string, entityPatchRequest: Array<EntityPatchRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchEntities(id, entityPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntitiesApi.patchEntities']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EntitiesApi - factory interface
 * @export
 */
export const EntitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntitiesApiFp(configuration)
    return {
        /**
         * Create new entities by automatically generating their id.
         * @summary Create
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntities(body: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createEntities(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create or update entities by using the provided ids.
         * @summary Update (or create)
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateEntities(body: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createOrUpdateEntities(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete entities with the provided ids.
         * @summary Delete
         * @param {Set<string>} id One or more ids, in the form of URLs.
         * @param {string} [includeChildren] Whether to delete all the entities whose ids start with the provided ids, by default false.
         * @param {string} [includeReferenced] Whether to delete all the referenced entities (e.g. in &#x60;schema:mentions&#x60;), by default false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntities(id: Set<string>, includeChildren?: string, includeReferenced?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteEntities(id, includeChildren, includeReferenced, options).then((request) => request(axios, basePath));
        },
        /**
         * Get entities with the provided ids.
         * @summary Get
         * @param {Set<string>} id One or more ids, in the form of URLs.
         * @param {string} [includeChildren] Whether to return all the entities whose ids start with the provided ids, by default false.
         * @param {string} [includeReferenced] Whether to return all the referenced entities (e.g. in &#x60;schema:mentions&#x60;), by default false.
         * @param {string} [includePrivate] Whether to return private properties, requires an authenticated request, by default false.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntities(id: Set<string>, includeChildren?: string, includeReferenced?: string, includePrivate?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getEntities(id, includeChildren, includeReferenced, includePrivate, options).then((request) => request(axios, basePath));
        },
        /**
         * Patch entity
         * @summary Patch Entity
         * @param {string} id Entity id.
         * @param {Array<EntityPatchRequest>} entityPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchEntities(id: string, entityPatchRequest: Array<EntityPatchRequest>, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.patchEntities(id, entityPatchRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntitiesApi - object-oriented interface
 * @export
 * @class EntitiesApi
 * @extends {BaseAPI}
 */
export class EntitiesApi extends BaseAPI {
    /**
     * Create new entities by automatically generating their id.
     * @summary Create
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public createEntities(body: string, options?: RawAxiosRequestConfig) {
        return EntitiesApiFp(this.configuration).createEntities(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create or update entities by using the provided ids.
     * @summary Update (or create)
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public createOrUpdateEntities(body: string, options?: RawAxiosRequestConfig) {
        return EntitiesApiFp(this.configuration).createOrUpdateEntities(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete entities with the provided ids.
     * @summary Delete
     * @param {Set<string>} id One or more ids, in the form of URLs.
     * @param {string} [includeChildren] Whether to delete all the entities whose ids start with the provided ids, by default false.
     * @param {string} [includeReferenced] Whether to delete all the referenced entities (e.g. in &#x60;schema:mentions&#x60;), by default false.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public deleteEntities(id: Set<string>, includeChildren?: string, includeReferenced?: string, options?: RawAxiosRequestConfig) {
        return EntitiesApiFp(this.configuration).deleteEntities(id, includeChildren, includeReferenced, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get entities with the provided ids.
     * @summary Get
     * @param {Set<string>} id One or more ids, in the form of URLs.
     * @param {string} [includeChildren] Whether to return all the entities whose ids start with the provided ids, by default false.
     * @param {string} [includeReferenced] Whether to return all the referenced entities (e.g. in &#x60;schema:mentions&#x60;), by default false.
     * @param {string} [includePrivate] Whether to return private properties, requires an authenticated request, by default false.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public getEntities(id: Set<string>, includeChildren?: string, includeReferenced?: string, includePrivate?: string, options?: RawAxiosRequestConfig) {
        return EntitiesApiFp(this.configuration).getEntities(id, includeChildren, includeReferenced, includePrivate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Patch entity
     * @summary Patch Entity
     * @param {string} id Entity id.
     * @param {Array<EntityPatchRequest>} entityPatchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntitiesApi
     */
    public patchEntities(id: string, entityPatchRequest: Array<EntityPatchRequest>, options?: RawAxiosRequestConfig) {
        return EntitiesApiFp(this.configuration).patchEntities(id, entityPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EntityGapsApi - axios parameter creator
 * @export
 */
export const EntityGapsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an Entity Gaps analysis.
         * @summary Create
         * @param {EntityGapRequest} entityGapRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityGap: async (entityGapRequest: EntityGapRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityGapRequest' is not null or undefined
            assertParamExists('createEntityGap', 'entityGapRequest', entityGapRequest)
            const localVarPath = `/entity-gaps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityGapRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntityGapsApi - functional programming interface
 * @export
 */
export const EntityGapsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EntityGapsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an Entity Gaps analysis.
         * @summary Create
         * @param {EntityGapRequest} entityGapRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEntityGap(entityGapRequest: EntityGapRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnalysesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEntityGap(entityGapRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EntityGapsApi.createEntityGap']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EntityGapsApi - factory interface
 * @export
 */
export const EntityGapsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EntityGapsApiFp(configuration)
    return {
        /**
         * Create an Entity Gaps analysis.
         * @summary Create
         * @param {EntityGapRequest} entityGapRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEntityGap(entityGapRequest: EntityGapRequest, options?: RawAxiosRequestConfig): AxiosPromise<AnalysesResponse> {
            return localVarFp.createEntityGap(entityGapRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EntityGapsApi - object-oriented interface
 * @export
 * @class EntityGapsApi
 * @extends {BaseAPI}
 */
export class EntityGapsApi extends BaseAPI {
    /**
     * Create an Entity Gaps analysis.
     * @summary Create
     * @param {EntityGapRequest} entityGapRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntityGapsApi
     */
    public createEntityGap(entityGapRequest: EntityGapRequest, options?: RawAxiosRequestConfig) {
        return EntityGapsApiFp(this.configuration).createEntityGap(entityGapRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FactCheckApi - axios parameter creator
 * @export
 */
export const FactCheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Submit a fact-checking request
         * @param {SubmitFactCheckRequest} submitFactCheckRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFactCheck: async (submitFactCheckRequest: SubmitFactCheckRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'submitFactCheckRequest' is not null or undefined
            assertParamExists('submitFactCheck', 'submitFactCheckRequest', submitFactCheckRequest)
            const localVarPath = `/fact-check/score`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(submitFactCheckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FactCheckApi - functional programming interface
 * @export
 */
export const FactCheckApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FactCheckApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Submit a fact-checking request
         * @param {SubmitFactCheckRequest} submitFactCheckRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitFactCheck(submitFactCheckRequest: SubmitFactCheckRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmitFactCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitFactCheck(submitFactCheckRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FactCheckApi.submitFactCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FactCheckApi - factory interface
 * @export
 */
export const FactCheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FactCheckApiFp(configuration)
    return {
        /**
         * 
         * @summary Submit a fact-checking request
         * @param {SubmitFactCheckRequest} submitFactCheckRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFactCheck(submitFactCheckRequest: SubmitFactCheckRequest, options?: RawAxiosRequestConfig): AxiosPromise<SubmitFactCheck200Response> {
            return localVarFp.submitFactCheck(submitFactCheckRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FactCheckApi - object-oriented interface
 * @export
 * @class FactCheckApi
 * @extends {BaseAPI}
 */
export class FactCheckApi extends BaseAPI {
    /**
     * 
     * @summary Submit a fact-checking request
     * @param {SubmitFactCheckRequest} submitFactCheckRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactCheckApi
     */
    public submitFactCheck(submitFactCheckRequest: SubmitFactCheckRequest, options?: RawAxiosRequestConfig) {
        return FactCheckApiFp(this.configuration).submitFactCheck(submitFactCheckRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GoogleMerchantsApi - axios parameter creator
 * @export
 */
export const GoogleMerchantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List the Google Merchants
         * @summary List
         * @param {string} googleAccessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoogleMerchants: async (googleAccessToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'googleAccessToken' is not null or undefined
            assertParamExists('listGoogleMerchants', 'googleAccessToken', googleAccessToken)
            const localVarPath = `/ext/google/shopping/merchants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (googleAccessToken !== undefined) {
                localVarQueryParameter['google_access_token'] = googleAccessToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoogleMerchantsApi - functional programming interface
 * @export
 */
export const GoogleMerchantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GoogleMerchantsApiAxiosParamCreator(configuration)
    return {
        /**
         * List the Google Merchants
         * @summary List
         * @param {string} googleAccessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGoogleMerchants(googleAccessToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageMerchantEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGoogleMerchants(googleAccessToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleMerchantsApi.listGoogleMerchants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GoogleMerchantsApi - factory interface
 * @export
 */
export const GoogleMerchantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoogleMerchantsApiFp(configuration)
    return {
        /**
         * List the Google Merchants
         * @summary List
         * @param {string} googleAccessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGoogleMerchants(googleAccessToken: string, options?: RawAxiosRequestConfig): AxiosPromise<PageMerchantEntry> {
            return localVarFp.listGoogleMerchants(googleAccessToken, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GoogleMerchantsApi - object-oriented interface
 * @export
 * @class GoogleMerchantsApi
 * @extends {BaseAPI}
 */
export class GoogleMerchantsApi extends BaseAPI {
    /**
     * List the Google Merchants
     * @summary List
     * @param {string} googleAccessToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleMerchantsApi
     */
    public listGoogleMerchants(googleAccessToken: string, options?: RawAxiosRequestConfig) {
        return GoogleMerchantsApiFp(this.configuration).listGoogleMerchants(googleAccessToken, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GoogleSearchConsoleApi - axios parameter creator
 * @export
 */
export const GoogleSearchConsoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List the Website Search performance data
         * @summary List Website Search data
         * @param {string} website The website URL
         * @param {string} since The start date, inclusive, in yyyy-MM-dd format.
         * @param {string} until The end date, inclusive, in yyyy-MM-dd format.
         * @param {Array<string>} dimensions The dimensions, e.g. &#x60;query&#x60;, &#x60;page&#x60;. Must repeat for each dimension.
         * @param {string} googleAccessToken The Google access token, must have access to the Google Search Console scope
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebsiteSearch: async (website: string, since: string, until: string, dimensions: Array<string>, googleAccessToken: string, cursor?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'website' is not null or undefined
            assertParamExists('listWebsiteSearch', 'website', website)
            // verify required parameter 'since' is not null or undefined
            assertParamExists('listWebsiteSearch', 'since', since)
            // verify required parameter 'until' is not null or undefined
            assertParamExists('listWebsiteSearch', 'until', until)
            // verify required parameter 'dimensions' is not null or undefined
            assertParamExists('listWebsiteSearch', 'dimensions', dimensions)
            // verify required parameter 'googleAccessToken' is not null or undefined
            assertParamExists('listWebsiteSearch', 'googleAccessToken', googleAccessToken)
            const localVarPath = `/ext/google/searchconsole/searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (website !== undefined) {
                localVarQueryParameter['website'] = website;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = until;
            }

            if (dimensions) {
                localVarQueryParameter['dimensions'] = dimensions;
            }

            if (googleAccessToken !== undefined) {
                localVarQueryParameter['google_access_token'] = googleAccessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Websites
         * @summary List
         * @param {string} googleAccessToken The Google access token, must have access to the Google Search Console scope
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebsites: async (googleAccessToken: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'googleAccessToken' is not null or undefined
            assertParamExists('listWebsites', 'googleAccessToken', googleAccessToken)
            const localVarPath = `/ext/google/searchconsole/websites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (googleAccessToken !== undefined) {
                localVarQueryParameter['google_access_token'] = googleAccessToken;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoogleSearchConsoleApi - functional programming interface
 * @export
 */
export const GoogleSearchConsoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GoogleSearchConsoleApiAxiosParamCreator(configuration)
    return {
        /**
         * List the Website Search performance data
         * @summary List Website Search data
         * @param {string} website The website URL
         * @param {string} since The start date, inclusive, in yyyy-MM-dd format.
         * @param {string} until The end date, inclusive, in yyyy-MM-dd format.
         * @param {Array<string>} dimensions The dimensions, e.g. &#x60;query&#x60;, &#x60;page&#x60;. Must repeat for each dimension.
         * @param {string} googleAccessToken The Google access token, must have access to the Google Search Console scope
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebsiteSearch(website: string, since: string, until: string, dimensions: Array<string>, googleAccessToken: string, cursor?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageWebsiteSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebsiteSearch(website, since, until, dimensions, googleAccessToken, cursor, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleSearchConsoleApi.listWebsiteSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the Websites
         * @summary List
         * @param {string} googleAccessToken The Google access token, must have access to the Google Search Console scope
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebsites(googleAccessToken: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageWebsite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebsites(googleAccessToken, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleSearchConsoleApi.listWebsites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GoogleSearchConsoleApi - factory interface
 * @export
 */
export const GoogleSearchConsoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoogleSearchConsoleApiFp(configuration)
    return {
        /**
         * List the Website Search performance data
         * @summary List Website Search data
         * @param {string} website The website URL
         * @param {string} since The start date, inclusive, in yyyy-MM-dd format.
         * @param {string} until The end date, inclusive, in yyyy-MM-dd format.
         * @param {Array<string>} dimensions The dimensions, e.g. &#x60;query&#x60;, &#x60;page&#x60;. Must repeat for each dimension.
         * @param {string} googleAccessToken The Google access token, must have access to the Google Search Console scope
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebsiteSearch(website: string, since: string, until: string, dimensions: Array<string>, googleAccessToken: string, cursor?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageWebsiteSearch> {
            return localVarFp.listWebsiteSearch(website, since, until, dimensions, googleAccessToken, cursor, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Websites
         * @summary List
         * @param {string} googleAccessToken The Google access token, must have access to the Google Search Console scope
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebsites(googleAccessToken: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageWebsite> {
            return localVarFp.listWebsites(googleAccessToken, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GoogleSearchConsoleApi - object-oriented interface
 * @export
 * @class GoogleSearchConsoleApi
 * @extends {BaseAPI}
 */
export class GoogleSearchConsoleApi extends BaseAPI {
    /**
     * List the Website Search performance data
     * @summary List Website Search data
     * @param {string} website The website URL
     * @param {string} since The start date, inclusive, in yyyy-MM-dd format.
     * @param {string} until The end date, inclusive, in yyyy-MM-dd format.
     * @param {Array<string>} dimensions The dimensions, e.g. &#x60;query&#x60;, &#x60;page&#x60;. Must repeat for each dimension.
     * @param {string} googleAccessToken The Google access token, must have access to the Google Search Console scope
     * @param {string} [cursor] The cursor
     * @param {number} [limit] The maximum number of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleSearchConsoleApi
     */
    public listWebsiteSearch(website: string, since: string, until: string, dimensions: Array<string>, googleAccessToken: string, cursor?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return GoogleSearchConsoleApiFp(this.configuration).listWebsiteSearch(website, since, until, dimensions, googleAccessToken, cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Websites
     * @summary List
     * @param {string} googleAccessToken The Google access token, must have access to the Google Search Console scope
     * @param {number} [limit] The maximum number of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleSearchConsoleApi
     */
    public listWebsites(googleAccessToken: string, limit?: number, options?: RawAxiosRequestConfig) {
        return GoogleSearchConsoleApiFp(this.configuration).listWebsites(googleAccessToken, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GoogleSearchConsoleOAuth2Api - axios parameter creator
 * @export
 */
export const GoogleSearchConsoleOAuth2ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Call this API to have the Platform receive an Authentication Token to access the Analytics data via Google Search Console.
         * @summary Get an Access Code
         * @param {ExchangeAuthCodeRequest} exchangeAuthCodeRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createAuthCodeExchange: async (exchangeAuthCodeRequest: ExchangeAuthCodeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exchangeAuthCodeRequest' is not null or undefined
            assertParamExists('createAuthCodeExchange', 'exchangeAuthCodeRequest', exchangeAuthCodeRequest)
            const localVarPath = `/google-search-console/oauth2/auth-code-exchanges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exchangeAuthCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Call this API to get an authorization URI needed to interactively get an authorization token. Then call the `exchangeAuthCode` to exchange it with an authorization token.
         * @summary Create an Authorization URI
         * @param {BuildAuthorizeUriRequest} buildAuthorizeUriRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createAuthorizeUri: async (buildAuthorizeUriRequest: BuildAuthorizeUriRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'buildAuthorizeUriRequest' is not null or undefined
            assertParamExists('createAuthorizeUri', 'buildAuthorizeUriRequest', buildAuthorizeUriRequest)
            const localVarPath = `/google-search-console/oauth2/authorize-uris`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(buildAuthorizeUriRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the authorizations of the authenticated user.
         * @summary Delete an authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthorization: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/google-search-console/authorization`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Call this API to duplicate an existing google search console connection to another accounts.
         * @summary Duplicate the Google Search Console connection through accounts
         * @param {DuplicateAuthorizationRequest} duplicateAuthorizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicate: async (duplicateAuthorizationRequest: DuplicateAuthorizationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'duplicateAuthorizationRequest' is not null or undefined
            assertParamExists('duplicate', 'duplicateAuthorizationRequest', duplicateAuthorizationRequest)
            const localVarPath = `/google-search-console/authorize/duplicate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(duplicateAuthorizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the authorizations of the authenticated user.
         * @summary Get the authorizations
         * @param {Array<string>} [accountKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizations: async (accountKey?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/google-search-console/authorizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (accountKey) {
                localVarQueryParameter['account_key'] = accountKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Call this API to go to the login page of the Google Search Console.
         * @summary Login to the Google Search Console API client
         * @param {string} accountKey The account key
         * @param {string} redirectUri The redirect URI to redirect to after the login
         * @param {string} [state] The state to maintain after authorize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (accountKey: string, redirectUri: string, state?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountKey' is not null or undefined
            assertParamExists('login', 'accountKey', accountKey)
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('login', 'redirectUri', redirectUri)
            const localVarPath = `/google-search-console/authorize/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (accountKey !== undefined) {
                localVarQueryParameter['accountKey'] = accountKey;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirectUri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoogleSearchConsoleOAuth2Api - functional programming interface
 * @export
 */
export const GoogleSearchConsoleOAuth2ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GoogleSearchConsoleOAuth2ApiAxiosParamCreator(configuration)
    return {
        /**
         * Call this API to have the Platform receive an Authentication Token to access the Analytics data via Google Search Console.
         * @summary Get an Access Code
         * @param {ExchangeAuthCodeRequest} exchangeAuthCodeRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createAuthCodeExchange(exchangeAuthCodeRequest: ExchangeAuthCodeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeAuthCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthCodeExchange(exchangeAuthCodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleSearchConsoleOAuth2Api.createAuthCodeExchange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Call this API to get an authorization URI needed to interactively get an authorization token. Then call the `exchangeAuthCode` to exchange it with an authorization token.
         * @summary Create an Authorization URI
         * @param {BuildAuthorizeUriRequest} buildAuthorizeUriRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async createAuthorizeUri(buildAuthorizeUriRequest: BuildAuthorizeUriRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BuildAuthorizeUriResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthorizeUri(buildAuthorizeUriRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleSearchConsoleOAuth2Api.createAuthorizeUri']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the authorizations of the authenticated user.
         * @summary Delete an authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAuthorization(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAuthorization(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleSearchConsoleOAuth2Api.deleteAuthorization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Call this API to duplicate an existing google search console connection to another accounts.
         * @summary Duplicate the Google Search Console connection through accounts
         * @param {DuplicateAuthorizationRequest} duplicateAuthorizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async duplicate(duplicateAuthorizationRequest: DuplicateAuthorizationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.duplicate(duplicateAuthorizationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleSearchConsoleOAuth2Api.duplicate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the authorizations of the authenticated user.
         * @summary Get the authorizations
         * @param {Array<string>} [accountKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthorizations(accountKey?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Authorization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthorizations(accountKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleSearchConsoleOAuth2Api.getAuthorizations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Call this API to go to the login page of the Google Search Console.
         * @summary Login to the Google Search Console API client
         * @param {string} accountKey The account key
         * @param {string} redirectUri The redirect URI to redirect to after the login
         * @param {string} [state] The state to maintain after authorize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(accountKey: string, redirectUri: string, state?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(accountKey, redirectUri, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleSearchConsoleOAuth2Api.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GoogleSearchConsoleOAuth2Api - factory interface
 * @export
 */
export const GoogleSearchConsoleOAuth2ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoogleSearchConsoleOAuth2ApiFp(configuration)
    return {
        /**
         * Call this API to have the Platform receive an Authentication Token to access the Analytics data via Google Search Console.
         * @summary Get an Access Code
         * @param {ExchangeAuthCodeRequest} exchangeAuthCodeRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createAuthCodeExchange(exchangeAuthCodeRequest: ExchangeAuthCodeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExchangeAuthCodeResponse> {
            return localVarFp.createAuthCodeExchange(exchangeAuthCodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Call this API to get an authorization URI needed to interactively get an authorization token. Then call the `exchangeAuthCode` to exchange it with an authorization token.
         * @summary Create an Authorization URI
         * @param {BuildAuthorizeUriRequest} buildAuthorizeUriRequest 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        createAuthorizeUri(buildAuthorizeUriRequest: BuildAuthorizeUriRequest, options?: RawAxiosRequestConfig): AxiosPromise<BuildAuthorizeUriResponse> {
            return localVarFp.createAuthorizeUri(buildAuthorizeUriRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the authorizations of the authenticated user.
         * @summary Delete an authorization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAuthorization(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAuthorization(options).then((request) => request(axios, basePath));
        },
        /**
         * Call this API to duplicate an existing google search console connection to another accounts.
         * @summary Duplicate the Google Search Console connection through accounts
         * @param {DuplicateAuthorizationRequest} duplicateAuthorizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicate(duplicateAuthorizationRequest: DuplicateAuthorizationRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.duplicate(duplicateAuthorizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the authorizations of the authenticated user.
         * @summary Get the authorizations
         * @param {Array<string>} [accountKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthorizations(accountKey?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<Authorization>> {
            return localVarFp.getAuthorizations(accountKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Call this API to go to the login page of the Google Search Console.
         * @summary Login to the Google Search Console API client
         * @param {string} accountKey The account key
         * @param {string} redirectUri The redirect URI to redirect to after the login
         * @param {string} [state] The state to maintain after authorize.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(accountKey: string, redirectUri: string, state?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.login(accountKey, redirectUri, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GoogleSearchConsoleOAuth2Api - object-oriented interface
 * @export
 * @class GoogleSearchConsoleOAuth2Api
 * @extends {BaseAPI}
 */
export class GoogleSearchConsoleOAuth2Api extends BaseAPI {
    /**
     * Call this API to have the Platform receive an Authentication Token to access the Analytics data via Google Search Console.
     * @summary Get an Access Code
     * @param {ExchangeAuthCodeRequest} exchangeAuthCodeRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GoogleSearchConsoleOAuth2Api
     */
    public createAuthCodeExchange(exchangeAuthCodeRequest: ExchangeAuthCodeRequest, options?: RawAxiosRequestConfig) {
        return GoogleSearchConsoleOAuth2ApiFp(this.configuration).createAuthCodeExchange(exchangeAuthCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Call this API to get an authorization URI needed to interactively get an authorization token. Then call the `exchangeAuthCode` to exchange it with an authorization token.
     * @summary Create an Authorization URI
     * @param {BuildAuthorizeUriRequest} buildAuthorizeUriRequest 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GoogleSearchConsoleOAuth2Api
     */
    public createAuthorizeUri(buildAuthorizeUriRequest: BuildAuthorizeUriRequest, options?: RawAxiosRequestConfig) {
        return GoogleSearchConsoleOAuth2ApiFp(this.configuration).createAuthorizeUri(buildAuthorizeUriRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the authorizations of the authenticated user.
     * @summary Delete an authorization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleSearchConsoleOAuth2Api
     */
    public deleteAuthorization(options?: RawAxiosRequestConfig) {
        return GoogleSearchConsoleOAuth2ApiFp(this.configuration).deleteAuthorization(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Call this API to duplicate an existing google search console connection to another accounts.
     * @summary Duplicate the Google Search Console connection through accounts
     * @param {DuplicateAuthorizationRequest} duplicateAuthorizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleSearchConsoleOAuth2Api
     */
    public duplicate(duplicateAuthorizationRequest: DuplicateAuthorizationRequest, options?: RawAxiosRequestConfig) {
        return GoogleSearchConsoleOAuth2ApiFp(this.configuration).duplicate(duplicateAuthorizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the authorizations of the authenticated user.
     * @summary Get the authorizations
     * @param {Array<string>} [accountKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleSearchConsoleOAuth2Api
     */
    public getAuthorizations(accountKey?: Array<string>, options?: RawAxiosRequestConfig) {
        return GoogleSearchConsoleOAuth2ApiFp(this.configuration).getAuthorizations(accountKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Call this API to go to the login page of the Google Search Console.
     * @summary Login to the Google Search Console API client
     * @param {string} accountKey The account key
     * @param {string} redirectUri The redirect URI to redirect to after the login
     * @param {string} [state] The state to maintain after authorize.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleSearchConsoleOAuth2Api
     */
    public login(accountKey: string, redirectUri: string, state?: string, options?: RawAxiosRequestConfig) {
        return GoogleSearchConsoleOAuth2ApiFp(this.configuration).login(accountKey, redirectUri, state, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GoogleSearchConsoleSearchesApi - axios parameter creator
 * @export
 */
export const GoogleSearchConsoleSearchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List the Website Search performance data
         * @summary List Website Search data
         * @param {string} since The start date, inclusive, in yyyy-MM-dd format.
         * @param {string} until The end date, inclusive, in yyyy-MM-dd format.
         * @param {Array<string>} dimensions The dimensions, e.g. &#x60;query&#x60;, &#x60;page&#x60;. Must repeat for each dimension.
         * @param {string} [cursor] The cursor
         * @param {ListWebsiteSearch1DataStateEnum} [dataState] If \&quot;all\&quot; (case-insensitive), data will include fresh data. If \&quot;final\&quot; (case-insensitive) or if this parameter is omitted, the returned data will include only finalized data.
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebsiteSearch1: async (since: string, until: string, dimensions: Array<string>, cursor?: string, dataState?: ListWebsiteSearch1DataStateEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'since' is not null or undefined
            assertParamExists('listWebsiteSearch1', 'since', since)
            // verify required parameter 'until' is not null or undefined
            assertParamExists('listWebsiteSearch1', 'until', until)
            // verify required parameter 'dimensions' is not null or undefined
            assertParamExists('listWebsiteSearch1', 'dimensions', dimensions)
            const localVarPath = `/accounts/me/google/searches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = until;
            }

            if (dimensions) {
                localVarQueryParameter['dimensions'] = dimensions;
            }

            if (dataState !== undefined) {
                localVarQueryParameter['data_state'] = dataState;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoogleSearchConsoleSearchesApi - functional programming interface
 * @export
 */
export const GoogleSearchConsoleSearchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GoogleSearchConsoleSearchesApiAxiosParamCreator(configuration)
    return {
        /**
         * List the Website Search performance data
         * @summary List Website Search data
         * @param {string} since The start date, inclusive, in yyyy-MM-dd format.
         * @param {string} until The end date, inclusive, in yyyy-MM-dd format.
         * @param {Array<string>} dimensions The dimensions, e.g. &#x60;query&#x60;, &#x60;page&#x60;. Must repeat for each dimension.
         * @param {string} [cursor] The cursor
         * @param {ListWebsiteSearch1DataStateEnum} [dataState] If \&quot;all\&quot; (case-insensitive), data will include fresh data. If \&quot;final\&quot; (case-insensitive) or if this parameter is omitted, the returned data will include only finalized data.
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listWebsiteSearch1(since: string, until: string, dimensions: Array<string>, cursor?: string, dataState?: ListWebsiteSearch1DataStateEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageWebsiteSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebsiteSearch1(since, until, dimensions, cursor, dataState, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GoogleSearchConsoleSearchesApi.listWebsiteSearch1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GoogleSearchConsoleSearchesApi - factory interface
 * @export
 */
export const GoogleSearchConsoleSearchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GoogleSearchConsoleSearchesApiFp(configuration)
    return {
        /**
         * List the Website Search performance data
         * @summary List Website Search data
         * @param {string} since The start date, inclusive, in yyyy-MM-dd format.
         * @param {string} until The end date, inclusive, in yyyy-MM-dd format.
         * @param {Array<string>} dimensions The dimensions, e.g. &#x60;query&#x60;, &#x60;page&#x60;. Must repeat for each dimension.
         * @param {string} [cursor] The cursor
         * @param {ListWebsiteSearch1DataStateEnum} [dataState] If \&quot;all\&quot; (case-insensitive), data will include fresh data. If \&quot;final\&quot; (case-insensitive) or if this parameter is omitted, the returned data will include only finalized data.
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWebsiteSearch1(since: string, until: string, dimensions: Array<string>, cursor?: string, dataState?: ListWebsiteSearch1DataStateEnum, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageWebsiteSearch> {
            return localVarFp.listWebsiteSearch1(since, until, dimensions, cursor, dataState, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GoogleSearchConsoleSearchesApi - object-oriented interface
 * @export
 * @class GoogleSearchConsoleSearchesApi
 * @extends {BaseAPI}
 */
export class GoogleSearchConsoleSearchesApi extends BaseAPI {
    /**
     * List the Website Search performance data
     * @summary List Website Search data
     * @param {string} since The start date, inclusive, in yyyy-MM-dd format.
     * @param {string} until The end date, inclusive, in yyyy-MM-dd format.
     * @param {Array<string>} dimensions The dimensions, e.g. &#x60;query&#x60;, &#x60;page&#x60;. Must repeat for each dimension.
     * @param {string} [cursor] The cursor
     * @param {ListWebsiteSearch1DataStateEnum} [dataState] If \&quot;all\&quot; (case-insensitive), data will include fresh data. If \&quot;final\&quot; (case-insensitive) or if this parameter is omitted, the returned data will include only finalized data.
     * @param {number} [limit] The maximum number of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleSearchConsoleSearchesApi
     */
    public listWebsiteSearch1(since: string, until: string, dimensions: Array<string>, cursor?: string, dataState?: ListWebsiteSearch1DataStateEnum, limit?: number, options?: RawAxiosRequestConfig) {
        return GoogleSearchConsoleSearchesApiFp(this.configuration).listWebsiteSearch1(since, until, dimensions, cursor, dataState, limit, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListWebsiteSearch1DataStateEnum = {
    All: 'all',
    Final: 'final'
} as const;
export type ListWebsiteSearch1DataStateEnum = typeof ListWebsiteSearch1DataStateEnum[keyof typeof ListWebsiteSearch1DataStateEnum];


/**
 * GraphQLApi - axios parameter creator
 * @export
 */
export const GraphQLApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Query
         * @param {GraphqlRequest} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        graphqlUsingPost: async (body: GraphqlRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('graphqlUsingPost', 'body', body)
            const localVarPath = `/graphql`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphQLApi - functional programming interface
 * @export
 */
export const GraphQLApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GraphQLApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Query
         * @param {GraphqlRequest} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async graphqlUsingPost(body: GraphqlRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.graphqlUsingPost(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GraphQLApi.graphqlUsingPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GraphQLApi - factory interface
 * @export
 */
export const GraphQLApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GraphQLApiFp(configuration)
    return {
        /**
         * 
         * @summary Query
         * @param {GraphqlRequest} body body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        graphqlUsingPost(body: GraphqlRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.graphqlUsingPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GraphQLApi - object-oriented interface
 * @export
 * @class GraphQLApi
 * @extends {BaseAPI}
 */
export class GraphQLApi extends BaseAPI {
    /**
     * 
     * @summary Query
     * @param {GraphqlRequest} body body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphQLApi
     */
    public graphqlUsingPost(body: GraphqlRequest, options?: RawAxiosRequestConfig) {
        return GraphQLApiFp(this.configuration).graphqlUsingPost(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IncludeExcludesApi - axios parameter creator
 * @export
 */
export const IncludeExcludesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List the include and exclude configurations.
         * @summary List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIncludeExcludes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts/me/include-excludes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the include and exclude configurations.
         * @summary Update
         * @param {Array<IncludeExcludeRequest>} includeExcludeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIncludeExcludes: async (includeExcludeRequest: Array<IncludeExcludeRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'includeExcludeRequest' is not null or undefined
            assertParamExists('updateIncludeExcludes', 'includeExcludeRequest', includeExcludeRequest)
            const localVarPath = `/accounts/me/include-excludes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(includeExcludeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IncludeExcludesApi - functional programming interface
 * @export
 */
export const IncludeExcludesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IncludeExcludesApiAxiosParamCreator(configuration)
    return {
        /**
         * List the include and exclude configurations.
         * @summary List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIncludeExcludes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IncludeExclude>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIncludeExcludes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncludeExcludesApi.listIncludeExcludes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the include and exclude configurations.
         * @summary Update
         * @param {Array<IncludeExcludeRequest>} includeExcludeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIncludeExcludes(includeExcludeRequest: Array<IncludeExcludeRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IncludeExclude>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIncludeExcludes(includeExcludeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IncludeExcludesApi.updateIncludeExcludes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IncludeExcludesApi - factory interface
 * @export
 */
export const IncludeExcludesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IncludeExcludesApiFp(configuration)
    return {
        /**
         * List the include and exclude configurations.
         * @summary List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIncludeExcludes(options?: RawAxiosRequestConfig): AxiosPromise<Array<IncludeExclude>> {
            return localVarFp.listIncludeExcludes(options).then((request) => request(axios, basePath));
        },
        /**
         * Update the include and exclude configurations.
         * @summary Update
         * @param {Array<IncludeExcludeRequest>} includeExcludeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIncludeExcludes(includeExcludeRequest: Array<IncludeExcludeRequest>, options?: RawAxiosRequestConfig): AxiosPromise<Array<IncludeExclude>> {
            return localVarFp.updateIncludeExcludes(includeExcludeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IncludeExcludesApi - object-oriented interface
 * @export
 * @class IncludeExcludesApi
 * @extends {BaseAPI}
 */
export class IncludeExcludesApi extends BaseAPI {
    /**
     * List the include and exclude configurations.
     * @summary List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncludeExcludesApi
     */
    public listIncludeExcludes(options?: RawAxiosRequestConfig) {
        return IncludeExcludesApiFp(this.configuration).listIncludeExcludes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the include and exclude configurations.
     * @summary Update
     * @param {Array<IncludeExcludeRequest>} includeExcludeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IncludeExcludesApi
     */
    public updateIncludeExcludes(includeExcludeRequest: Array<IncludeExcludeRequest>, options?: RawAxiosRequestConfig) {
        return IncludeExcludesApiFp(this.configuration).updateIncludeExcludes(includeExcludeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InspectorApi - axios parameter creator
 * @export
 */
export const InspectorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Inspect a URL to perform a variety of tasks defined by the list of applied filters.
         * @summary Inspect
         * @param {string} u The URL to inspect
         * @param {GetInspectFEnum} f Filters to be applied on the result, if you want to apply multiple filters they should be separated by comma
         * @param {Array<string>} [classes] A list of categories to be provided for classify filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInspect: async (u: string, f: GetInspectFEnum, classes?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'u' is not null or undefined
            assertParamExists('getInspect', 'u', u)
            // verify required parameter 'f' is not null or undefined
            assertParamExists('getInspect', 'f', f)
            const localVarPath = `/inspect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (u !== undefined) {
                localVarQueryParameter['u'] = u;
            }

            if (f !== undefined) {
                localVarQueryParameter['f'] = f;
            }

            if (classes) {
                localVarQueryParameter['classes'] = classes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InspectorApi - functional programming interface
 * @export
 */
export const InspectorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InspectorApiAxiosParamCreator(configuration)
    return {
        /**
         * Inspect a URL to perform a variety of tasks defined by the list of applied filters.
         * @summary Inspect
         * @param {string} u The URL to inspect
         * @param {GetInspectFEnum} f Filters to be applied on the result, if you want to apply multiple filters they should be separated by comma
         * @param {Array<string>} [classes] A list of categories to be provided for classify filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInspect(u: string, f: GetInspectFEnum, classes?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InspectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInspect(u, f, classes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InspectorApi.getInspect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InspectorApi - factory interface
 * @export
 */
export const InspectorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InspectorApiFp(configuration)
    return {
        /**
         * Inspect a URL to perform a variety of tasks defined by the list of applied filters.
         * @summary Inspect
         * @param {string} u The URL to inspect
         * @param {GetInspectFEnum} f Filters to be applied on the result, if you want to apply multiple filters they should be separated by comma
         * @param {Array<string>} [classes] A list of categories to be provided for classify filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInspect(u: string, f: GetInspectFEnum, classes?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<InspectResponse> {
            return localVarFp.getInspect(u, f, classes, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InspectorApi - object-oriented interface
 * @export
 * @class InspectorApi
 * @extends {BaseAPI}
 */
export class InspectorApi extends BaseAPI {
    /**
     * Inspect a URL to perform a variety of tasks defined by the list of applied filters.
     * @summary Inspect
     * @param {string} u The URL to inspect
     * @param {GetInspectFEnum} f Filters to be applied on the result, if you want to apply multiple filters they should be separated by comma
     * @param {Array<string>} [classes] A list of categories to be provided for classify filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InspectorApi
     */
    public getInspect(u: string, f: GetInspectFEnum, classes?: Array<string>, options?: RawAxiosRequestConfig) {
        return InspectorApiFp(this.configuration).getInspect(u, f, classes, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetInspectFEnum = {
    Validator: 'validator',
    ContentAnalysis: 'content-analysis',
    MockLanguageDetection: 'mock-language-detection',
    BrowserResponse: 'browser-response',
    JenaGraph: 'jena-graph',
    Links: 'links',
    BrowserResponse2: 'browser-response',
    LinguaLanguageDetection: 'lingua-language-detection',
    LanguageDetection: 'language-detection',
    RedlinkContentAnalysis: 'redlink-content-analysis',
    Summarize: 'summarize',
    Text: 'text',
    Validator2: 'validator',
    Xmltei: 'xmltei',
    Classify: 'classify'
} as const;
export type GetInspectFEnum = typeof GetInspectFEnum[keyof typeof GetInspectFEnum];


/**
 * InternalLinksApi - axios parameter creator
 * @export
 */
export const InternalLinksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create Internal Links.
         * @summary Create
         * @param {InternalLinkRequest} internalLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInternalLink: async (internalLinkRequest: InternalLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'internalLinkRequest' is not null or undefined
            assertParamExists('createInternalLink', 'internalLinkRequest', internalLinkRequest)
            const localVarPath = `/internal-links`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(internalLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an Internal Links suggestion.
         * @summary Suggest
         * @param {InternalLinkRequest} internalLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInternalLinkSuggestion: async (internalLinkRequest: InternalLinkRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'internalLinkRequest' is not null or undefined
            assertParamExists('createInternalLinkSuggestion', 'internalLinkRequest', internalLinkRequest)
            const localVarPath = `/internal-links/suggestions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(internalLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalLinksApi - functional programming interface
 * @export
 */
export const InternalLinksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalLinksApiAxiosParamCreator(configuration)
    return {
        /**
         * Create Internal Links.
         * @summary Create
         * @param {InternalLinkRequest} internalLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInternalLink(internalLinkRequest: InternalLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInternalLink(internalLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalLinksApi.createInternalLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create an Internal Links suggestion.
         * @summary Suggest
         * @param {InternalLinkRequest} internalLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInternalLinkSuggestion(internalLinkRequest: InternalLinkRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InternalLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInternalLinkSuggestion(internalLinkRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalLinksApi.createInternalLinkSuggestion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InternalLinksApi - factory interface
 * @export
 */
export const InternalLinksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalLinksApiFp(configuration)
    return {
        /**
         * Create Internal Links.
         * @summary Create
         * @param {InternalLinkRequest} internalLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInternalLink(internalLinkRequest: InternalLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.createInternalLink(internalLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an Internal Links suggestion.
         * @summary Suggest
         * @param {InternalLinkRequest} internalLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInternalLinkSuggestion(internalLinkRequest: InternalLinkRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<InternalLink>> {
            return localVarFp.createInternalLinkSuggestion(internalLinkRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalLinksApi - object-oriented interface
 * @export
 * @class InternalLinksApi
 * @extends {BaseAPI}
 */
export class InternalLinksApi extends BaseAPI {
    /**
     * Create Internal Links.
     * @summary Create
     * @param {InternalLinkRequest} internalLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalLinksApi
     */
    public createInternalLink(internalLinkRequest: InternalLinkRequest, options?: RawAxiosRequestConfig) {
        return InternalLinksApiFp(this.configuration).createInternalLink(internalLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an Internal Links suggestion.
     * @summary Suggest
     * @param {InternalLinkRequest} internalLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalLinksApi
     */
    public createInternalLinkSuggestion(internalLinkRequest: InternalLinkRequest, options?: RawAxiosRequestConfig) {
        return InternalLinksApiFp(this.configuration).createInternalLinkSuggestion(internalLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LongTailsApi - axios parameter creator
 * @export
 */
export const LongTailsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Query for long tail opportunities and receive entities.
         * @summary Get entities
         * @param {string} q The Longtail query
         * @param {string} ln A location name, origin of the search
         * @param {string} lc Language Code
         * @param {string} sd Search Domain
         * @param {Get2ScEnum} [sc] Analysis Scope
         * @param {string} [d] The maximum number of results to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2: async (q: string, ln: string, lc: string, sd: string, sc?: Get2ScEnum, d?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('get2', 'q', q)
            // verify required parameter 'ln' is not null or undefined
            assertParamExists('get2', 'ln', ln)
            // verify required parameter 'lc' is not null or undefined
            assertParamExists('get2', 'lc', lc)
            // verify required parameter 'sd' is not null or undefined
            assertParamExists('get2', 'sd', sd)
            const localVarPath = `/longtail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (ln !== undefined) {
                localVarQueryParameter['ln'] = ln;
            }

            if (lc !== undefined) {
                localVarQueryParameter['lc'] = lc;
            }

            if (sd !== undefined) {
                localVarQueryParameter['sd'] = sd;
            }

            if (sc !== undefined) {
                localVarQueryParameter['sc'] = sc;
            }

            if (d !== undefined) {
                localVarQueryParameter['d'] = d;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query for long tail opportunities and receive entities along with their position in SERP.
         * @summary Get entities by rank (async)
         * @param {string} q The Longtail query
         * @param {string} ln A location name, origin of the search
         * @param {string} lc Language Code
         * @param {string} sd Search Domain
         * @param {string} hk Webhook URL
         * @param {Get3ScEnum} [sc] Analysis Scope
         * @param {string} [d] The maximum number of results to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3: async (q: string, ln: string, lc: string, sd: string, hk: string, sc?: Get3ScEnum, d?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('get3', 'q', q)
            // verify required parameter 'ln' is not null or undefined
            assertParamExists('get3', 'ln', ln)
            // verify required parameter 'lc' is not null or undefined
            assertParamExists('get3', 'lc', lc)
            // verify required parameter 'sd' is not null or undefined
            assertParamExists('get3', 'sd', sd)
            // verify required parameter 'hk' is not null or undefined
            assertParamExists('get3', 'hk', hk)
            const localVarPath = `/longtail/hook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (ln !== undefined) {
                localVarQueryParameter['ln'] = ln;
            }

            if (lc !== undefined) {
                localVarQueryParameter['lc'] = lc;
            }

            if (sd !== undefined) {
                localVarQueryParameter['sd'] = sd;
            }

            if (sc !== undefined) {
                localVarQueryParameter['sc'] = sc;
            }

            if (hk !== undefined) {
                localVarQueryParameter['hk'] = hk;
            }

            if (d !== undefined) {
                localVarQueryParameter['d'] = d;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Query for long tail opportunities and receive entities along with their position in SERP.
         * @summary Get entities by rank
         * @param {string} q The Longtail query
         * @param {string} ln A location name, origin of the search
         * @param {string} lc Language Code
         * @param {string} sd Search Domain
         * @param {GetV2ScEnum} [sc] Analysis Scope
         * @param {string} [d] The maximum number of results to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getV2: async (q: string, ln: string, lc: string, sd: string, sc?: GetV2ScEnum, d?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('getV2', 'q', q)
            // verify required parameter 'ln' is not null or undefined
            assertParamExists('getV2', 'ln', ln)
            // verify required parameter 'lc' is not null or undefined
            assertParamExists('getV2', 'lc', lc)
            // verify required parameter 'sd' is not null or undefined
            assertParamExists('getV2', 'sd', sd)
            const localVarPath = `/longtail/v2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (ln !== undefined) {
                localVarQueryParameter['ln'] = ln;
            }

            if (lc !== undefined) {
                localVarQueryParameter['lc'] = lc;
            }

            if (sd !== undefined) {
                localVarQueryParameter['sd'] = sd;
            }

            if (sc !== undefined) {
                localVarQueryParameter['sc'] = sc;
            }

            if (d !== undefined) {
                localVarQueryParameter['d'] = d;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LongTailsApi - functional programming interface
 * @export
 */
export const LongTailsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LongTailsApiAxiosParamCreator(configuration)
    return {
        /**
         * Query for long tail opportunities and receive entities.
         * @summary Get entities
         * @param {string} q The Longtail query
         * @param {string} ln A location name, origin of the search
         * @param {string} lc Language Code
         * @param {string} sd Search Domain
         * @param {Get2ScEnum} [sc] Analysis Scope
         * @param {string} [d] The maximum number of results to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get2(q: string, ln: string, lc: string, sd: string, sc?: Get2ScEnum, d?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LongtailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get2(q, ln, lc, sd, sc, d, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LongTailsApi.get2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query for long tail opportunities and receive entities along with their position in SERP.
         * @summary Get entities by rank (async)
         * @param {string} q The Longtail query
         * @param {string} ln A location name, origin of the search
         * @param {string} lc Language Code
         * @param {string} sd Search Domain
         * @param {string} hk Webhook URL
         * @param {Get3ScEnum} [sc] Analysis Scope
         * @param {string} [d] The maximum number of results to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get3(q: string, ln: string, lc: string, sd: string, hk: string, sc?: Get3ScEnum, d?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get3(q, ln, lc, sd, hk, sc, d, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LongTailsApi.get3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Query for long tail opportunities and receive entities along with their position in SERP.
         * @summary Get entities by rank
         * @param {string} q The Longtail query
         * @param {string} ln A location name, origin of the search
         * @param {string} lc Language Code
         * @param {string} sd Search Domain
         * @param {GetV2ScEnum} [sc] Analysis Scope
         * @param {string} [d] The maximum number of results to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getV2(q: string, ln: string, lc: string, sd: string, sc?: GetV2ScEnum, d?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RankEntities>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getV2(q, ln, lc, sd, sc, d, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LongTailsApi.getV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LongTailsApi - factory interface
 * @export
 */
export const LongTailsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LongTailsApiFp(configuration)
    return {
        /**
         * Query for long tail opportunities and receive entities.
         * @summary Get entities
         * @param {string} q The Longtail query
         * @param {string} ln A location name, origin of the search
         * @param {string} lc Language Code
         * @param {string} sd Search Domain
         * @param {Get2ScEnum} [sc] Analysis Scope
         * @param {string} [d] The maximum number of results to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2(q: string, ln: string, lc: string, sd: string, sc?: Get2ScEnum, d?: string, options?: RawAxiosRequestConfig): AxiosPromise<LongtailResponse> {
            return localVarFp.get2(q, ln, lc, sd, sc, d, options).then((request) => request(axios, basePath));
        },
        /**
         * Query for long tail opportunities and receive entities along with their position in SERP.
         * @summary Get entities by rank (async)
         * @param {string} q The Longtail query
         * @param {string} ln A location name, origin of the search
         * @param {string} lc Language Code
         * @param {string} sd Search Domain
         * @param {string} hk Webhook URL
         * @param {Get3ScEnum} [sc] Analysis Scope
         * @param {string} [d] The maximum number of results to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3(q: string, ln: string, lc: string, sd: string, hk: string, sc?: Get3ScEnum, d?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.get3(q, ln, lc, sd, hk, sc, d, options).then((request) => request(axios, basePath));
        },
        /**
         * Query for long tail opportunities and receive entities along with their position in SERP.
         * @summary Get entities by rank
         * @param {string} q The Longtail query
         * @param {string} ln A location name, origin of the search
         * @param {string} lc Language Code
         * @param {string} sd Search Domain
         * @param {GetV2ScEnum} [sc] Analysis Scope
         * @param {string} [d] The maximum number of results to analyze
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getV2(q: string, ln: string, lc: string, sd: string, sc?: GetV2ScEnum, d?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<RankEntities>> {
            return localVarFp.getV2(q, ln, lc, sd, sc, d, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LongTailsApi - object-oriented interface
 * @export
 * @class LongTailsApi
 * @extends {BaseAPI}
 */
export class LongTailsApi extends BaseAPI {
    /**
     * Query for long tail opportunities and receive entities.
     * @summary Get entities
     * @param {string} q The Longtail query
     * @param {string} ln A location name, origin of the search
     * @param {string} lc Language Code
     * @param {string} sd Search Domain
     * @param {Get2ScEnum} [sc] Analysis Scope
     * @param {string} [d] The maximum number of results to analyze
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LongTailsApi
     */
    public get2(q: string, ln: string, lc: string, sd: string, sc?: Get2ScEnum, d?: string, options?: RawAxiosRequestConfig) {
        return LongTailsApiFp(this.configuration).get2(q, ln, lc, sd, sc, d, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query for long tail opportunities and receive entities along with their position in SERP.
     * @summary Get entities by rank (async)
     * @param {string} q The Longtail query
     * @param {string} ln A location name, origin of the search
     * @param {string} lc Language Code
     * @param {string} sd Search Domain
     * @param {string} hk Webhook URL
     * @param {Get3ScEnum} [sc] Analysis Scope
     * @param {string} [d] The maximum number of results to analyze
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LongTailsApi
     */
    public get3(q: string, ln: string, lc: string, sd: string, hk: string, sc?: Get3ScEnum, d?: string, options?: RawAxiosRequestConfig) {
        return LongTailsApiFp(this.configuration).get3(q, ln, lc, sd, hk, sc, d, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Query for long tail opportunities and receive entities along with their position in SERP.
     * @summary Get entities by rank
     * @param {string} q The Longtail query
     * @param {string} ln A location name, origin of the search
     * @param {string} lc Language Code
     * @param {string} sd Search Domain
     * @param {GetV2ScEnum} [sc] Analysis Scope
     * @param {string} [d] The maximum number of results to analyze
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LongTailsApi
     */
    public getV2(q: string, ln: string, lc: string, sd: string, sc?: GetV2ScEnum, d?: string, options?: RawAxiosRequestConfig) {
        return LongTailsApiFp(this.configuration).getV2(q, ln, lc, sd, sc, d, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const Get2ScEnum = {
    All: 'all',
    Local: 'local',
    Network: 'network'
} as const;
export type Get2ScEnum = typeof Get2ScEnum[keyof typeof Get2ScEnum];
/**
 * @export
 */
export const Get3ScEnum = {
    All: 'all',
    Local: 'local',
    Network: 'network'
} as const;
export type Get3ScEnum = typeof Get3ScEnum[keyof typeof Get3ScEnum];
/**
 * @export
 */
export const GetV2ScEnum = {
    All: 'all',
    Local: 'local',
    Network: 'network'
} as const;
export type GetV2ScEnum = typeof GetV2ScEnum[keyof typeof GetV2ScEnum];


/**
 * MerchantSyncsApi - axios parameter creator
 * @export
 */
export const MerchantSyncsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Start
         * @param {number} merchantId The Merchant\&#39;s &#x60;id&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSync: async (merchantId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'merchantId' is not null or undefined
            assertParamExists('createSync', 'merchantId', merchantId)
            const localVarPath = `/merchants/{merchantId}/syncs`
                .replace(`{${"merchantId"}}`, encodeURIComponent(String(merchantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get by id
         * @param {number} merchantId The Merchant\&#39;s &#x60;id&#x60;
         * @param {number} id The Merchant Sync &#x60;id&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantSync: async (merchantId: number, id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'merchantId' is not null or undefined
            assertParamExists('getMerchantSync', 'merchantId', merchantId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMerchantSync', 'id', id)
            const localVarPath = `/merchants/{merchantId}/syncs/{id}`
                .replace(`{${"merchantId"}}`, encodeURIComponent(String(merchantId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Merchants Syncs
         * @summary List
         * @param {number} merchantId The Merchant\&#39;s &#x60;id&#x60;
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {string} [sort] The sorting, &#x60;+id&#x60; or &#x60;-id&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMerchantSyncs: async (merchantId: number, cursor?: string, limit?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'merchantId' is not null or undefined
            assertParamExists('listMerchantSyncs', 'merchantId', merchantId)
            const localVarPath = `/merchants/{merchantId}/syncs`
                .replace(`{${"merchantId"}}`, encodeURIComponent(String(merchantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MerchantSyncsApi - functional programming interface
 * @export
 */
export const MerchantSyncsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MerchantSyncsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Start
         * @param {number} merchantId The Merchant\&#39;s &#x60;id&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSync(merchantId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantSync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSync(merchantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MerchantSyncsApi.createSync']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get by id
         * @param {number} merchantId The Merchant\&#39;s &#x60;id&#x60;
         * @param {number} id The Merchant Sync &#x60;id&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMerchantSync(merchantId: number, id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MerchantSync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMerchantSync(merchantId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MerchantSyncsApi.getMerchantSync']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the Merchants Syncs
         * @summary List
         * @param {number} merchantId The Merchant\&#39;s &#x60;id&#x60;
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {string} [sort] The sorting, &#x60;+id&#x60; or &#x60;-id&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMerchantSyncs(merchantId: number, cursor?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageMerchantSync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMerchantSyncs(merchantId, cursor, limit, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MerchantSyncsApi.listMerchantSyncs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MerchantSyncsApi - factory interface
 * @export
 */
export const MerchantSyncsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MerchantSyncsApiFp(configuration)
    return {
        /**
         * 
         * @summary Start
         * @param {number} merchantId The Merchant\&#39;s &#x60;id&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSync(merchantId: number, options?: RawAxiosRequestConfig): AxiosPromise<MerchantSync> {
            return localVarFp.createSync(merchantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get by id
         * @param {number} merchantId The Merchant\&#39;s &#x60;id&#x60;
         * @param {number} id The Merchant Sync &#x60;id&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchantSync(merchantId: number, id: number, options?: RawAxiosRequestConfig): AxiosPromise<MerchantSync> {
            return localVarFp.getMerchantSync(merchantId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Merchants Syncs
         * @summary List
         * @param {number} merchantId The Merchant\&#39;s &#x60;id&#x60;
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {string} [sort] The sorting, &#x60;+id&#x60; or &#x60;-id&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMerchantSyncs(merchantId: number, cursor?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<PageMerchantSync> {
            return localVarFp.listMerchantSyncs(merchantId, cursor, limit, sort, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MerchantSyncsApi - object-oriented interface
 * @export
 * @class MerchantSyncsApi
 * @extends {BaseAPI}
 */
export class MerchantSyncsApi extends BaseAPI {
    /**
     * 
     * @summary Start
     * @param {number} merchantId The Merchant\&#39;s &#x60;id&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantSyncsApi
     */
    public createSync(merchantId: number, options?: RawAxiosRequestConfig) {
        return MerchantSyncsApiFp(this.configuration).createSync(merchantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get by id
     * @param {number} merchantId The Merchant\&#39;s &#x60;id&#x60;
     * @param {number} id The Merchant Sync &#x60;id&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantSyncsApi
     */
    public getMerchantSync(merchantId: number, id: number, options?: RawAxiosRequestConfig) {
        return MerchantSyncsApiFp(this.configuration).getMerchantSync(merchantId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Merchants Syncs
     * @summary List
     * @param {number} merchantId The Merchant\&#39;s &#x60;id&#x60;
     * @param {string} [cursor] The cursor
     * @param {number} [limit] The maximum number of results
     * @param {string} [sort] The sorting, &#x60;+id&#x60; or &#x60;-id&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantSyncsApi
     */
    public listMerchantSyncs(merchantId: number, cursor?: string, limit?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return MerchantSyncsApiFp(this.configuration).listMerchantSyncs(merchantId, cursor, limit, sort, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MerchantsApi - axios parameter creator
 * @export
 */
export const MerchantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Merchant
         * @summary Create
         * @param {MerchantRequest} merchantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMerchant: async (merchantRequest: MerchantRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'merchantRequest' is not null or undefined
            assertParamExists('createMerchant', 'merchantRequest', merchantRequest)
            const localVarPath = `/merchants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(merchantRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Merchant by its `id`.
         * @summary Delete by id
         * @param {number} id The Merchant id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMerchant: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteMerchant', 'id', id)
            const localVarPath = `/merchants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Merchant by its `id`.
         * @summary Get by id
         * @param {number} id The Merchant id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchant: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMerchant', 'id', id)
            const localVarPath = `/merchants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the Merchants, optionally filtering by the `deleted` flag
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {boolean} [deleted] Filter by the &#x60;deleted&#x60; flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMerchants: async (cursor?: string, limit?: number, deleted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/merchants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a Merchant
         * @summary Update
         * @param {number} id The Merchant id
         * @param {MerchantRequest} merchantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMerchant: async (id: number, merchantRequest: MerchantRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMerchant', 'id', id)
            // verify required parameter 'merchantRequest' is not null or undefined
            assertParamExists('updateMerchant', 'merchantRequest', merchantRequest)
            const localVarPath = `/merchants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(merchantRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MerchantsApi - functional programming interface
 * @export
 */
export const MerchantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MerchantsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a Merchant
         * @summary Create
         * @param {MerchantRequest} merchantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMerchant(merchantRequest: MerchantRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Merchant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMerchant(merchantRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MerchantsApi.createMerchant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Merchant by its `id`.
         * @summary Delete by id
         * @param {number} id The Merchant id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMerchant(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMerchant(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MerchantsApi.deleteMerchant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Merchant by its `id`.
         * @summary Get by id
         * @param {number} id The Merchant id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMerchant(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Merchant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMerchant(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MerchantsApi.getMerchant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the Merchants, optionally filtering by the `deleted` flag
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {boolean} [deleted] Filter by the &#x60;deleted&#x60; flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMerchants(cursor?: string, limit?: number, deleted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageMerchantView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMerchants(cursor, limit, deleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MerchantsApi.listMerchants']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a Merchant
         * @summary Update
         * @param {number} id The Merchant id
         * @param {MerchantRequest} merchantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMerchant(id: number, merchantRequest: MerchantRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Merchant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMerchant(id, merchantRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MerchantsApi.updateMerchant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MerchantsApi - factory interface
 * @export
 */
export const MerchantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MerchantsApiFp(configuration)
    return {
        /**
         * Create a Merchant
         * @summary Create
         * @param {MerchantRequest} merchantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMerchant(merchantRequest: MerchantRequest, options?: RawAxiosRequestConfig): AxiosPromise<Merchant> {
            return localVarFp.createMerchant(merchantRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Merchant by its `id`.
         * @summary Delete by id
         * @param {number} id The Merchant id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMerchant(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteMerchant(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Merchant by its `id`.
         * @summary Get by id
         * @param {number} id The Merchant id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerchant(id: number, options?: RawAxiosRequestConfig): AxiosPromise<Merchant> {
            return localVarFp.getMerchant(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the Merchants, optionally filtering by the `deleted` flag
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {boolean} [deleted] Filter by the &#x60;deleted&#x60; flag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMerchants(cursor?: string, limit?: number, deleted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<PageMerchantView> {
            return localVarFp.listMerchants(cursor, limit, deleted, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a Merchant
         * @summary Update
         * @param {number} id The Merchant id
         * @param {MerchantRequest} merchantRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMerchant(id: number, merchantRequest: MerchantRequest, options?: RawAxiosRequestConfig): AxiosPromise<Merchant> {
            return localVarFp.updateMerchant(id, merchantRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MerchantsApi - object-oriented interface
 * @export
 * @class MerchantsApi
 * @extends {BaseAPI}
 */
export class MerchantsApi extends BaseAPI {
    /**
     * Create a Merchant
     * @summary Create
     * @param {MerchantRequest} merchantRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantsApi
     */
    public createMerchant(merchantRequest: MerchantRequest, options?: RawAxiosRequestConfig) {
        return MerchantsApiFp(this.configuration).createMerchant(merchantRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Merchant by its `id`.
     * @summary Delete by id
     * @param {number} id The Merchant id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantsApi
     */
    public deleteMerchant(id: number, options?: RawAxiosRequestConfig) {
        return MerchantsApiFp(this.configuration).deleteMerchant(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Merchant by its `id`.
     * @summary Get by id
     * @param {number} id The Merchant id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantsApi
     */
    public getMerchant(id: number, options?: RawAxiosRequestConfig) {
        return MerchantsApiFp(this.configuration).getMerchant(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the Merchants, optionally filtering by the `deleted` flag
     * @summary List
     * @param {string} [cursor] The cursor
     * @param {number} [limit] The maximum number of results
     * @param {boolean} [deleted] Filter by the &#x60;deleted&#x60; flag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantsApi
     */
    public listMerchants(cursor?: string, limit?: number, deleted?: boolean, options?: RawAxiosRequestConfig) {
        return MerchantsApiFp(this.configuration).listMerchants(cursor, limit, deleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a Merchant
     * @summary Update
     * @param {number} id The Merchant id
     * @param {MerchantRequest} merchantRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MerchantsApi
     */
    public updateMerchant(id: number, merchantRequest: MerchantRequest, options?: RawAxiosRequestConfig) {
        return MerchantsApiFp(this.configuration).updateMerchant(id, merchantRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MicrodataApi - axios parameter creator
 * @export
 */
export const MicrodataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provided a URL, converts any microdata found on that URL to JSON-LD.
         * @summary Microdata to JSON-LD
         * @param {string} u The web page URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        microdataToJsonLd: async (u: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'u' is not null or undefined
            assertParamExists('microdataToJsonLd', 'u', u)
            const localVarPath = `/microdata-to-jsonld`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (u !== undefined) {
                localVarQueryParameter['u'] = u;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MicrodataApi - functional programming interface
 * @export
 */
export const MicrodataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MicrodataApiAxiosParamCreator(configuration)
    return {
        /**
         * Provided a URL, converts any microdata found on that URL to JSON-LD.
         * @summary Microdata to JSON-LD
         * @param {string} u The web page URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async microdataToJsonLd(u: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.microdataToJsonLd(u, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MicrodataApi.microdataToJsonLd']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MicrodataApi - factory interface
 * @export
 */
export const MicrodataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MicrodataApiFp(configuration)
    return {
        /**
         * Provided a URL, converts any microdata found on that URL to JSON-LD.
         * @summary Microdata to JSON-LD
         * @param {string} u The web page URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        microdataToJsonLd(u: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.microdataToJsonLd(u, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MicrodataApi - object-oriented interface
 * @export
 * @class MicrodataApi
 * @extends {BaseAPI}
 */
export class MicrodataApi extends BaseAPI {
    /**
     * Provided a URL, converts any microdata found on that URL to JSON-LD.
     * @summary Microdata to JSON-LD
     * @param {string} u The web page URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrodataApi
     */
    public microdataToJsonLd(u: string, options?: RawAxiosRequestConfig) {
        return MicrodataApiFp(this.configuration).microdataToJsonLd(u, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OAuth2AuthorizedClientsApi - axios parameter creator
 * @export
 */
export const OAuth2AuthorizedClientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a OAuth2 Authorized Client
         * @summary Create
         * @param {OAuth2AuthorizedClientRequest} oAuth2AuthorizedClientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOAuth2AuthorizedClient: async (oAuth2AuthorizedClientRequest: OAuth2AuthorizedClientRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'oAuth2AuthorizedClientRequest' is not null or undefined
            assertParamExists('createOAuth2AuthorizedClient', 'oAuth2AuthorizedClientRequest', oAuth2AuthorizedClientRequest)
            const localVarPath = `/oauth2/authorized-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuth2AuthorizedClientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a OAuth2 Authorized Client given its client registration id
         * @summary Delete
         * @param {number} id The Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOAuth2AuthorizedClient: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOAuth2AuthorizedClient', 'id', id)
            const localVarPath = `/oauth2/authorized-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a OAuth2 Authorized Client given its client registration id
         * @summary Get
         * @param {number} id The Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuth2AuthorizedClient: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOAuth2AuthorizedClient', 'id', id)
            const localVarPath = `/oauth2/authorized-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List OAuth2 Authorized Clients
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOAuth2AuthorizedClients: async (cursor?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/oauth2/authorized-clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a OAuth2 Authorized Client given its client registration id
         * @summary Update
         * @param {number} id The Id
         * @param {OAuth2AuthorizedClientRequest} oAuth2AuthorizedClientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOAuth2AuthorizedClient: async (id: number, oAuth2AuthorizedClientRequest: OAuth2AuthorizedClientRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOAuth2AuthorizedClient', 'id', id)
            // verify required parameter 'oAuth2AuthorizedClientRequest' is not null or undefined
            assertParamExists('updateOAuth2AuthorizedClient', 'oAuth2AuthorizedClientRequest', oAuth2AuthorizedClientRequest)
            const localVarPath = `/oauth2/authorized-clients/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oAuth2AuthorizedClientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OAuth2AuthorizedClientsApi - functional programming interface
 * @export
 */
export const OAuth2AuthorizedClientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OAuth2AuthorizedClientsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a OAuth2 Authorized Client
         * @summary Create
         * @param {OAuth2AuthorizedClientRequest} oAuth2AuthorizedClientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOAuth2AuthorizedClient(oAuth2AuthorizedClientRequest: OAuth2AuthorizedClientRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2AuthorizedClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOAuth2AuthorizedClient(oAuth2AuthorizedClientRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2AuthorizedClientsApi.createOAuth2AuthorizedClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a OAuth2 Authorized Client given its client registration id
         * @summary Delete
         * @param {number} id The Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOAuth2AuthorizedClient(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOAuth2AuthorizedClient(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2AuthorizedClientsApi.deleteOAuth2AuthorizedClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a OAuth2 Authorized Client given its client registration id
         * @summary Get
         * @param {number} id The Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOAuth2AuthorizedClient(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2AuthorizedClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOAuth2AuthorizedClient(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2AuthorizedClientsApi.getOAuth2AuthorizedClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List OAuth2 Authorized Clients
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOAuth2AuthorizedClients(cursor?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageOAuth2AuthorizedClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listOAuth2AuthorizedClients(cursor, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2AuthorizedClientsApi.listOAuth2AuthorizedClients']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a OAuth2 Authorized Client given its client registration id
         * @summary Update
         * @param {number} id The Id
         * @param {OAuth2AuthorizedClientRequest} oAuth2AuthorizedClientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOAuth2AuthorizedClient(id: number, oAuth2AuthorizedClientRequest: OAuth2AuthorizedClientRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2AuthorizedClient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOAuth2AuthorizedClient(id, oAuth2AuthorizedClientRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OAuth2AuthorizedClientsApi.updateOAuth2AuthorizedClient']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OAuth2AuthorizedClientsApi - factory interface
 * @export
 */
export const OAuth2AuthorizedClientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OAuth2AuthorizedClientsApiFp(configuration)
    return {
        /**
         * Create a OAuth2 Authorized Client
         * @summary Create
         * @param {OAuth2AuthorizedClientRequest} oAuth2AuthorizedClientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOAuth2AuthorizedClient(oAuth2AuthorizedClientRequest: OAuth2AuthorizedClientRequest, options?: RawAxiosRequestConfig): AxiosPromise<OAuth2AuthorizedClient> {
            return localVarFp.createOAuth2AuthorizedClient(oAuth2AuthorizedClientRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a OAuth2 Authorized Client given its client registration id
         * @summary Delete
         * @param {number} id The Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOAuth2AuthorizedClient(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteOAuth2AuthorizedClient(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a OAuth2 Authorized Client given its client registration id
         * @summary Get
         * @param {number} id The Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOAuth2AuthorizedClient(id: number, options?: RawAxiosRequestConfig): AxiosPromise<OAuth2AuthorizedClient> {
            return localVarFp.getOAuth2AuthorizedClient(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List OAuth2 Authorized Clients
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOAuth2AuthorizedClients(cursor?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageOAuth2AuthorizedClient> {
            return localVarFp.listOAuth2AuthorizedClients(cursor, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a OAuth2 Authorized Client given its client registration id
         * @summary Update
         * @param {number} id The Id
         * @param {OAuth2AuthorizedClientRequest} oAuth2AuthorizedClientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOAuth2AuthorizedClient(id: number, oAuth2AuthorizedClientRequest: OAuth2AuthorizedClientRequest, options?: RawAxiosRequestConfig): AxiosPromise<OAuth2AuthorizedClient> {
            return localVarFp.updateOAuth2AuthorizedClient(id, oAuth2AuthorizedClientRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OAuth2AuthorizedClientsApi - object-oriented interface
 * @export
 * @class OAuth2AuthorizedClientsApi
 * @extends {BaseAPI}
 */
export class OAuth2AuthorizedClientsApi extends BaseAPI {
    /**
     * Create a OAuth2 Authorized Client
     * @summary Create
     * @param {OAuth2AuthorizedClientRequest} oAuth2AuthorizedClientRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2AuthorizedClientsApi
     */
    public createOAuth2AuthorizedClient(oAuth2AuthorizedClientRequest: OAuth2AuthorizedClientRequest, options?: RawAxiosRequestConfig) {
        return OAuth2AuthorizedClientsApiFp(this.configuration).createOAuth2AuthorizedClient(oAuth2AuthorizedClientRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a OAuth2 Authorized Client given its client registration id
     * @summary Delete
     * @param {number} id The Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2AuthorizedClientsApi
     */
    public deleteOAuth2AuthorizedClient(id: number, options?: RawAxiosRequestConfig) {
        return OAuth2AuthorizedClientsApiFp(this.configuration).deleteOAuth2AuthorizedClient(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a OAuth2 Authorized Client given its client registration id
     * @summary Get
     * @param {number} id The Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2AuthorizedClientsApi
     */
    public getOAuth2AuthorizedClient(id: number, options?: RawAxiosRequestConfig) {
        return OAuth2AuthorizedClientsApiFp(this.configuration).getOAuth2AuthorizedClient(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List OAuth2 Authorized Clients
     * @summary List
     * @param {string} [cursor] The cursor
     * @param {number} [limit] The maximum number of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2AuthorizedClientsApi
     */
    public listOAuth2AuthorizedClients(cursor?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return OAuth2AuthorizedClientsApiFp(this.configuration).listOAuth2AuthorizedClients(cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a OAuth2 Authorized Client given its client registration id
     * @summary Update
     * @param {number} id The Id
     * @param {OAuth2AuthorizedClientRequest} oAuth2AuthorizedClientRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OAuth2AuthorizedClientsApi
     */
    public updateOAuth2AuthorizedClient(id: number, oAuth2AuthorizedClientRequest: OAuth2AuthorizedClientRequest, options?: RawAxiosRequestConfig) {
        return OAuth2AuthorizedClientsApiFp(this.configuration).updateOAuth2AuthorizedClient(id, oAuth2AuthorizedClientRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlatformConsumptionsApi - axios parameter creator
 * @export
 */
export const PlatformConsumptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create or update the Platform Consumption for the authenticated user.
         * @summary Create or update the Platform Consumption
         * @param {string} appliesTo 
         * @param {number} [consumptionToAdd] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateMyPlatformConsumption: async (appliesTo: string, consumptionToAdd?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appliesTo' is not null or undefined
            assertParamExists('createOrUpdateMyPlatformConsumption', 'appliesTo', appliesTo)
            const localVarPath = `/platform-limit/consumptions/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (appliesTo !== undefined) {
                localVarQueryParameter['applies_to'] = appliesTo;
            }

            if (consumptionToAdd !== undefined) {
                localVarQueryParameter['consumption_to_add'] = consumptionToAdd;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the Platform Consumption for the authenticated user.
         * @summary Get the Platform Consumption
         * @param {string} appliesTo 
         * @param {boolean} [includeSubscription] 
         * @param {boolean} [includeLimit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyPlatformConsumption: async (appliesTo: string, includeSubscription?: boolean, includeLimit?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appliesTo' is not null or undefined
            assertParamExists('getMyPlatformConsumption', 'appliesTo', appliesTo)
            const localVarPath = `/platform-limit/consumptions/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (appliesTo !== undefined) {
                localVarQueryParameter['applies_to'] = appliesTo;
            }

            if (includeSubscription !== undefined) {
                localVarQueryParameter['include_subscription'] = includeSubscription;
            }

            if (includeLimit !== undefined) {
                localVarQueryParameter['include_limit'] = includeLimit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlatformConsumptionsApi - functional programming interface
 * @export
 */
export const PlatformConsumptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlatformConsumptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create or update the Platform Consumption for the authenticated user.
         * @summary Create or update the Platform Consumption
         * @param {string} appliesTo 
         * @param {number} [consumptionToAdd] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateMyPlatformConsumption(appliesTo: string, consumptionToAdd?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageWithLimits>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrUpdateMyPlatformConsumption(appliesTo, consumptionToAdd, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlatformConsumptionsApi.createOrUpdateMyPlatformConsumption']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the Platform Consumption for the authenticated user.
         * @summary Get the Platform Consumption
         * @param {string} appliesTo 
         * @param {boolean} [includeSubscription] 
         * @param {boolean} [includeLimit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyPlatformConsumption(appliesTo: string, includeSubscription?: boolean, includeLimit?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageWithLimits>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyPlatformConsumption(appliesTo, includeSubscription, includeLimit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlatformConsumptionsApi.getMyPlatformConsumption']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlatformConsumptionsApi - factory interface
 * @export
 */
export const PlatformConsumptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlatformConsumptionsApiFp(configuration)
    return {
        /**
         * Create or update the Platform Consumption for the authenticated user.
         * @summary Create or update the Platform Consumption
         * @param {string} appliesTo 
         * @param {number} [consumptionToAdd] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateMyPlatformConsumption(appliesTo: string, consumptionToAdd?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageWithLimits> {
            return localVarFp.createOrUpdateMyPlatformConsumption(appliesTo, consumptionToAdd, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the Platform Consumption for the authenticated user.
         * @summary Get the Platform Consumption
         * @param {string} appliesTo 
         * @param {boolean} [includeSubscription] 
         * @param {boolean} [includeLimit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyPlatformConsumption(appliesTo: string, includeSubscription?: boolean, includeLimit?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<PageWithLimits> {
            return localVarFp.getMyPlatformConsumption(appliesTo, includeSubscription, includeLimit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlatformConsumptionsApi - object-oriented interface
 * @export
 * @class PlatformConsumptionsApi
 * @extends {BaseAPI}
 */
export class PlatformConsumptionsApi extends BaseAPI {
    /**
     * Create or update the Platform Consumption for the authenticated user.
     * @summary Create or update the Platform Consumption
     * @param {string} appliesTo 
     * @param {number} [consumptionToAdd] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformConsumptionsApi
     */
    public createOrUpdateMyPlatformConsumption(appliesTo: string, consumptionToAdd?: number, options?: RawAxiosRequestConfig) {
        return PlatformConsumptionsApiFp(this.configuration).createOrUpdateMyPlatformConsumption(appliesTo, consumptionToAdd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the Platform Consumption for the authenticated user.
     * @summary Get the Platform Consumption
     * @param {string} appliesTo 
     * @param {boolean} [includeSubscription] 
     * @param {boolean} [includeLimit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformConsumptionsApi
     */
    public getMyPlatformConsumption(appliesTo: string, includeSubscription?: boolean, includeLimit?: boolean, options?: RawAxiosRequestConfig) {
        return PlatformConsumptionsApiFp(this.configuration).getMyPlatformConsumption(appliesTo, includeSubscription, includeLimit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlatformLimitsApi - axios parameter creator
 * @export
 */
export const PlatformLimitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a platform limit.
         * @summary Create Platform Limit
         * @param {PlatformLimitRequest} platformLimitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlatformLimit: async (platformLimitRequest: PlatformLimitRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'platformLimitRequest' is not null or undefined
            assertParamExists('createPlatformLimit', 'platformLimitRequest', platformLimitRequest)
            const localVarPath = `/platform-limit/limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(platformLimitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a platform limit.
         * @summary Delete Platform Limit
         * @param {number} id Platform Limit id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlatformLimit: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePlatformLimit', 'id', id)
            const localVarPath = `/platform-limit/limits/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a platform limit.
         * @summary Get Platform Limit
         * @param {number} id Platform Limit id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformLimit: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlatformLimit', 'id', id)
            const localVarPath = `/platform-limit/limits/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the platform limits.
         * @summary List Platform Limits
         * @param {Set<ListPlatformLimitsBasedOnInEnum>} [basedOnIn] The type of based on, e.g. &#x60;sku&#x60;.
         * @param {Set<string>} [basedOnValueIn] The based on values.
         * @param {Set<string>} [appliesToIn] The applies to (e.g. API name).
         * @param {Set<ListPlatformLimitsScopeInEnum>} [scopeIn] The scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlatformLimits: async (basedOnIn?: Set<ListPlatformLimitsBasedOnInEnum>, basedOnValueIn?: Set<string>, appliesToIn?: Set<string>, scopeIn?: Set<ListPlatformLimitsScopeInEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/platform-limit/limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (basedOnIn) {
                localVarQueryParameter['based_on_in'] = Array.from(basedOnIn);
            }

            if (basedOnValueIn) {
                localVarQueryParameter['based_on_value_in'] = Array.from(basedOnValueIn);
            }

            if (appliesToIn) {
                localVarQueryParameter['applies_to_in'] = Array.from(appliesToIn);
            }

            if (scopeIn) {
                localVarQueryParameter['scope_in'] = Array.from(scopeIn);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a platform limit.
         * @summary Update Platform Limit
         * @param {number} id Platform Limit id
         * @param {PlatformLimitRequest} platformLimitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlatformLimit: async (id: number, platformLimitRequest: PlatformLimitRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePlatformLimit', 'id', id)
            // verify required parameter 'platformLimitRequest' is not null or undefined
            assertParamExists('updatePlatformLimit', 'platformLimitRequest', platformLimitRequest)
            const localVarPath = `/platform-limit/limits/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(platformLimitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlatformLimitsApi - functional programming interface
 * @export
 */
export const PlatformLimitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlatformLimitsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a platform limit.
         * @summary Create Platform Limit
         * @param {PlatformLimitRequest} platformLimitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlatformLimit(platformLimitRequest: PlatformLimitRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformLimit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlatformLimit(platformLimitRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlatformLimitsApi.createPlatformLimit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a platform limit.
         * @summary Delete Platform Limit
         * @param {number} id Platform Limit id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlatformLimit(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlatformLimit(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlatformLimitsApi.deletePlatformLimit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a platform limit.
         * @summary Get Platform Limit
         * @param {number} id Platform Limit id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlatformLimit(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformLimit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlatformLimit(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlatformLimitsApi.getPlatformLimit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the platform limits.
         * @summary List Platform Limits
         * @param {Set<ListPlatformLimitsBasedOnInEnum>} [basedOnIn] The type of based on, e.g. &#x60;sku&#x60;.
         * @param {Set<string>} [basedOnValueIn] The based on values.
         * @param {Set<string>} [appliesToIn] The applies to (e.g. API name).
         * @param {Set<ListPlatformLimitsScopeInEnum>} [scopeIn] The scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlatformLimits(basedOnIn?: Set<ListPlatformLimitsBasedOnInEnum>, basedOnValueIn?: Set<string>, appliesToIn?: Set<string>, scopeIn?: Set<ListPlatformLimitsScopeInEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagePlatformLimit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPlatformLimits(basedOnIn, basedOnValueIn, appliesToIn, scopeIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlatformLimitsApi.listPlatformLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a platform limit.
         * @summary Update Platform Limit
         * @param {number} id Platform Limit id
         * @param {PlatformLimitRequest} platformLimitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlatformLimit(id: number, platformLimitRequest: PlatformLimitRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformLimit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlatformLimit(id, platformLimitRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlatformLimitsApi.updatePlatformLimit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlatformLimitsApi - factory interface
 * @export
 */
export const PlatformLimitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlatformLimitsApiFp(configuration)
    return {
        /**
         * Create a platform limit.
         * @summary Create Platform Limit
         * @param {PlatformLimitRequest} platformLimitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlatformLimit(platformLimitRequest: PlatformLimitRequest, options?: RawAxiosRequestConfig): AxiosPromise<PlatformLimit> {
            return localVarFp.createPlatformLimit(platformLimitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a platform limit.
         * @summary Delete Platform Limit
         * @param {number} id Platform Limit id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlatformLimit(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePlatformLimit(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a platform limit.
         * @summary Get Platform Limit
         * @param {number} id Platform Limit id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformLimit(id: number, options?: RawAxiosRequestConfig): AxiosPromise<PlatformLimit> {
            return localVarFp.getPlatformLimit(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List the platform limits.
         * @summary List Platform Limits
         * @param {Set<ListPlatformLimitsBasedOnInEnum>} [basedOnIn] The type of based on, e.g. &#x60;sku&#x60;.
         * @param {Set<string>} [basedOnValueIn] The based on values.
         * @param {Set<string>} [appliesToIn] The applies to (e.g. API name).
         * @param {Set<ListPlatformLimitsScopeInEnum>} [scopeIn] The scope.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlatformLimits(basedOnIn?: Set<ListPlatformLimitsBasedOnInEnum>, basedOnValueIn?: Set<string>, appliesToIn?: Set<string>, scopeIn?: Set<ListPlatformLimitsScopeInEnum>, options?: RawAxiosRequestConfig): AxiosPromise<PagePlatformLimit> {
            return localVarFp.listPlatformLimits(basedOnIn, basedOnValueIn, appliesToIn, scopeIn, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a platform limit.
         * @summary Update Platform Limit
         * @param {number} id Platform Limit id
         * @param {PlatformLimitRequest} platformLimitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlatformLimit(id: number, platformLimitRequest: PlatformLimitRequest, options?: RawAxiosRequestConfig): AxiosPromise<PlatformLimit> {
            return localVarFp.updatePlatformLimit(id, platformLimitRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlatformLimitsApi - object-oriented interface
 * @export
 * @class PlatformLimitsApi
 * @extends {BaseAPI}
 */
export class PlatformLimitsApi extends BaseAPI {
    /**
     * Create a platform limit.
     * @summary Create Platform Limit
     * @param {PlatformLimitRequest} platformLimitRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformLimitsApi
     */
    public createPlatformLimit(platformLimitRequest: PlatformLimitRequest, options?: RawAxiosRequestConfig) {
        return PlatformLimitsApiFp(this.configuration).createPlatformLimit(platformLimitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a platform limit.
     * @summary Delete Platform Limit
     * @param {number} id Platform Limit id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformLimitsApi
     */
    public deletePlatformLimit(id: number, options?: RawAxiosRequestConfig) {
        return PlatformLimitsApiFp(this.configuration).deletePlatformLimit(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a platform limit.
     * @summary Get Platform Limit
     * @param {number} id Platform Limit id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformLimitsApi
     */
    public getPlatformLimit(id: number, options?: RawAxiosRequestConfig) {
        return PlatformLimitsApiFp(this.configuration).getPlatformLimit(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the platform limits.
     * @summary List Platform Limits
     * @param {Set<ListPlatformLimitsBasedOnInEnum>} [basedOnIn] The type of based on, e.g. &#x60;sku&#x60;.
     * @param {Set<string>} [basedOnValueIn] The based on values.
     * @param {Set<string>} [appliesToIn] The applies to (e.g. API name).
     * @param {Set<ListPlatformLimitsScopeInEnum>} [scopeIn] The scope.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformLimitsApi
     */
    public listPlatformLimits(basedOnIn?: Set<ListPlatformLimitsBasedOnInEnum>, basedOnValueIn?: Set<string>, appliesToIn?: Set<string>, scopeIn?: Set<ListPlatformLimitsScopeInEnum>, options?: RawAxiosRequestConfig) {
        return PlatformLimitsApiFp(this.configuration).listPlatformLimits(basedOnIn, basedOnValueIn, appliesToIn, scopeIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a platform limit.
     * @summary Update Platform Limit
     * @param {number} id Platform Limit id
     * @param {PlatformLimitRequest} platformLimitRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformLimitsApi
     */
    public updatePlatformLimit(id: number, platformLimitRequest: PlatformLimitRequest, options?: RawAxiosRequestConfig) {
        return PlatformLimitsApiFp(this.configuration).updatePlatformLimit(id, platformLimitRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ListPlatformLimitsBasedOnInEnum = {
    Sku: 'SKU'
} as const;
export type ListPlatformLimitsBasedOnInEnum = typeof ListPlatformLimitsBasedOnInEnum[keyof typeof ListPlatformLimitsBasedOnInEnum];
/**
 * @export
 */
export const ListPlatformLimitsScopeInEnum = {
    Account: 'ACCOUNT',
    Subscription: 'SUBSCRIPTION'
} as const;
export type ListPlatformLimitsScopeInEnum = typeof ListPlatformLimitsScopeInEnum[keyof typeof ListPlatformLimitsScopeInEnum];


/**
 * PluginDiagnosticsApi - axios parameter creator
 * @export
 */
export const PluginDiagnosticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Replace the list of the plugins for the current account with the one provided by the client
         * @summary Update
         * @param {Account} account 
         * @param {Array<DiagnosticPluginRequest>} diagnosticPluginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiagnosticPluginCollection: async (account: Account, diagnosticPluginRequest: Array<DiagnosticPluginRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            assertParamExists('updateDiagnosticPluginCollection', 'account', account)
            // verify required parameter 'diagnosticPluginRequest' is not null or undefined
            assertParamExists('updateDiagnosticPluginCollection', 'diagnosticPluginRequest', diagnosticPluginRequest)
            const localVarPath = `/accounts/me/plugin/diagnostics/plugins-collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (account !== undefined) {
                for (const [key, value] of Object.entries(account)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(diagnosticPluginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluginDiagnosticsApi - functional programming interface
 * @export
 */
export const PluginDiagnosticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PluginDiagnosticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Replace the list of the plugins for the current account with the one provided by the client
         * @summary Update
         * @param {Account} account 
         * @param {Array<DiagnosticPluginRequest>} diagnosticPluginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDiagnosticPluginCollection(account: Account, diagnosticPluginRequest: Array<DiagnosticPluginRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDiagnosticPluginCollection(account, diagnosticPluginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginDiagnosticsApi.updateDiagnosticPluginCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PluginDiagnosticsApi - factory interface
 * @export
 */
export const PluginDiagnosticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PluginDiagnosticsApiFp(configuration)
    return {
        /**
         * Replace the list of the plugins for the current account with the one provided by the client
         * @summary Update
         * @param {Account} account 
         * @param {Array<DiagnosticPluginRequest>} diagnosticPluginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiagnosticPluginCollection(account: Account, diagnosticPluginRequest: Array<DiagnosticPluginRequest>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDiagnosticPluginCollection(account, diagnosticPluginRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PluginDiagnosticsApi - object-oriented interface
 * @export
 * @class PluginDiagnosticsApi
 * @extends {BaseAPI}
 */
export class PluginDiagnosticsApi extends BaseAPI {
    /**
     * Replace the list of the plugins for the current account with the one provided by the client
     * @summary Update
     * @param {Account} account 
     * @param {Array<DiagnosticPluginRequest>} diagnosticPluginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginDiagnosticsApi
     */
    public updateDiagnosticPluginCollection(account: Account, diagnosticPluginRequest: Array<DiagnosticPluginRequest>, options?: RawAxiosRequestConfig) {
        return PluginDiagnosticsApiFp(this.configuration).updateDiagnosticPluginCollection(account, diagnosticPluginRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PluginEventsApi - axios parameter creator
 * @export
 */
export const PluginEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an event
         * @summary Create
         * @param {Request1} request1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent: async (request1: Request1, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request1' is not null or undefined
            assertParamExists('createEvent', 'request1', request1)
            const localVarPath = `/plugin/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request1, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List the events bound to the authenticated account.
         * @summary List
         * @param {Set<string>} [url] URLs to return
         * @param {string} [dateGreaterThan] Event datetime filter to return events with date greater than the parameter
         * @param {string} [dateLessThan] Event datetime filter to return events with date less than the parameter
         * @param {string} [cursor] The pagination cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents: async (url?: Set<string>, dateGreaterThan?: string, dateLessThan?: string, cursor?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/plugin/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (url) {
                localVarQueryParameter['url'] = Array.from(url);
            }

            if (dateGreaterThan !== undefined) {
                localVarQueryParameter['date_greater_than'] = (dateGreaterThan as any instanceof Date) ?
                    (dateGreaterThan as any).toISOString() :
                    dateGreaterThan;
            }

            if (dateLessThan !== undefined) {
                localVarQueryParameter['date_less_than'] = (dateLessThan as any instanceof Date) ?
                    (dateLessThan as any).toISOString() :
                    dateLessThan;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluginEventsApi - functional programming interface
 * @export
 */
export const PluginEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PluginEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an event
         * @summary Create
         * @param {Request1} request1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEvent(request1: Request1, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEvent(request1, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginEventsApi.createEvent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List the events bound to the authenticated account.
         * @summary List
         * @param {Set<string>} [url] URLs to return
         * @param {string} [dateGreaterThan] Event datetime filter to return events with date greater than the parameter
         * @param {string} [dateLessThan] Event datetime filter to return events with date less than the parameter
         * @param {string} [cursor] The pagination cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEvents(url?: Set<string>, dateGreaterThan?: string, dateLessThan?: string, cursor?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listEvents(url, dateGreaterThan, dateLessThan, cursor, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginEventsApi.listEvents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PluginEventsApi - factory interface
 * @export
 */
export const PluginEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PluginEventsApiFp(configuration)
    return {
        /**
         * Create an event
         * @summary Create
         * @param {Request1} request1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(request1: Request1, options?: RawAxiosRequestConfig): AxiosPromise<Event> {
            return localVarFp.createEvent(request1, options).then((request) => request(axios, basePath));
        },
        /**
         * List the events bound to the authenticated account.
         * @summary List
         * @param {Set<string>} [url] URLs to return
         * @param {string} [dateGreaterThan] Event datetime filter to return events with date greater than the parameter
         * @param {string} [dateLessThan] Event datetime filter to return events with date less than the parameter
         * @param {string} [cursor] The pagination cursor
         * @param {number} [limit] The maximum number of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEvents(url?: Set<string>, dateGreaterThan?: string, dateLessThan?: string, cursor?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Response1> {
            return localVarFp.listEvents(url, dateGreaterThan, dateLessThan, cursor, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PluginEventsApi - object-oriented interface
 * @export
 * @class PluginEventsApi
 * @extends {BaseAPI}
 */
export class PluginEventsApi extends BaseAPI {
    /**
     * Create an event
     * @summary Create
     * @param {Request1} request1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginEventsApi
     */
    public createEvent(request1: Request1, options?: RawAxiosRequestConfig) {
        return PluginEventsApiFp(this.configuration).createEvent(request1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List the events bound to the authenticated account.
     * @summary List
     * @param {Set<string>} [url] URLs to return
     * @param {string} [dateGreaterThan] Event datetime filter to return events with date greater than the parameter
     * @param {string} [dateLessThan] Event datetime filter to return events with date less than the parameter
     * @param {string} [cursor] The pagination cursor
     * @param {number} [limit] The maximum number of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginEventsApi
     */
    public listEvents(url?: Set<string>, dateGreaterThan?: string, dateLessThan?: string, cursor?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return PluginEventsApiFp(this.configuration).listEvents(url, dateGreaterThan, dateLessThan, cursor, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QuestionsAndAnswersApi - axios parameter creator
 * @export
 */
export const QuestionsAndAnswersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create
         * @param {QuestionAndAnswerRequest} questionAndAnswerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestionAndAnswer: async (questionAndAnswerRequest: QuestionAndAnswerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionAndAnswerRequest' is not null or undefined
            assertParamExists('createQuestionAndAnswer', 'questionAndAnswerRequest', questionAndAnswerRequest)
            const localVarPath = `/questions-and-answers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionAndAnswerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create
         * @param {SmartContentRequest} smartContentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestionsAndAnswersCollection: async (smartContentRequest: SmartContentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'smartContentRequest' is not null or undefined
            assertParamExists('createQuestionsAndAnswersCollection', 'smartContentRequest', smartContentRequest)
            const localVarPath = `/questions-and-answers-collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(smartContentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestionAndAnswer: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteQuestionAndAnswer', 'id', id)
            const localVarPath = `/questions-and-answers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete
         * @param {number} smartContentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestionsAndAnswersCollection: async (smartContentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'smartContentId' is not null or undefined
            assertParamExists('deleteQuestionsAndAnswersCollection', 'smartContentId', smartContentId)
            const localVarPath = `/questions-and-answers-collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (smartContentId !== undefined) {
                localVarQueryParameter['smart_content_id'] = smartContentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get
         * @param {number} [accountId] The account id.
         * @param {string} [iri] The webpage IRI
         * @param {number} [smartContentId] The smart content id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionsAndAnswers: async (accountId?: number, iri?: string, smartContentId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/questions-and-answers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (iri !== undefined) {
                localVarQueryParameter['iri'] = iri;
            }

            if (smartContentId !== undefined) {
                localVarQueryParameter['smart_content_id'] = smartContentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update
         * @param {number} id 
         * @param {UpdateQuestionAndAnswerRequest} updateQuestionAndAnswerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestionAndAnswer: async (id: number, updateQuestionAndAnswerRequest: UpdateQuestionAndAnswerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateQuestionAndAnswer', 'id', id)
            // verify required parameter 'updateQuestionAndAnswerRequest' is not null or undefined
            assertParamExists('updateQuestionAndAnswer', 'updateQuestionAndAnswerRequest', updateQuestionAndAnswerRequest)
            const localVarPath = `/questions-and-answers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateQuestionAndAnswerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update
         * @param {QuestionAndAnswerRequest} questionAndAnswerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestionsAndAnswersCollection: async (questionAndAnswerRequest: QuestionAndAnswerRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'questionAndAnswerRequest' is not null or undefined
            assertParamExists('updateQuestionsAndAnswersCollection', 'questionAndAnswerRequest', questionAndAnswerRequest)
            const localVarPath = `/questions-and-answers-collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(questionAndAnswerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuestionsAndAnswersApi - functional programming interface
 * @export
 */
export const QuestionsAndAnswersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuestionsAndAnswersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {QuestionAndAnswerRequest} questionAndAnswerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuestionAndAnswer(questionAndAnswerRequest: QuestionAndAnswerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionAndAnswer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuestionAndAnswer(questionAndAnswerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionsAndAnswersApi.createQuestionAndAnswer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create
         * @param {SmartContentRequest} smartContentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuestionsAndAnswersCollection(smartContentRequest: SmartContentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SmartContent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuestionsAndAnswersCollection(smartContentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionsAndAnswersApi.createQuestionsAndAnswersCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteQuestionAndAnswer(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteQuestionAndAnswer(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionsAndAnswersApi.deleteQuestionAndAnswer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete
         * @param {number} smartContentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteQuestionsAndAnswersCollection(smartContentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteQuestionsAndAnswersCollection(smartContentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionsAndAnswersApi.deleteQuestionsAndAnswersCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get
         * @param {number} [accountId] The account id.
         * @param {string} [iri] The webpage IRI
         * @param {number} [smartContentId] The smart content id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuestionsAndAnswers(accountId?: number, iri?: string, smartContentId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionAndAnswer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuestionsAndAnswers(accountId, iri, smartContentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionsAndAnswersApi.getQuestionsAndAnswers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update
         * @param {number} id 
         * @param {UpdateQuestionAndAnswerRequest} updateQuestionAndAnswerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateQuestionAndAnswer(id: number, updateQuestionAndAnswerRequest: UpdateQuestionAndAnswerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuestionAndAnswer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateQuestionAndAnswer(id, updateQuestionAndAnswerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionsAndAnswersApi.updateQuestionAndAnswer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update
         * @param {QuestionAndAnswerRequest} questionAndAnswerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateQuestionsAndAnswersCollection(questionAndAnswerRequest: QuestionAndAnswerRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<QuestionAndAnswer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateQuestionsAndAnswersCollection(questionAndAnswerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuestionsAndAnswersApi.updateQuestionsAndAnswersCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QuestionsAndAnswersApi - factory interface
 * @export
 */
export const QuestionsAndAnswersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuestionsAndAnswersApiFp(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {QuestionAndAnswerRequest} questionAndAnswerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestionAndAnswer(questionAndAnswerRequest: QuestionAndAnswerRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuestionAndAnswer> {
            return localVarFp.createQuestionAndAnswer(questionAndAnswerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create
         * @param {SmartContentRequest} smartContentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestionsAndAnswersCollection(smartContentRequest: SmartContentRequest, options?: RawAxiosRequestConfig): AxiosPromise<SmartContent> {
            return localVarFp.createQuestionsAndAnswersCollection(smartContentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestionAndAnswer(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteQuestionAndAnswer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete
         * @param {number} smartContentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestionsAndAnswersCollection(smartContentId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteQuestionsAndAnswersCollection(smartContentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get
         * @param {number} [accountId] The account id.
         * @param {string} [iri] The webpage IRI
         * @param {number} [smartContentId] The smart content id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionsAndAnswers(accountId?: number, iri?: string, smartContentId?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<QuestionAndAnswer>> {
            return localVarFp.getQuestionsAndAnswers(accountId, iri, smartContentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update
         * @param {number} id 
         * @param {UpdateQuestionAndAnswerRequest} updateQuestionAndAnswerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestionAndAnswer(id: number, updateQuestionAndAnswerRequest: UpdateQuestionAndAnswerRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuestionAndAnswer> {
            return localVarFp.updateQuestionAndAnswer(id, updateQuestionAndAnswerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update
         * @param {QuestionAndAnswerRequest} questionAndAnswerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuestionsAndAnswersCollection(questionAndAnswerRequest: QuestionAndAnswerRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<QuestionAndAnswer>> {
            return localVarFp.updateQuestionsAndAnswersCollection(questionAndAnswerRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuestionsAndAnswersApi - object-oriented interface
 * @export
 * @class QuestionsAndAnswersApi
 * @extends {BaseAPI}
 */
export class QuestionsAndAnswersApi extends BaseAPI {
    /**
     * 
     * @summary Create
     * @param {QuestionAndAnswerRequest} questionAndAnswerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsAndAnswersApi
     */
    public createQuestionAndAnswer(questionAndAnswerRequest: QuestionAndAnswerRequest, options?: RawAxiosRequestConfig) {
        return QuestionsAndAnswersApiFp(this.configuration).createQuestionAndAnswer(questionAndAnswerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create
     * @param {SmartContentRequest} smartContentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsAndAnswersApi
     */
    public createQuestionsAndAnswersCollection(smartContentRequest: SmartContentRequest, options?: RawAxiosRequestConfig) {
        return QuestionsAndAnswersApiFp(this.configuration).createQuestionsAndAnswersCollection(smartContentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsAndAnswersApi
     */
    public deleteQuestionAndAnswer(id: number, options?: RawAxiosRequestConfig) {
        return QuestionsAndAnswersApiFp(this.configuration).deleteQuestionAndAnswer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete
     * @param {number} smartContentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsAndAnswersApi
     */
    public deleteQuestionsAndAnswersCollection(smartContentId: number, options?: RawAxiosRequestConfig) {
        return QuestionsAndAnswersApiFp(this.configuration).deleteQuestionsAndAnswersCollection(smartContentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get
     * @param {number} [accountId] The account id.
     * @param {string} [iri] The webpage IRI
     * @param {number} [smartContentId] The smart content id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsAndAnswersApi
     */
    public getQuestionsAndAnswers(accountId?: number, iri?: string, smartContentId?: number, options?: RawAxiosRequestConfig) {
        return QuestionsAndAnswersApiFp(this.configuration).getQuestionsAndAnswers(accountId, iri, smartContentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update
     * @param {number} id 
     * @param {UpdateQuestionAndAnswerRequest} updateQuestionAndAnswerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsAndAnswersApi
     */
    public updateQuestionAndAnswer(id: number, updateQuestionAndAnswerRequest: UpdateQuestionAndAnswerRequest, options?: RawAxiosRequestConfig) {
        return QuestionsAndAnswersApiFp(this.configuration).updateQuestionAndAnswer(id, updateQuestionAndAnswerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update
     * @param {QuestionAndAnswerRequest} questionAndAnswerRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionsAndAnswersApi
     */
    public updateQuestionsAndAnswersCollection(questionAndAnswerRequest: QuestionAndAnswerRequest, options?: RawAxiosRequestConfig) {
        return QuestionsAndAnswersApiFp(this.configuration).updateQuestionsAndAnswersCollection(questionAndAnswerRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RedeemCodesApi - axios parameter creator
 * @export
 */
export const RedeemCodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Redeem the provided code and get a key
         * @param {Request2} request2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeemCode: async (request2: Request2, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'request2' is not null or undefined
            assertParamExists('redeemCode', 'request2', request2)
            const localVarPath = `/redeem-codes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(request2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RedeemCodesApi - functional programming interface
 * @export
 */
export const RedeemCodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RedeemCodesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Redeem the provided code and get a key
         * @param {Request2} request2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redeemCode(request2: Request2, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Response2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redeemCode(request2, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RedeemCodesApi.redeemCode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RedeemCodesApi - factory interface
 * @export
 */
export const RedeemCodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RedeemCodesApiFp(configuration)
    return {
        /**
         * 
         * @summary Redeem the provided code and get a key
         * @param {Request2} request2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeemCode(request2: Request2, options?: RawAxiosRequestConfig): AxiosPromise<Response2> {
            return localVarFp.redeemCode(request2, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RedeemCodesApi - object-oriented interface
 * @export
 * @class RedeemCodesApi
 * @extends {BaseAPI}
 */
export class RedeemCodesApi extends BaseAPI {
    /**
     * 
     * @summary Redeem the provided code and get a key
     * @param {Request2} request2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RedeemCodesApi
     */
    public redeemCode(request2: Request2, options?: RawAxiosRequestConfig) {
        return RedeemCodesApiFp(this.configuration).redeemCode(request2, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RulesApi - axios parameter creator
 * @export
 */
export const RulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Copy
         * @param {ProjectType} projectType The project type
         * @param {number} fromProjectId The source Content Generation id.
         * @param {number} toProjectId The target Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyRules: async (projectType: ProjectType, fromProjectId: number, toProjectId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectType' is not null or undefined
            assertParamExists('copyRules', 'projectType', projectType)
            // verify required parameter 'fromProjectId' is not null or undefined
            assertParamExists('copyRules', 'fromProjectId', fromProjectId)
            // verify required parameter 'toProjectId' is not null or undefined
            assertParamExists('copyRules', 'toProjectId', toProjectId)
            const localVarPath = `/rules/copies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projectType !== undefined) {
                localVarQueryParameter['project_type'] = projectType;
            }

            if (fromProjectId !== undefined) {
                localVarQueryParameter['from_project_id'] = fromProjectId;
            }

            if (toProjectId !== undefined) {
                localVarQueryParameter['to_project_id'] = toProjectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create
         * @param {RuleRequest} ruleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRule: async (ruleRequest: RuleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleRequest' is not null or undefined
            assertParamExists('createRule', 'ruleRequest', ruleRequest)
            const localVarPath = `/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete
         * @param {number} id The id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRule', 'id', id)
            const localVarPath = `/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {number} [projectId] The project id - if provided, must also provide the project type
         * @param {ProjectType} [projectType] The project type - if provided, must also provide the project id
         * @param {Scope} [scope] The scope
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRules: async (cursor?: string, limit?: number, projectId?: number, projectType?: ProjectType, scope?: Scope, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (projectType !== undefined) {
                localVarQueryParameter['project_type'] = projectType;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update
         * @param {number} id The id
         * @param {RuleRequest} ruleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRule: async (id: number, ruleRequest: RuleRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRule', 'id', id)
            // verify required parameter 'ruleRequest' is not null or undefined
            assertParamExists('updateRule', 'ruleRequest', ruleRequest)
            const localVarPath = `/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update
         * @param {number} projectId The project id
         * @param {ProjectType} projectType The project type
         * @param {Array<RuleRequest>} ruleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRuleCollection: async (projectId: number, projectType: ProjectType, ruleRequest: Array<RuleRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateRuleCollection', 'projectId', projectId)
            // verify required parameter 'projectType' is not null or undefined
            assertParamExists('updateRuleCollection', 'projectType', projectType)
            // verify required parameter 'ruleRequest' is not null or undefined
            assertParamExists('updateRuleCollection', 'ruleRequest', ruleRequest)
            const localVarPath = `/rules-collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (projectType !== undefined) {
                localVarQueryParameter['project_type'] = projectType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulesApi - functional programming interface
 * @export
 */
export const RulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Copy
         * @param {ProjectType} projectType The project type
         * @param {number} fromProjectId The source Content Generation id.
         * @param {number} toProjectId The target Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async copyRules(projectType: ProjectType, fromProjectId: number, toProjectId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.copyRules(projectType, fromProjectId, toProjectId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.copyRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create
         * @param {RuleRequest} ruleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRule(ruleRequest: RuleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRule(ruleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.createRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete
         * @param {number} id The id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRule(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRule(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.deleteRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {number} [projectId] The project id - if provided, must also provide the project type
         * @param {ProjectType} [projectType] The project type - if provided, must also provide the project id
         * @param {Scope} [scope] The scope
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRules(cursor?: string, limit?: number, projectId?: number, projectType?: ProjectType, scope?: Scope, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRules(cursor, limit, projectId, projectType, scope, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.listRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update
         * @param {number} id The id
         * @param {RuleRequest} ruleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRule(id: number, ruleRequest: RuleRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRule(id, ruleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.updateRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update
         * @param {number} projectId The project id
         * @param {ProjectType} projectType The project type
         * @param {Array<RuleRequest>} ruleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRuleCollection(projectId: number, projectType: ProjectType, ruleRequest: Array<RuleRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Rule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRuleCollection(projectId, projectType, ruleRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.updateRuleCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RulesApi - factory interface
 * @export
 */
export const RulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RulesApiFp(configuration)
    return {
        /**
         * 
         * @summary Copy
         * @param {ProjectType} projectType The project type
         * @param {number} fromProjectId The source Content Generation id.
         * @param {number} toProjectId The target Content Generation id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyRules(projectType: ProjectType, fromProjectId: number, toProjectId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.copyRules(projectType, fromProjectId, toProjectId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create
         * @param {RuleRequest} ruleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRule(ruleRequest: RuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Rule> {
            return localVarFp.createRule(ruleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete
         * @param {number} id The id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRule(id: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List
         * @param {string} [cursor] The cursor
         * @param {number} [limit] The maximum number of results
         * @param {number} [projectId] The project id - if provided, must also provide the project type
         * @param {ProjectType} [projectType] The project type - if provided, must also provide the project id
         * @param {Scope} [scope] The scope
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRules(cursor?: string, limit?: number, projectId?: number, projectType?: ProjectType, scope?: Scope, options?: RawAxiosRequestConfig): AxiosPromise<PageRule> {
            return localVarFp.listRules(cursor, limit, projectId, projectType, scope, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update
         * @param {number} id The id
         * @param {RuleRequest} ruleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRule(id: number, ruleRequest: RuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Rule> {
            return localVarFp.updateRule(id, ruleRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update
         * @param {number} projectId The project id
         * @param {ProjectType} projectType The project type
         * @param {Array<RuleRequest>} ruleRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRuleCollection(projectId: number, projectType: ProjectType, ruleRequest: Array<RuleRequest>, options?: RawAxiosRequestConfig): AxiosPromise<Array<Rule>> {
            return localVarFp.updateRuleCollection(projectId, projectType, ruleRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RulesApi - object-oriented interface
 * @export
 * @class RulesApi
 * @extends {BaseAPI}
 */
export class RulesApi extends BaseAPI {
    /**
     * 
     * @summary Copy
     * @param {ProjectType} projectType The project type
     * @param {number} fromProjectId The source Content Generation id.
     * @param {number} toProjectId The target Content Generation id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public copyRules(projectType: ProjectType, fromProjectId: number, toProjectId: number, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).copyRules(projectType, fromProjectId, toProjectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create
     * @param {RuleRequest} ruleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public createRule(ruleRequest: RuleRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).createRule(ruleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete
     * @param {number} id The id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public deleteRule(id: number, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).deleteRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List
     * @param {string} [cursor] The cursor
     * @param {number} [limit] The maximum number of results
     * @param {number} [projectId] The project id - if provided, must also provide the project type
     * @param {ProjectType} [projectType] The project type - if provided, must also provide the project id
     * @param {Scope} [scope] The scope
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public listRules(cursor?: string, limit?: number, projectId?: number, projectType?: ProjectType, scope?: Scope, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).listRules(cursor, limit, projectId, projectType, scope, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update
     * @param {number} id The id
     * @param {RuleRequest} ruleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public updateRule(id: number, ruleRequest: RuleRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).updateRule(id, ruleRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update
     * @param {number} projectId The project id
     * @param {ProjectType} projectType The project type
     * @param {Array<RuleRequest>} ruleRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RulesApi
     */
    public updateRuleCollection(projectId: number, projectType: ProjectType, ruleRequest: Array<RuleRequest>, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).updateRuleCollection(projectId, projectType, ruleRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SEOScoresApi - axios parameter creator
 * @export
 */
export const SEOScoresApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create
         * @param {CreateSEOScoreRequest} createSEOScoreRequest body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSEOScore: async (createSEOScoreRequest: CreateSEOScoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSEOScoreRequest' is not null or undefined
            assertParamExists('createSEOScore', 'createSEOScoreRequest', createSEOScoreRequest)
            const localVarPath = `/score`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSEOScoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SEOScoresApi - functional programming interface
 * @export
 */
export const SEOScoresApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SEOScoresApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {CreateSEOScoreRequest} createSEOScoreRequest body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSEOScore(createSEOScoreRequest: CreateSEOScoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSEOScore200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSEOScore(createSEOScoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SEOScoresApi.createSEOScore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SEOScoresApi - factory interface
 * @export
 */
export const SEOScoresApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SEOScoresApiFp(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {CreateSEOScoreRequest} createSEOScoreRequest body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSEOScore(createSEOScoreRequest: CreateSEOScoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateSEOScore200Response> {
            return localVarFp.createSEOScore(createSEOScoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SEOScoresApi - object-oriented interface
 * @export
 * @class SEOScoresApi
 * @extends {BaseAPI}
 */
export class SEOScoresApi extends BaseAPI {
    /**
     * 
     * @summary Create
     * @param {CreateSEOScoreRequest} createSEOScoreRequest body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SEOScoresApi
     */
    public createSEOScore(createSEOScoreRequest: CreateSEOScoreRequest, options?: RawAxiosRequestConfig) {
        return SEOScoresApiFp(this.configuration).createSEOScore(createSEOScoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SitemapGeneratorApi - axios parameter creator
 * @export
 */
export const SitemapGeneratorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates a sitemap from a GraphQL query to WordLift KG. You must provide a valid GraphQL query as the request body. 
         * @summary Generate Sitemap
         * @param {GenerateSitemapRequest} generateSitemapRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSitemap: async (generateSitemapRequest: GenerateSitemapRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateSitemapRequest' is not null or undefined
            assertParamExists('generateSitemap', 'generateSitemapRequest', generateSitemapRequest)
            const localVarPath = `/build`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateSitemapRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SitemapGeneratorApi - functional programming interface
 * @export
 */
export const SitemapGeneratorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SitemapGeneratorApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates a sitemap from a GraphQL query to WordLift KG. You must provide a valid GraphQL query as the request body. 
         * @summary Generate Sitemap
         * @param {GenerateSitemapRequest} generateSitemapRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateSitemap(generateSitemapRequest: GenerateSitemapRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateSitemap200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateSitemap(generateSitemapRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SitemapGeneratorApi.generateSitemap']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SitemapGeneratorApi - factory interface
 * @export
 */
export const SitemapGeneratorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SitemapGeneratorApiFp(configuration)
    return {
        /**
         * Generates a sitemap from a GraphQL query to WordLift KG. You must provide a valid GraphQL query as the request body. 
         * @summary Generate Sitemap
         * @param {GenerateSitemapRequest} generateSitemapRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateSitemap(generateSitemapRequest: GenerateSitemapRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenerateSitemap200Response> {
            return localVarFp.generateSitemap(generateSitemapRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SitemapGeneratorApi - object-oriented interface
 * @export
 * @class SitemapGeneratorApi
 * @extends {BaseAPI}
 */
export class SitemapGeneratorApi extends BaseAPI {
    /**
     * Generates a sitemap from a GraphQL query to WordLift KG. You must provide a valid GraphQL query as the request body. 
     * @summary Generate Sitemap
     * @param {GenerateSitemapRequest} generateSitemapRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitemapGeneratorApi
     */
    public generateSitemap(generateSitemapRequest: GenerateSitemapRequest, options?: RawAxiosRequestConfig) {
        return SitemapGeneratorApiFp(this.configuration).generateSitemap(generateSitemapRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SitemapImportsApi - axios parameter creator
 * @export
 */
export const SitemapImportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a Sitemap Import
         * @summary Create
         * @param {SitemapImportRequest} sitemapImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSitemapImport: async (sitemapImportRequest: SitemapImportRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sitemapImportRequest' is not null or undefined
            assertParamExists('createSitemapImport', 'sitemapImportRequest', sitemapImportRequest)
            const localVarPath = `/sitemap-imports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sitemapImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SitemapImportsApi - functional programming interface
 * @export
 */
export const SitemapImportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SitemapImportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a Sitemap Import
         * @summary Create
         * @param {SitemapImportRequest} sitemapImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSitemapImport(sitemapImportRequest: SitemapImportRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSitemapImport(sitemapImportRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SitemapImportsApi.createSitemapImport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SitemapImportsApi - factory interface
 * @export
 */
export const SitemapImportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SitemapImportsApiFp(configuration)
    return {
        /**
         * Create a Sitemap Import
         * @summary Create
         * @param {SitemapImportRequest} sitemapImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSitemapImport(sitemapImportRequest: SitemapImportRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.createSitemapImport(sitemapImportRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SitemapImportsApi - object-oriented interface
 * @export
 * @class SitemapImportsApi
 * @extends {BaseAPI}
 */
export class SitemapImportsApi extends BaseAPI {
    /**
     * Create a Sitemap Import
     * @summary Create
     * @param {SitemapImportRequest} sitemapImportRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SitemapImportsApi
     */
    public createSitemapImport(sitemapImportRequest: SitemapImportRequest, options?: RawAxiosRequestConfig) {
        return SitemapImportsApiFp(this.configuration).createSitemapImport(sitemapImportRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SummarizationsApi - axios parameter creator
 * @export
 */
export const SummarizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create
         * @param {string} body body
         * @param {number} [maxLength] Maximum text length
         * @param {number} [minLength] Minimum text length
         * @param {number} [ratio] Ratio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        microdataToJsonLdUsingPOST: async (body: string, maxLength?: number, minLength?: number, ratio?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('microdataToJsonLdUsingPOST', 'body', body)
            const localVarPath = `/summarize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (maxLength !== undefined) {
                localVarQueryParameter['max_length'] = maxLength;
            }

            if (minLength !== undefined) {
                localVarQueryParameter['min_length'] = minLength;
            }

            if (ratio !== undefined) {
                localVarQueryParameter['ratio'] = ratio;
            }


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SummarizationsApi - functional programming interface
 * @export
 */
export const SummarizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SummarizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {string} body body
         * @param {number} [maxLength] Maximum text length
         * @param {number} [minLength] Minimum text length
         * @param {number} [ratio] Ratio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async microdataToJsonLdUsingPOST(body: string, maxLength?: number, minLength?: number, ratio?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.microdataToJsonLdUsingPOST(body, maxLength, minLength, ratio, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SummarizationsApi.microdataToJsonLdUsingPOST']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SummarizationsApi - factory interface
 * @export
 */
export const SummarizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SummarizationsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {string} body body
         * @param {number} [maxLength] Maximum text length
         * @param {number} [minLength] Minimum text length
         * @param {number} [ratio] Ratio
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        microdataToJsonLdUsingPOST(body: string, maxLength?: number, minLength?: number, ratio?: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.microdataToJsonLdUsingPOST(body, maxLength, minLength, ratio, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SummarizationsApi - object-oriented interface
 * @export
 * @class SummarizationsApi
 * @extends {BaseAPI}
 */
export class SummarizationsApi extends BaseAPI {
    /**
     * 
     * @summary Create
     * @param {string} body body
     * @param {number} [maxLength] Maximum text length
     * @param {number} [minLength] Minimum text length
     * @param {number} [ratio] Ratio
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SummarizationsApi
     */
    public microdataToJsonLdUsingPOST(body: string, maxLength?: number, minLength?: number, ratio?: number, options?: RawAxiosRequestConfig) {
        return SummarizationsApiFp(this.configuration).microdataToJsonLdUsingPOST(body, maxLength, minLength, ratio, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VectorSearchNodesApi - axios parameter creator
 * @export
 */
export const VectorSearchNodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update
         * @param {Array<NodeRequest>} nodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodesCollection: async (nodeRequest: Array<NodeRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeRequest' is not null or undefined
            assertParamExists('updateNodesCollection', 'nodeRequest', nodeRequest)
            const localVarPath = `/vector-search/nodes-collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VectorSearchNodesApi - functional programming interface
 * @export
 */
export const VectorSearchNodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VectorSearchNodesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update
         * @param {Array<NodeRequest>} nodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNodesCollection(nodeRequest: Array<NodeRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNodesCollection(nodeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VectorSearchNodesApi.updateNodesCollection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VectorSearchNodesApi - factory interface
 * @export
 */
export const VectorSearchNodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VectorSearchNodesApiFp(configuration)
    return {
        /**
         * 
         * @summary Update
         * @param {Array<NodeRequest>} nodeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNodesCollection(nodeRequest: Array<NodeRequest>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateNodesCollection(nodeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VectorSearchNodesApi - object-oriented interface
 * @export
 * @class VectorSearchNodesApi
 * @extends {BaseAPI}
 */
export class VectorSearchNodesApi extends BaseAPI {
    /**
     * 
     * @summary Update
     * @param {Array<NodeRequest>} nodeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VectorSearchNodesApi
     */
    public updateNodesCollection(nodeRequest: Array<NodeRequest>, options?: RawAxiosRequestConfig) {
        return VectorSearchNodesApiFp(this.configuration).updateNodesCollection(nodeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VectorSearchQueriesApi - axios parameter creator
 * @export
 */
export const VectorSearchQueriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create
         * @param {VectorSearchQueryRequest} vectorSearchQueryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuery: async (vectorSearchQueryRequest: VectorSearchQueryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vectorSearchQueryRequest' is not null or undefined
            assertParamExists('createQuery', 'vectorSearchQueryRequest', vectorSearchQueryRequest)
            const localVarPath = `/vector-search/queries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vectorSearchQueryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VectorSearchQueriesApi - functional programming interface
 * @export
 */
export const VectorSearchQueriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VectorSearchQueriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {VectorSearchQueryRequest} vectorSearchQueryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuery(vectorSearchQueryRequest: VectorSearchQueryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageVectorSearchQueryResponseItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuery(vectorSearchQueryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VectorSearchQueriesApi.createQuery']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VectorSearchQueriesApi - factory interface
 * @export
 */
export const VectorSearchQueriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VectorSearchQueriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {VectorSearchQueryRequest} vectorSearchQueryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuery(vectorSearchQueryRequest: VectorSearchQueryRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageVectorSearchQueryResponseItem> {
            return localVarFp.createQuery(vectorSearchQueryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VectorSearchQueriesApi - object-oriented interface
 * @export
 * @class VectorSearchQueriesApi
 * @extends {BaseAPI}
 */
export class VectorSearchQueriesApi extends BaseAPI {
    /**
     * 
     * @summary Create
     * @param {VectorSearchQueryRequest} vectorSearchQueryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VectorSearchQueriesApi
     */
    public createQuery(vectorSearchQueryRequest: VectorSearchQueryRequest, options?: RawAxiosRequestConfig) {
        return VectorSearchQueriesApiFp(this.configuration).createQuery(vectorSearchQueryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VectorSearchQuestionsApi - axios parameter creator
 * @export
 */
export const VectorSearchQuestionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create
         * @param {VectorSearchQuestionRequest} vectorSearchQuestionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVectorSearchQuestion: async (vectorSearchQuestionRequest: VectorSearchQuestionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vectorSearchQuestionRequest' is not null or undefined
            assertParamExists('createVectorSearchQuestion', 'vectorSearchQuestionRequest', vectorSearchQuestionRequest)
            const localVarPath = `/vector-search/questions-collection`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vectorSearchQuestionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VectorSearchQuestionsApi - functional programming interface
 * @export
 */
export const VectorSearchQuestionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VectorSearchQuestionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {VectorSearchQuestionRequest} vectorSearchQuestionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVectorSearchQuestion(vectorSearchQuestionRequest: VectorSearchQuestionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageVectorSearchQuestionResponseItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVectorSearchQuestion(vectorSearchQuestionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VectorSearchQuestionsApi.createVectorSearchQuestion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VectorSearchQuestionsApi - factory interface
 * @export
 */
export const VectorSearchQuestionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VectorSearchQuestionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {VectorSearchQuestionRequest} vectorSearchQuestionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVectorSearchQuestion(vectorSearchQuestionRequest: VectorSearchQuestionRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageVectorSearchQuestionResponseItem> {
            return localVarFp.createVectorSearchQuestion(vectorSearchQuestionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VectorSearchQuestionsApi - object-oriented interface
 * @export
 * @class VectorSearchQuestionsApi
 * @extends {BaseAPI}
 */
export class VectorSearchQuestionsApi extends BaseAPI {
    /**
     * 
     * @summary Create
     * @param {VectorSearchQuestionRequest} vectorSearchQuestionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VectorSearchQuestionsApi
     */
    public createVectorSearchQuestion(vectorSearchQuestionRequest: VectorSearchQuestionRequest, options?: RawAxiosRequestConfig) {
        return VectorSearchQuestionsApiFp(this.configuration).createVectorSearchQuestion(vectorSearchQuestionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebAsyncsMetadataApi - axios parameter creator
 * @export
 */
export const WebAsyncsMetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a Web Async operation by its id.
         * @summary Get by id
         * @param {string} id The Web Async id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebAsync: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWebAsync', 'id', id)
            const localVarPath = `/webasyncs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all Web Async operations.
         * @summary List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/webasyncs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebAsyncsMetadataApi - functional programming interface
 * @export
 */
export const WebAsyncsMetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebAsyncsMetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a Web Async operation by its id.
         * @summary Get by id
         * @param {string} id The Web Async id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebAsync(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebAsync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebAsync(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebAsyncsMetadataApi.getWebAsync']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all Web Async operations.
         * @summary List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebAsync>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebAsyncsMetadataApi.list']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebAsyncsMetadataApi - factory interface
 * @export
 */
export const WebAsyncsMetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebAsyncsMetadataApiFp(configuration)
    return {
        /**
         * Get a Web Async operation by its id.
         * @summary Get by id
         * @param {string} id The Web Async id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebAsync(id: string, options?: RawAxiosRequestConfig): AxiosPromise<WebAsync> {
            return localVarFp.getWebAsync(id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all Web Async operations.
         * @summary List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(options?: RawAxiosRequestConfig): AxiosPromise<Array<WebAsync>> {
            return localVarFp.list(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebAsyncsMetadataApi - object-oriented interface
 * @export
 * @class WebAsyncsMetadataApi
 * @extends {BaseAPI}
 */
export class WebAsyncsMetadataApi extends BaseAPI {
    /**
     * Get a Web Async operation by its id.
     * @summary Get by id
     * @param {string} id The Web Async id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAsyncsMetadataApi
     */
    public getWebAsync(id: string, options?: RawAxiosRequestConfig) {
        return WebAsyncsMetadataApiFp(this.configuration).getWebAsync(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all Web Async operations.
     * @summary List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAsyncsMetadataApi
     */
    public list(options?: RawAxiosRequestConfig) {
        return WebAsyncsMetadataApiFp(this.configuration).list(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebAsyncsResponsesApi - axios parameter creator
 * @export
 */
export const WebAsyncsResponsesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a Web Async response by id.
         * @summary Get by id
         * @param {string} id The Web Async id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('get1', 'id', id)
            const localVarPath = `/webasyncs/{id}/pull`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebAsyncsResponsesApi - functional programming interface
 * @export
 */
export const WebAsyncsResponsesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebAsyncsResponsesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a Web Async response by id.
         * @summary Get by id
         * @param {string} id The Web Async id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebAsyncsResponsesApi.get1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebAsyncsResponsesApi - factory interface
 * @export
 */
export const WebAsyncsResponsesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebAsyncsResponsesApiFp(configuration)
    return {
        /**
         * Get a Web Async response by id.
         * @summary Get by id
         * @param {string} id The Web Async id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.get1(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebAsyncsResponsesApi - object-oriented interface
 * @export
 * @class WebAsyncsResponsesApi
 * @extends {BaseAPI}
 */
export class WebAsyncsResponsesApi extends BaseAPI {
    /**
     * Get a Web Async response by id.
     * @summary Get by id
     * @param {string} id The Web Async id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebAsyncsResponsesApi
     */
    public get1(id: string, options?: RawAxiosRequestConfig) {
        return WebAsyncsResponsesApiFp(this.configuration).get1(id, options).then((request) => request(this.axios, this.basePath));
    }
}



